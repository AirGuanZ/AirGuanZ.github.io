{"articles/2018.04.05.C99-Inline-Keyword":{"title":"C99 inline关键字","links":[],"tags":["C/C++"],"content":"被C99的inline坑了一把——根本就和C++的inline不是一个东西……\n一直以来都是C++用得比较多，这个学期做操作系统的课设用回了C，结果一波內联函数居然链接不过去……查了查资料，C99引入的inline和C++的inline语义区别是很大的，我算是踩了个坑。\nC++的inline除了建议编译器把函数内容内联以外，主要的作用就是能够让你把一个函数的定义在不同的编译单元里重复，而不会报链接错误。C99的inline则不然，它的语义是：\n\nAny function with internal linkage can be an inline function. For a function with external linkage, the following restrictions apply: If a function is declared with an inline function specifier, then it shall also be defined in the same translation unit. If all of the file scope declarations for a function in a translation unit include the inline function specifier without extern, then the definition in that translation unit is an inline definition. An inline definition does not provide an external definition for the function, and does not forbid an external definition in another translation unit. An inline definition provides an alternative to an external definition, which a translator may use to implement any call to the function in the same translation unit. It is unspecified whether a call to the function uses the inline definition or the external definition.\n\n大概可以总结为以下几点：\n\nInternal linkage的函数总可以用inline修饰，C代码中常见的static inline用法就是从这来的。\n在某个编译单元中，如果某个inline函数的任意一个declaration都没有用extern修饰，那么这个编译单元中的该函数定义称为内联定义。编译器可以选择使用内联定义（即接受建议），也可以不使用该定义，此时相当于这个定义不存在（即这个函数的调用需要链接其他编译单元的符号）。\n内联定义实际上是提供了对外部链接函数的一个“替代方案”。比如你在a.c中已经有了函数foo的定义，但是你在b.c中又给了个foo的内联定义，那么编译器可能会用b.c中给的内联定义，也可能视之不见。\n\n所以C语言的inline语义的正确使用方法应该有下面三种：\nstatic inline，不解释：\n// a.h\nstatic inline int func(int x) { /* ... */ }\n这样做可以模仿C++的inline语义：\n// a.h\ninline int func(int x) { /* ... */ }\n\n// a.c\nextern int func(int x);\n\n提供函数的“内联版本”，由编译器进行选择：\n// a.h\nint func(int x);\n\n//a.c\nint func(int x) { /* implementation [1] */ }\n\n// b.c\ninline int func(int x) { /* implementation [2] */ }\nvoid A(void)\n{\n    //...\n    i = func(j);\n    //...\n}\n\n最后一种用法中，implementation [1]和implementation [2]可以是不一样的。也就是说，我们可以为已有的函数提供一个“内联版本”，这个版本不需要和原版相同。至于用哪个，则由编译器决定。"},"articles/2018.04.27.Makefile-Dependency":{"title":"makefile中的依赖生成","links":[],"tags":["makefile"],"content":"不正确的makefile\n今天在改善我的玩具 Parser Generator AGZParserGen 的时候，我修改了一个头文件，然而当我敲下make的时候，它竟然告诉我目标已经是最新了。显而易见，这是写makefile的时候文件间的依赖关系出了问题。我不禁惊出一身冷汗来，因为在过去相当长的一段时间内，我都是使用同样的方式来自动生成文件依赖。以某个简单的C++项目为例：\nCC = clang++\nCC_INCLUDE_FLAGS = -I ./Include/\nCC_FLAGS = -std=c++11 -O2 $(CC_INCLUDE_FLAGS) -Werror -Wall\n \nCPP_SRC_FILES = $(shell find ./Source/ -name &quot;*.cpp&quot;)\nCPP_OBJ_FILES = $(patsubst %.cpp, %.o, $(CPP_SRC_FILES))\nCPP_DPT_FILES = $(patsubst %.cpp, %.d, $(CPP_SRC_FILES))\n \nDST = Output\n \n$(DST): $(CPP_OBJ_FILES)\n\t$(CC) $^ -o $@\n \n%.o: %.cpp\n\t$(CC) $(CC_FLAGS) -c $&lt; -o $@\n \n%.d: %.cpp\n\t@set -e; \\\n\trm -f $@; \\\n\t$(CC) -MM $(CC_FLAGS) $&lt; $(CC_INCLUDE_FLAGS) &gt; $@.$$$$.dtmp; \\\n\tsed &#039;s,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g&#039; &lt; $@.$$$$.dtmp &gt; $@; \\\n\trm -f $@.$$$$.dtmp\n \n-include $(CPP_DPT_FILES)\n \nclean:\n\trm -f $(DST)\n\trm -f $(CPP_OBJ_FILES)\n\trm -f $(CPP_DPT_FILES)\n\trm -f $(shell find ./Source/ -name &quot;*.dtmp&quot;)\n \nrun:\n\tmake\n\t$(DST)\n这里面隐藏了一个致命的错误，我很好奇为什么我以前都没有踩到这个大坑，但既然今天被我发现了，自然要拖出来批判一番。\n文件思路很简单，用shell find找到代码目录下所有的.cpp文件名（CPP_SRC_FILES），并通过后缀替换得到对应的.o文件名（CPP_OBJ_FILES）和.d文件名（CPP_DPT_FILES）。目标文件依赖于所有的.o，每个.o又依赖于自己的.cpp。\n当然，.o仅仅依赖于.cpp是不够的，还应该依赖于该.cpp中包含以及间接包含的所有文件。这一依赖关系就存放在.d文件中，且这些.d在第24行被引入该makefile中。那么.d文件有何来头呢？它们是第17~22行代码生成的，而这几行代码我是从网上直接抄的（数个博客中都是这一段代码，我真是日了哈士奇了），它就是导致依赖关系不正确的万恶之源。下面逐行地解析这段有问题的的代码。\n%.d: %.cpp\n\t@set -e; \\\n\trm -f $@; \\\n\t$(CC) -MM $(CC_FLAGS) $&lt; $(CC_INCLUDE_FLAGS) &gt; $@.$$$$.dtmp; \\\n\tsed &#039;s,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g&#039; &lt; $@.$$$$.dtmp &gt; $@; \\\n\trm -f $@.$$$$.dtmp\n\n第一行%.d: %.cpp是makefile的语法，意思是形如“%.d”的文件依赖于一个名为“%.cpp”的文件，这个没什么好说的。\n第二行@set -e;的含义是一旦出现错误，立即放弃执行后续的命令。加上这行是为了保证我看得到生成.d时的错误消息，而不是被后面一连串命令的输出掩盖。\n第三行rm -f $@;是删除已经存在的.d文件，其中$@是makefile的特殊语法，表示要生成的目标文件。\n第四个命令使用了gcc/clang都支持的一个特殊功能——加上-MM参数表示将源文件包含以及间接包含的文件（标准库除外）以依赖项的形式输出到标准输出流。这行命令末尾把编译器的输出重定向到一个.dtmp的文件中，其中$@是目标文件名，四个美元符表示当前进程号。.dtmp文件只是一个临时文件，稍后会被自动删除。\n第五个命令调用了sed，它是一个灵活的字符串操作工具，在这里用来将.d文件的依赖项插入到依赖文件内容中，并输出为需要的.d。这么说不太清晰，稍后举例即可看到。\n最后一个命令删除了之前临时存放依赖关系的文件。至此，.d文件的生成就大功告成了。\n举个简单的例子，我们在某个空目录下创建一个src目录，在其中放置a.cpp，a.h和b.h三个文件，它们包含如下内容：\n/* In a.h */\n#include &quot;b.h&quot;\n \n/* In b.h */\n#include &lt;iostream&gt;\n \n/* In a.cpp */\n#include &quot;a.h&quot;\n \nint main(void)\n{\n \n}\n现在要把src/a.cpp编译为src/a.o，我们期望的依赖是src/a.o src/a.d: src/a.cpp src/a.h src/b.h。假设我们使用上述的makefile来构建这个“项目”，那么clang++输出的临时文件会是：\na.o: src/a.cpp src/a.h src/b.h\n\n这一输出和我们期望的输出有两个差异，一个是该输出不包含.d文件的依赖关系，第五个命令中的sed就是用来添加这个关系的；另一个差异则是目标文件名——a.o和src/a.o完全不是一回事！很不幸，第二个差异是致命的，它不仅导致这个依赖关系无效（a.o根本不在$(DST)的依赖列表中），还导致sed命令无法查找到src/a.o进而无法添加.d文件的依赖关系。可以说，这样的依赖关系生成方案只能应对所有的.cpp都和makefile在同一个目录下的情况，一旦某个.cpp在别的目录下（比如这里的src/a.cpp），就会无法生成正确的依赖文件。\n说到这我就来气，网络上这么多博主都在博文中如是构建依赖关系，大部分人恐怕都只是你抄我我抄你罢了……\n错误修正\n要修复这个问题也很简单，那就是修改sed命令的参数，让它把这两个差异都处理掉。修改后的第五个命令如下：\nsed &#039;s,\\(.*\\)\\.o\\:,$*\\.o $*\\.d\\:,g&#039; &lt; $@.$$$$.dtmp &gt; $@;\n\n其中，\\(.*\\)\\.o\\:会匹配形如a.o:这样的字符串，并将其替换为路径正确的.o和.d文件名以及其后的:。这里$*是makefile的特殊语法，表示的是%.d中“%”所代表的字符串（即去掉了后缀的文件路径）。这一行命令能够正确地将clang++输出的\na.o: src/a.cpp src/a.h src/b.h\n\n替换为\nsrc/a.o src/a.d: src/a.cpp src/a.h src/b.h\n"},"articles/2018.06.23.CompGeoNote":{"title":"计算几何读书笔记","links":[],"tags":["Graphics"],"content":"第一次接触到计算几何，非常有意思。\nBookmark\nCGAA: Computational Geometry Algorithms and Applications 3rd\nLine Segment Intersection\n2018.6.22, CGAA\n问题. 给定一个大小为n的平面线段集合，其中每条线段由两个端点确定，求其中所有线段间的交点。\n两条线段是否相交可以O(1)确定，于是遍历所有无序线段对给出了Θ(n2)的暴力算法，这显然太naive了。容易观察到，线段si​和sj​相交的一个必要条件是它们在y轴（或者任意一个轴）上的投影存在重叠部分，于是我们可以给出以下改良：初始时所有线段的标记均为out，用一根sweep line从上往下扫描，每当遇到一条线段的entry point，就把该线段标记为in并测试它和所有其他处于in状态的相交性；每当遇到一条线段的exit point，就将其标记改回out。这一算法规避了在y轴上投影不重叠的线段间的相交测试。但是在y轴上投影重叠的两条线段可能在其他轴上相距很远，该算法在最坏情况下还是Θ(n2)的。\n进一步的改进基于以下观察：假设所有和sweep line相交的线段按交点的x坐标排序，则每条线段只需要和左右相邻的两条线段进行相交测试。\n在算法运行之初，所有线段都和sweep line不相交，因此这些线段两两“不相邻”。在sweep line向下运动的过程中，什么时候两条线段会变得相邻，从而需要进行相交测试呢？有以下几种情况——\n\n\nEntry事件：遇到某条线段sj​的entry point时，设此时和sweep line相交的线段按排序为…,si​,sj​,sk​,…，则sj​变得和si​以及sk​相邻。\n\n\nExit事件：遇到某条线段sj​的exit point时，若原来和sweep line相交的线段排序为…,si​,sj​,sk​,…，则si​和sk​变为相邻。\n\n\n交点事件：遇到两条线段si​和sj​的交点时，若原来和sweep line相交的线段排序为…,sh​,si​,sj​,sk​,…，则sh​和sj​变为相邻，si​和sk​变为相邻。\n\n\n基于此，只需从上往下地移动sweep line，每次遇到这种“变得相邻”的事件，就对当事的两条线段进行相交测试即可。Entry point和exit point事件都非常容易探测，而对于交点事件，我们有这样的结论：在sweep line移动到si​和sj​的交点p之前，si​和sj​一定已经经历过相交测试，即p一定已经被发现过了。这样一来，我们就可以保证不漏过任何一个“变得相邻”事件，从而找出所有的线段交点。\n该算法时间复杂度为O((n+k)logn)，其中n为线段数量，k为交点数量——建立和维护有序结构（比如使用红黑树）使得每次基本操作（插入删除查询等）是O(logn)的，而事件总数（entry+exit+intersect）则是O(n+k)的。\n注意这里没有叙述对一些微妙corner case的处理，比如如何handle水平线段、如何应对多条线段交于一点的情况等，它们并不会影响算法的时空复杂度，但实现的时候需要仔细处理。\nDoubly-Connected Edge List\n2018.6.22, CGAA\n考虑平面的一个联通子集上的区域划分，设区域边界都是直线，于是每个区域都是一个多边形。Doubly-Connected Edge List（DCEL）是用以表示该划分的一种数据结构，它支持以下操作：\n\n遍历某个面的所有边\n遍历通过某个顶点的所有边\n通过一个面的某条边访问占据该边的另一个面\n\nDCEL大概长这样：\nstruct vertex_t;\nstruct fce_t;\nstruct half_edge_t\n{\n    half_edge_t *succ, *prev, *twin;\n    vertex_t *origin;\n    face_t *face;\n};\nstruct vertex_t\n{\n    point2f coord;\n    half_edge_t *edge;     // arbitrary edge that has the vertex as its origin\n};\nstruct face_t\n{\n    half_edge_t *edge;     // arbitrary edge of its outer boundary\n    list&lt;edge*&gt; int_edges; // one for each hole in the interior\n};\n每条边被拆分为两条“half edge”，合称为一个“twin”。每个面由一系列half edge围起来，并且约定每条half edge的face位于它的左边（这保证了edge方向的一致性）。每条half edge都记录着它在自身所处的逆时针环中的前驱和后继，这构成一个循环链表。此外，half edge中还记录着其twin中的另一条half edge，以及自身的起点。\n其实这个结构挺trivial的，很容易根据定义想到上面列举的三种操作该如何实现。\nArt Gallery Theorem\n2018.6.22, CGAA\nSimple Polygon: regions enclosed by a single closed polygonal chain that does not intersect itself.\nDiagonal: an open segment that connects two vertices and lies in the interior of the polygon.\nTriangulation (of polygon): a decomposition into triangles by a maximal set of non-intersecting diagonals.\n通过对多边形顶点数n做归纳，容易证明：\nTheorem. Every simple polygon admits a triangulation, and any triangulation of a simple polygon with n vertices consists of exactly n−2 triangles.\n也就是说，线性输出规模的三角化对简单多边形总是可行的。在此基础上，容易证明三角化后的简单多边形的对偶图是一棵树，于是可以用线性时间对三角化的结果进行3着色，并得到以下推论：\nArt Gallery Theorem. For a simple polygon with n vertices, ⌊n/3⌋ cameras are occasionally necessary and always sufficient to have every point in the polygon visible from at least one of the cameras.\nOverlay of Two Subdivisions\n2018.6.23, CGAA\n给定两个平面上的subdivision S1​,S2​，定义它们的overlay O(S1​,S2​)为：面f∈O(S1​,S2​)当且仅当存在f1​∈S1​,f2​∈S2​使得f是f1​∩f2​的某个极大联通子集。\nO(S1​,S2​)的计算方法和所使用的subdivision表示方法息息相关，在这里假设是输入输出都用DCEL表示。容易证明两个输入DCEL中没有发生相交的那些half edge、face和vertex都可以原封不动地拷贝到输出DCEL中，需要重新计算的仅仅是S1​和S2​之间发生了相交的部分。\n考虑之前提到的全局线段求交算法，我们把两个DCEL中的edge临时视为closed segment，然后用求交算法求全局交点。在sweep line往下扫的时候，根据遇到的event point类型来修正DCEL的vertex和edge信息是不困难的，不过需要非常多的分类讨论。这个过程只需要保证一个invariant：在任意时刻sweep line上方的DCEL的vertex和edge是正确的。\n比较麻烦的是新face的计算，我们需要确定有哪些新face记录要添加，为遭遇变动的face更正edge指针，修改变动的face的edge中的face指针，以及为新face根据原face的label name赋予正确的label值。\n在之前的步骤中，已经计算了顶点和边的信息。每条half edge都处于唯一的一个循环链表中，这个edge half list称为一个“boundary”。给定一个boundary，如何判定它是一个face的外边界还是内部的hole的轮廓呢？这可以通过boundary中的lowest leftmost vertex的两条相邻edge间的转角结合“boundary中边的左边是它所处的face”的约定来实现。\n另外，由于face需要持有它所有boundary入口的链表，我们还需要判定哪些boundaries隶属于同一face。为此，考虑图G：\n\n每个boundary对应G中的一个顶点，此外对subdivision最外面的那个unbounded “face”，也设置一个对应的顶点。\n对两个boundaries，若其中一个是boundary of a hole，而另一个boundary中恰有half edge是hole boundary的lowest leftmost vertex左方最近的一条边，则这两个boundary对应的顶点间有一条边。若某个boundary地lowest leftmost vertex左侧没有half edge，它就和unbounded face对应地节点链在一起。\n\nLemma. G中的每个连通分量恰对应一个face的boundary集合。\n乍一看，图G的边集构造简直坑爹，但我们其实可以在sweep line扫描的过程中得到需要的信息——在每个event point处，很容易获得它左侧最近的边是哪条。\n这个算法时间复杂度还是O((n+k)logn)，其中n是S1​,S2​的复杂度之和。尽管算法的每一步都透露出trivial的气息，但是综合到一起颇有一种蒸汽朋克式的美感——也就是说，实现起来会很蛋疼。\n最后，基于这个算法，二维矢量多边形的布尔运算可以很容易地实现，算是回答了我一直有些好奇的问题吧。\nPolygon Triangulation\n2018.6.23, CGAA\nPolygon into Monotone Pieces\nMonotone: a simple polygon is called monotone with respect to a line ℓ if for any line ℓ′ perpecdicular to ℓ the intersection of the polygon with ℓ′ is connected. A polygon that is monotone with respect to the y-axis is called y-monotone.\n将多边形先转换为y-monotone pieces，能极大地简化将多边形三角化的过程。\nTurn Vertex: 相邻的两条边都朝下或者都朝上的顶点称为turn vertex。把多边形转为monotone的过程也正是去除turn vertex的过程。\nBelow &amp; Above: a point p is below another point q iff (py​&lt;qy​) or (py​=qy​∧px​&gt;qx​). A point p is above another point q iff (py​&gt;qy​) or (py​=qy​∧px​&lt;qx​)。也就是说先按y坐标从下到上排序，对y相同的点再按x坐标从右往左排序，“左上”的点是最“高”的。\nStart Vertex: a vertex v is a start vertex iff its neighbors lie below it and the interior angle at v is less that π.\nSplit Vertex: a vertex v is a split vertex iff its neighbors lie below it and the interior angle at v is greater than π.\nEnd Vertex: a vertex v is an end vertex iff its neighbors lie above it and the interior angle at v is less than π.\nMerge Vertex: a vertex v is a merge vertex iff its neighbors lie above it and the interior angle at v is greater than π.\n其他的顶点就是常规顶点（regular vertex）了。\nLemma. a polygon is y-monotone if it has no split vertices or merge vertices.\n这个算法依然是基于sweep line的，也就是拿一条平行于x轴的直线从上往下扫过待分割的多边形P，P的顶点集合就是所有的event point。现假设v1​,…,vn​为P所有顶点的一个逆时针排列，e1​=v1​v2​​,…,en​=vn​v1​​是多边形的边集，我们的目的是用适当的diagonals干掉所有的split vertex和merge vertex。\nHelper: 对某条边ej​，定义helper(ej​)为\nargvy​min​{v∣ℓy​&lt;vy​≤up(ej​),HorSeg(v,ej​) in P}\n即y​介于sweep line和ej​​的上端点之间的、到ej​​的水平线段完全位于P​中的顶点中最低的那个。显然，把split vertex连到它左侧最近边的helper顶点就能干掉这个split。\nMerge vertex的处理要更困难一些，因为它连接的对象是在sweep line的下方，即相关顶点的选择必须被推迟。设ej​是merge vertex vi​左侧最近边，则当sweep line扫描到vi​时，vi​必然成为ej​的helper顶点。在之后的扫描中，如果再次更新了ej​的helper，那么把vi​和ej​的新helper连接起来即可；否则，可以把vi​和ej​的下端点连接起来。所以，只需要每次更新某条边的helper或遇到某条边的下端点时，检查该边原本的helper是否时一个merge vertex即可。\n如何找一个顶点的左侧最近边就不记了，sweep line的拿手好戏。于是乎，把简单多边形剖分成y-monotone多边形的算法就出炉了：\nproedure make_polygon_into_monotone(P)\n    for each vertex v[i] in P, ordered by desc y coord\n        handle(v[i])\n\nprocedure handle_start_vertex(v[i])\n    helper(e[i]) = v[i]\n\nprocedure handle_end_vertex(v[i])\n    if(helper(e[i-1]) is a merge vertex)\n        connect(helper(e[i-1]), v[i])\n\nprocedure handle_split_vertex(v[i])\n    let e[j] = DirectLeft(v[i])\n    connect(helper(e[j]), v[i])\n    helper(e[j]) = v[i]\n    helper(e[i]) = v[i]\n\nprocedure handle_merge_vertex(v[i])\n    if(helper(e[i-1]) is a merge vertex)\n        connect(helper(e[i-1]), v[i])\n    let e[j] = DirectLeft(v[i])\n    if(helper(e[j]) is a merge vertex)\n        connect(helper(e[j]), v[i])\n    helper(e[j]) = v[i]\n\nprocedure handle_regular_vertex(v[i])\n    if the interior of P lies to the right of v[i]\n        if(helper(e[i-1]) is a merge vertex)\n            connect(helper(e[i-1]), v[i])\n        helper(e[i]) = v[i]\n    else\n        let e[j] = DirectLeft(v[i])\n        if(helper(e[j]) is a merge vertex)\n            connect(helper(e[j]), v[i])\n        helper(e[j]) = v[i]\n\n好优美的算法……\nTheorem. a simple polygon with n vertices can be partitioned into y-monotone polygons in O(nlogn) time with an algorithm that uses O(n) storage.\nTriangulating a Monotone Polygon\n没什么好说的，一个把杂乱的思路理得非常清楚，但又似乎很trivial的算法：\n把P的顶点分为左链和右链，并把所有顶点从上到下排序，记排序结果为u[1..n]\nprocedure triangulate_monotone_polygon(u)\n    stack.clear()\n    for j = 3 to n-1\n        if u[j].chain != stack.top().chain\n            while stack.size() &gt; 1\n                connect(u[j], stack.pop())\n            stack.push(u[j-1])\n            stack.push(u[j])\n        else\n            last_popped = stack.pop()\n            while !stack.empty()\n                last_popped = stack.pop()\n                if connect(last_popped, u[j]) != successful\n                    break;\n            stack.push(last_popped)\n            stack.push(u[j])\n    add diagonals from u[n] to all stack vertices except the first and the last\n\nTheorem. a simple polygon with n vertices can be triangulated in O(nlogn) time.\nPoint Location Query\n2018.6.24, CGAA\nTrapezoidal Map\n问题: 给定一个包含n条边的planar subdivision S和一个点q，求包含点q的f∈S。\n一种简单的做法是：过S的每个顶点作一条平行于y轴的直线，于是这些直线把整个平面划分为了O(n)个竖直条带，每个条带内部都不包含任何顶点。通过排序和二分查找，可以在O(nlogn)时间内确定一个点位于哪个条带中；同时，每个条带至多被n条互不相交的边划分为n+1个区域，给定条带内一点，可以在O(nlogn)时间内确定该点位于条带中的哪个区域中。这样一来，任给平面上一点，总能在O(nlogn)时间内找出包含该点的面来。\n这个算法的时间复杂度令人满意，却可能会占据O(n2)的额外空间，这对数据规模稍大的应用是不可接受的。\nNon-crossing: 称两条平面线段是不相交的，当且仅当它们的交集为空或只包含自己的端点。\n这里先引入一个预处理：用一个非常大的轴平行矩形R包含整个subdivision S，任何待查询的点若落在该矩形区域外，都一律视为落在unbounded区域中。于是在接下来的处理中，可以假设待查询点一定落在某个有限大小的面中。同时，我们使用“将坐标轴微微旋转一个小角度”的trick，使得顶点的x坐标两两不相同。经预处理后的这组线段被称为是“in general position”的。\n现考虑在S∪R的基础上，对每个顶点v∈S，过v向上方和下方各投出一条射线（分别称为v的upper extension和lower extension），直到撞上S∪R中的其他线段为止。将经该步骤处理后的subdivision记为T(S)。容易证明T(S)中的所有面都是梯形或三角形，如果把三角形视为一条边长度为0的退化版梯形，就可以把T(S)名正言顺地称作S的“trapezoidal map”——\n\nLemma. Each face in a trapezoidal map of a set S of line segments in general position has one or two vertical sides and exactly two non-vertical sides.\nTop &amp; Bottom: 每个梯形Δ一定有两个non-vertical sides，上面那个所对应的原S∪R中的边记作T(Δ)，下面那个对应的原S∪R中的边记作B(Δ)。\nLeft &amp; Right: 除了整个T(S)中最左侧和最右侧的两个矩形外，每个梯形Δ左侧如果有条垂直边，那么记引出该垂直边的那个原S中的顶点为L(Δ)，否则记T(Δ)和B(Δ)的唯一交点（位于Δ的左侧）为L(Δ)。类似地，可以定义R(Δ)。\n总而言之，一个梯形Δ由它的上下边界线T(Δ)、B(Δ)和左右定界点L(Δ)、R(Δ)唯一地确定。\nLemma. the trapezoidal map T(S) of a set S of n line segments in general position contains O(n) vertices and O(n) trapezoids.\nSearch Structure\n这里给出一种数据结构D，用来快速进行point location query的答复。D是一个带根结点的有向无环图，对T(S)中的每个梯形，D中都有一个对应的叶结点。内部结点可分为x结点和y结点，出度均为2。每个x结点指向S中某条线段的一个端点，每个y结点指向S中的一条线段。\n给定D和待查询点p，从根结点开始，在每个内部结点处选择向左或向右移动，直到移动到一个叶结点为止。对x结点，按照p位于该结点中存储的顶点的左侧还是右侧进行选择；对y结点，按找p位于该结点中存储的线段上方还是下方进行选择。这里暂且假设不会发生px​和x结点横坐标相等，或是p恰好落在y结点线段上的情况。下图是一个简单的T(S)和它可能对应的D：\n\n一般而言，以不同的顺序把元素插入一棵树中会影响到这棵树的结构，这里也不例外。在某些极端情况下，树搜索效率会退化得非常糟糕。这里给出一个随机算法，其运行时间和空间在期望意义上是令人满意的。\nprocedure trapezoidal_map(S: set of n non-crrssing line segments)\n    make R\n    init T as trapezoids of empty set\n    init D with a single leaf node corresponding to R\n    compute a random permutation s[1..n] of the segments in S\n    for i = 1 to n\n        find T[0..k] of trapezoids in T properly intersected by s[i]\n        remove T[0..k] in T\n        insert new trapezoids that appear because of the insertion of s[i] and T[0..k]\n        remove leaves of T[0..k] in D\n        create leaves for the new trapezoids\n        link the new leaves to the existing inner nodes in D\n\n设Si​={s1​,…,si​}，则该算法的每轮循环结束时，T始终是T(Si​)，D是T的一个合法search structure。可以看出这是一个增量算法。\n在从T(Si−1​)过渡到T(Si​)时，某个梯形Δj​不能被原样保留当且仅当si​和Δi​有交叉，因此循环体的第一步就是找出这些梯形T[1..k]（这里设T[1..k]按和si​的相交位置从左往右排升序，显然T[j]和T[j+1]相邻）。跟据Δj​很容易找出Δj+1​，因此只需要找出Δ0​即可。而Δ0​就是si​左端点所在的梯形（如果没有落在已有线段或顶点上的话），因此在现有的D（恰为T(Si−1​)的search structure）上进行一次point location query就能找出Δ0​。\n在查找Δ0​时，si​的左端点p可能已经在Si−1​中的某条线段上，这时会出现沿着D进行搜索时px​和x结点横坐标相等，或是p恰落在y结点线段上的情况。这时，可以把p在概念上沿着si​微微挪动向右到一个相邻的p′。这样一来，对搜索时对x结点重合的情况，总是将p视为位于x结点的右侧；对恰好落在y结点的线段s上的情况，若s斜率大于si​斜率，则认为p在s下方，反之上方。\n综合前两段的讨论，寻找Δ0​,…,Δk​即T[0..k]的算法为：\nprocedure find_Ts(T, D, s[i])\n    let p = left end point of s[i]\n    let q = right end point of s[i]\n    search with p in the search structure D to find T[0]\n    j = 0\n    while q lies to the right of R(T[j])\n        if R(T[j]) lies above s[i]\n            let T[j+1] = lower right neighbor of T[j]\n        else\n            let T[j+1] = upper right neighbor of T[j]\n        j = j + 1\n    return T[0..j]\n\n更新T和D的过程是复杂但平凡的，这里不再赘述。\nDegenerate Cases\n在之前的讨论中，算法略微旋转了坐标系，使得所有顶点的x坐标均无重合。由于实际计算机的计算精度相当有限，这一trick在实现上并不平凡。接下来，我们从理论上除去这一trick，方法是使用一个逻辑上的微量扭曲。对某个微小的ε&gt;0，构建如下顶点变换：\nφ:(xy​)↦(x+εyy​)\n\n在接下来的运算中，实际使用的线段集合为φS={φs∣s∈S}。由于真正进行这一变换会遭遇数值计算上的困难，我们将(x+εy,y)记作(x,y)。在上面给出的算法中，我们从来没有计算过任何新的几何对象位置，而仅仅是使用本来就有的坐标，并对它们做一些比较或判断。因此，这一逻辑上的微量扭曲可以反映到涉及x坐标的判断操作上，使得任何两点的x坐标都不发生重合。\n于是乎——\nTheorem. algorithm trapezoidal_map computes the trapezoidal map T(S) of a set S of n non-crossing line segments and a search structure D for T(S) om O(nlogn) time. The expected size of D is O(n) and for any query point q the expected query time is O(nlogn).\n期望时间的推导比较复杂，有闲心再看吧。\nVoronoi Diagram\n2018.6.24, CGAA\nDefinitions &amp; Properties\nEuclidean Distance: 平面上两点p,q间的欧氏距离定义为\ndist(p,q)=(px​−qx​)2+(py​−qy​)2​\nVoronoi Diagram: 给定平面点集P={p1​,…,pn​}，P所定义的Voronoi Diagram（维诺图）是一个planar subdivision，每个face对应一个pi​。平面上一点p位于某个pi​的face内，当且仅当\n∀pj​∈P,pj​=pi​⇒dist(p,pi​)&lt;dist(p,pj​)\n将点集P确定的维诺图记为Vor(P)。\nCell: V(pi​):=⋂1≤j≤n,j=i​h(pi​,pj​)，其中h(p,q)是以点p,q中线为边界的p那一边的半平面，即：\nV(pi​):=1≤j≤n,j=i⋂​{r∣dist(r,pi​)&lt;dist(r,pj​)}\nTheorem. for n≥3, the number of vertices in the Voronoi diagram of a set of n point sites in te plane is at most 2n−5 and the number of edges is at most 3n−6.\nCp: 定义CP​(p)为以p∈R2为中心的、内部不包含其他任何顶点的圆。显然CP​(p)是个闭集。\nTheorem. 点q∈R2是Vor(P)的一个顶点，当且仅当CP​(q)边界上有不少于3个P中的点。\nTheorem. pi​,pj​连线的垂直平分直线的一个子线段是Vor(P)的一条边，当且仅当存在点q∈R2使得CP​(q)∩P={pi​,pj​}\nComputation\n给定平面点集P，一种简单的计算其维诺图的方法是对每个pi​∈P，利用之前提到的布尔求交的方法计算n−1个半平面的交集，这将带来O(n2logn)的时间复杂度，没什么用。接下来要介绍的是著名的Fortune算法，时间复杂度为O(nlogn)。\nFortune算法也是基于sweep line的，它的框架和之前的线段求交算法有些相似——也有event point的概念。在sweep line ℓ移动的过程中，要保证Vor(P)在ℓ上方的部分都已被计算出来是不现实的，这是由于这部分可能依赖于ℓ下方的、还未被扫描到的点。Fortune退而求其次，维护任一时刻Vor(P)在ℓ上方、且和ℓ下方顶点无关的部分。\n首先我们需要一个标准——维诺图的哪部分一定不会受到ℓ下方的点的影响？换言之，在ℓ运动到某一位置时，设ℓ+是ℓ上方的半平面，哪些q∈ℓ+的argminp∈P​dist(p,q)是已知的？\n容易注意到，q到ℓ下方任何一个p∈P的距离都大于q到ℓ的距离，因此，若\ndist(q,ℓ)≥p∈P∩ℓ+min​dist(p,q)\n则q在维诺图中的归属不可能和ℓ下方的任何p∈P有关。可以证明，对每个p∈P∩ℓ+，到p的距离小于到ℓ的距离的点的边界是一条抛物线，于是我们有一系列这样的抛物线——\nβℓ​={βp​={q∣dist(p,q)=dist(ℓ,q)}∣p∈P∩ℓ+}\n称∪βℓ​的下边界为beach line。Beach line由多条抛物线的一部分（arc）构成，beach line上各arcs的分界点称为break point（断点）。可以证明，随着ℓ的移动，断点总是在Vor(P)的边上移动。\n\nObservation. the beach line is x-monotone, that is, every vertical line intersects it in exactly one point.\nSite事件: ℓ在扫描过程中遇到一个p∈P，称为一个site事件。Site事件会产生两个新断点以及一个arc。事实上，这也是唯一能够产生新arc的情景——\nLemma. 一个新arc只可能在site事件中出现。\nCircle事件: 对形成beach line上相邻的三段arc的的三个P中的点，称ℓ和它们所确定的圆相切为一个circle事件。\nLemma. 一个已有的arc只可能在circle事件中消失。\n其实有了site和circle事件的概念，我认为维诺图的算法就已经自然而然地出来了，只是这里有非常多的细节需要handle。需要注意的是：不是所有的arc都会在circle事件中消失；一些潜在的circle事件可能由于当事arc在别的circle事件中先消失而作废。\nTheorem. the Voronoi diagram of a set of n point sites in the plane can be computed with a sweep line algorithm in O(nlogn) time using (n) storage.\nDelaunay Triangulations\n2018.6.25\nLegal Triangulation\nTriangulation: a triangulation of P={p1​,…,pn​}⊂R2 is a maximal planar subdivision whose vertex set is P.\nTheorem. 设P中包含n个（不全共线的）顶点，其中有k个顶点位于构成P的凸包的多边形上，则P的任何三角化结果都包含2n−n−k个三角形，3n−3−k条边\nAngle Vector: 任给点集P的一个三角化结果T，若其中共包含m个三角形，则m个三角形共有3m个内角。这些内角非降序排列的结果A(T):=(α1​,α2​,…,α3m​)称为T的角度向量。定义同一点集P的不同三角化结果的角度向量间的全序关系为角度的词法序。称P的三角化结果T是角度最优的，当且仅当A(T)不小于任何其他P的三角化结果的角度向量。\nThale’s Theorem. 设直线ℓ与圆C交于a,b两点，p,q,r,s落在ℓ的同一侧。若p,q在C上，r在C内，s在C外，则∠arb&gt;∠apb=∠aqb&gt;∠asb。\n\nEdge Flipping: 在一个三角化结果T中，任取一条非边界边e，e两边的两个三角形共同构成一个以e为对角线的四边形。将e替换为该四边形的另一条对角线后，将会得到另一个三角化结果T′，这一替换操作称为一次edge flipping（边翻转）。边翻转会将两个三角形变为另外两个三角形。设翻转前两个三角形的六个内角为α1​,…,α6​，翻转后为α1′​,…,α6′​，称e是一条非法边，当且仅当mini​αi​&lt;mini​αi′​。\nTheorem. 设T包含非法边e，T′是翻转e的结果，则A(T′)&gt;A(T)。\n这里有一个平凡的消去非法边的算法：\nwhile there exists an illegal edge e\n    flip e\n\n由于在算法运行过程中，A(T)严格单调上升，因此该算法一定会停机，不过最坏效率就不敢恭维了。\nDelaunay Triangulation\nDelaunay Graph: 给定平面点集P，Vor(P)的对偶图称为P的Delaunay Graph，记作DG(P)。\nTheorem. Delaunary图总是可平面图。\nGeneral Position: 称一个点集是“in general position”的，当且仅当其中任意四个点都不在同一个圆上。这个概念用作点集的临时假设，可以简化算法叙述。\n把按照Delaunay Graph连接顶点得到的三角化结果称为Delaunay三角化。"},"articles/2018.07.13.Cpp-Sucks":{"title":"为什么要学Rust","links":[],"tags":["C/C++"],"content":"C++真是混乱邪恶的语言。\n比方说，我想来个泛型四维向量Vec4&lt;T&gt;，有一些这样的代码：\ntemplate&lt;typename T&gt;\nAGZ_FORCE_INLINE bool ApproxEq(const Vec4&lt;T&gt; &amp;lhs, const Vec4&lt;T&gt; &amp;rhs, T epsilon)\n{\n    return ApproxEq(lhs.x, rhs.x, epsilon) &amp;&amp;\n           ApproxEq(lhs.y, rhs.y, epsilon) &amp;&amp;\n           ApproxEq(lhs.z, rhs.z, epsilon) &amp;&amp;\n           ApproxEq(lhs.w, rhs.w, epsilon));\n}\n倒数第二行最后不小心多写了个括号。理想的编译器应该是这样的：\n\nXX行：找不到与’)‘配对的括号\n\n就算不那么人性化，也应该是这样的：\n\nXX行：unexpected token ’)‘\n\n而万恶的MSVC是这样的：\nutils\\src\\math\\mat4.inl(9): error C2039: “Mat4”: 不是“`global namespace&#039;”的成员\nutils\\src\\math\\mat4.inl(10): error C2143: 语法错误: 缺少“;”(在“{”的前面)\nutils\\src\\math\\mat4.inl(10): error C2447: “{”: 缺少函数标题(是否是老式的形式表?)\nutils\\src\\math\\mat4.inl(19): error C2988: 不可识别的模板声明/定义\nutils\\src\\math\\mat4.inl(19): error C2143: 语法错误: 缺少“;”(在“&lt;”的前面)\nutils\\src\\math\\mat4.inl(19): error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int\nutils\\src\\math\\mat4.inl(19): error C2374: “AGZ::Math::Mat4”: 重定义；多次初始化\nutils\\src\\math\\mat4.inl(9): note: 参见“AGZ::Math::Mat4”的声明\nutils\\src\\math\\mat4.inl(19): error C2059: 语法错误:“&lt;”\nutils\\src\\math\\mat4.inl(19): error C2039: “Mat4”: 不是“`global namespace&#039;”的成员\nutils\\src\\math\\mat4.inl(19): error C2039: “Data”: 不是“`global namespace&#039;”的成员\n...... 此处省略数十行和出错的地方风马牛不相及的东西 ......\nutils\\src\\math\\mat4.inl(121): error C2923: “AGZ::Math::Vec3”: 对于参数“T”，“T”不是有效的 模板 类型变量\nutils\\src\\math\\mat4.inl(122): error C2143: 语法错误: 缺少“;”(在“{”的前面)\nutils\\src\\math\\mat4.inl(122): error C2447: “{”: 缺少函数标题(是否是老式的形式表?)\nutils\\src\\math\\mat4.inl(153): error C2988: 不可识别的模板声明/定义\nutils\\src\\math\\mat4.inl(153): error C2143: 语法错误: 缺少“;”(在“&lt;”的前面)\nutils\\src\\math\\mat4.inl(153): error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int\nutils\\src\\math\\mat4.inl(153): error C2374: “AGZ::Math::Mat4”: 重定义；多次初始化\nutils\\src\\math\\mat4.inl(9): note: 参见“AGZ::Math::Mat4”的声明\nutils\\src\\math\\mat4.inl(153): error C2059: 语法错误:“&lt;”\nutils\\src\\math\\mat4.inl(153): error C2039: “Self”: 不是“`global namespace&#039;”的成员\nutils\\src\\math\\mat4.inl(153): fatal error C1003: 错误计数超过 100；正在停止编译\n\n几乎所有的错误都出现在和我写错的地方毫无关联的地方，换成gcc或者clang也好不到哪去。VS贴心地为我将错误以有问题的方式排了序，以至于编译器给出的首个错误被藏在一大票胡言乱语之间。\n且不提模板元编程，这只是个普普通通、毫无技巧的模板类，就给我搞出这种幺蛾子，更别提一个未定义operator&lt;的类和std::set一起就能搞出超过500行的错误提示了。"},"articles/2018.08.14.Coherence-and-Consistency":{"title":"缓存/内存一致性","links":[],"tags":["Architecture"],"content":"一直对存储一致性方面的东西一知半解，拖下去也不是办法，索性系统地学一学。\n参考：A Primer on Memory Consistency and Cache Coherence。\n引言\n多个处理器核心读写同一地址空间，这就是现在主流的shared memory system。由于在多核心情境下，有多种不同的系统行为都被视为是正确的，因此shared memory system的正确性定义也就变得困难起来，特别是硬件设计者常常期望这一定义宽松一些，使得他们能做更多的优化。\nCoherence和consistency是对shared memory correctness的人为划分，我暂且把它理解为通常所说的缓存一致性和内存一致性。\nCoherence的正确性很简单：cache对一切软件透明。我们除了能通过一些性能测试来估计cache的性质（比如CSAPP中那个著名的存储器山）外，无法从语义的层面获知关于cache的任何信息，只需要当它不存在就行了。\nConsistency correctness则会真真切切地影响软件的行为，它决定了程序所观测到的许多内存操作的结果，对程序员是可见的。举个简单的例子，Facebook开源的C++基础类库folly中有以下代码：\nstatic void incrementRefs(Char * p) {\n  fromData(p)-&gt;refCount_.fetch_add(1, std::memory_order_acq_rel);\n}\n \nstatic void decrementRefs(Char * p) {\n  auto const dis = fromData(p);\n  size_t oldcnt = dis-&gt;refCount_.fetch_sub(1, std::memory_order_acq_rel);\n  FBSTRING_ASSERT(oldcnt &gt; 0);\n  if (oldcnt == 1) {\n    free(dis);\n  }\n}\n显然这是某个跨线程用引用计数类进行资源管理的函数，这种事我过去都是直接拿std::atomic&lt;unsigned&gt;怼的。可是std::memory_order_acq_rel是啥玩意儿？我隐约记得自己在读前半本《C++ Concurrency in Action》的时候遇到过它，当时没怎么看懂。事实上，这一套东西就是内存一致性模型在C++中的体现，编译器会根据用户所指定使用的模式，结合目标平台所使用的一致性模型，生成尽可能优化的、符合用户期望行为的代码。\nBasic Coherence\n设想某芯片上有两个核心，它们各自拥有独享的L1缓存，共享L2缓存和主存。现在核心A和核心B都读取某个内存地址m处的值，都得到了结果42。在之后的某个时候，核心A把这个值改写成了43，但是此时核心B的L1缓存中的m处值依然是42，形成了cache incoherence。要避免这样的尴尬情境，就要定义一套cache coherence协议来保证cache如我们希望地那样工作。\n这里且不论如何设计和实现cache coherence协议，我们先把自己想要什么给说清楚，即准确地定义cache coherence是什么。\n最简单，也最直观的一个约束被称为single-writer-multiple-reader（SWMR）invariant。顾名思义，就是说在任意时刻只能有一个写者和多个读者。在SWMR约束中，时间轴被分为一系列相邻的时间段，每个时间段中要么只有一个核心在写，要么有0个或多个核心在读。此外，任何时间段内某核心读出的值都必须等于在此之前最后一个被写入被读取地址处的值，这被称作data value invariant。\n需要注意的是，在理论上cache coherence可以在任意粒度上定义，但实践中它往往是以一定大小的cache block为单位实现的。此时，SWMR保证对任意一个内存块，同一时刻至多有一个写者或多个读者。\nSequential Consistency\nCoherence和consistency在理论上是可以没什么关系的，即一个系统可以满足特定的consistency，却不满足cache coherence。但在现实中，cache coherence基本都是实现了的，因此在下面对consistency的讨论中，若非指明，均假设系统满足coherence。\n考虑下面的程序：\nCore 1:\n        data = VALUE\n        flag = 1\nCore 2:\n    L:  load r = flag\n        if flag == 0\n            goto L\n        load d = data\n\n假设一开始data未初始化，flag为0。很不幸，在许多平台上这段代码都是buggy的——硬件对内存操作的重排序可能会导致Core 2看到flag被设置为1了，却发现data仍然处于为初始化的状态。事实上，在现代处理器上，memory access reordering是非常常见（大概人手一个吧……）的优化，可以被粗略地分为以下三类：\n\nStore-store reordering：如果某个core使用non-FIFO write buffer，那么两个store操作就可能被重排。比如第一个store操作cache miss了，第二个命中了或者和更早的一个store合并了，第二个就能比第一个store更早地完成。即使core没有改变指令的执行顺序，这样的reordering也可能发生。\nLoad-load reordering：主要由instruction reordering造成。\nLoad-store and store-load reordering：即使按program order老老实实执行，最常见的FIFO write buffer也可能导致这种重排。\n\nSequential consistency（SC）：在每个core看来，memory order都符合program order。若某个core的操作A在program order层面先于操作B，就记A&lt;p​B；若某个内存操作A在memory order层面先于B，则记作A&lt;m​B。设a和b分别是两个内存地址（可能相同），Sequence consistency可以被以下几条规则表述：\n​L(a)&lt;p​L(b)⇒L(b)&lt;m​L(b)L(a)&lt;p​S(b)⇒L(b)&lt;m​S(b)S(a)&lt;p​L(b)⇒S(a)&lt;m​L(b)S(a)&lt;p​S(b)⇒S(a)&lt;m​S(b)ValueOf(L(a))=ValueOf(&lt;m​max​{S(a)∣S(a)&lt;m​L(a)})​\n除此之外，atomic read-modify-write（RMW）操作要求在它的load和store之间不能有任何别的内存操作插进来（即使操作地址不同）。这就是SC模型的全部约束了。\n当然，一个好的SC实现还应该避免starvation和尽量保证fairness，不过这不在模型的讨论范围内。\nTotal Store Order\nSC对编程人员很友好，但对硬件设计不怎么友好。考虑一个带write buffer的单核处理器，它对某地址A的store操作先进入write buffer，然后在合适的时机写入cache/主存。如果在该操作仍位于write buffer中时又来了个load from A的操作，可以这么解决：\n\n给core一个stalling，直到store完成后才执行load。\n引入bypassing机制，直接从write buffer把值取给load。\n\n在把这套机制推广到多核时，每个core都应该有自己的write buffer，显而易见而又理所当然。但是问题来了，试看下面的程序：\nCore 1:\n    set x = 1\n    load r1 = y\nCore 2:\n    set y = 1\n    load r2 = x\n\n其中x和y的初值均为0。如果按下面的顺序执行：\n\nCore 1和Core 2各自把store操作提交到write buffer中。\nCore 1和Core 2各自从y和x中读出0来。\nCore 1和Core 2的write buffer把store的值写入内存。\n\n这样一来，r1和r2的值都为0，这是违背SC模型的。要解决这个问题，要么会极大地增加设计复杂性，要么会降低处理器执行效率。结果，SPARC和x86设计者索性舍弃了SC，并采用了新的模型——Total Store Order（TSO）。在TSO模型下，r1和r2均为0是合法的。\nTSO的idea很简单——删除SC的Store-Load约束。这样一来，每个core就都可以简单地拥有自己的write buffer了。值得注意的是仍然保留的Store-Store约束要求这个write buffer必须是FIFO的。\n如果程序员不希望一个Store-Load操作被重排，可以使用一种被称为FENCE（内存屏障）的指令。在Core i上执行一条FENCE指令，意味着Core i中program order意义上所有FENCE前的内存操作在memory order意义上都先于program order意义上所有FENCE后的内存操作，即对Core i而言——\nA&lt;p​FENCE&lt;p​B⇒A&lt;m​B\n大部分情况下TSO都“does the right thing”，因此FENCE在这里并不常用。\n现在考虑下面的程序：\nCore 1:\n    set x = 1\n    load r1 = x\n    load r2 = y\nCore 2:\n    set y = 1\n    load r3 = y\n    load r4 = x\n\n其中x和y初值均为0。由于Store-Load可以被重排，程序运行是可能导致r2和r4均为0的。在这种情况下，大多数人会期许r1和r3也为0，因为：\n​L(r1​)&lt;p​L(r2​)⇒L(r1​)&lt;m​L(r2​)L(r1​)&lt;m​L(r2​)∧L(r2​)&lt;m​S(x)⇒L(r1​)&lt;m​S(x)L(r3​)&lt;p​L(r4​)⇒L(r3​)&lt;m​L(r4​)L(r3​)&lt;m​L(r4​)∧L(r4​)&lt;m​S(y)⇒L(r3​)&lt;m​S(y)​\n然而事实上，这并不是强制的。在TSO实现中，由于load r1和set x都在Core 1上执行，load的结果完全可以通过bypassing从Core 1的write buffer中取得。看起来这违背了TSO模型的约束？其实不然，TSO不仅修改了program order对memory order的约束，还修改了value of load的概念。是时候搬出TSO的形式化定义了：\n​L(a)&lt;p​L(b)⇒L(b)&lt;m​L(b)L(a)&lt;p​S(b)⇒L(b)&lt;m​S(b)S(a)&lt;p​S(b)⇒S(a)&lt;m​S(b)ValueOf(L(a))=ValueOf(&lt;m​max​{S(a)∣S(a)&lt;m​L(a)∨S(a)&lt;p​L(a)})​\nValueOf(L(a))的修改基本就是为了允许bypassing。\n最后是FENCE的定义，emm，这里面废话蛮多的：\n​L(a)&lt;p​FENCE⇒L(a)&lt;m​FENCES(a)&lt;p​FENCE⇒S(a)&lt;m​FENCEFENCE&lt;p​FENCE⇒FENCE&lt;m​FENCEFENCE&lt;p​L(a)⇒FENCE&lt;m​L(a)FENCE&lt;p​S(a)⇒FENCE&lt;m​S(a)​\n在历史上，x86的设计并没有显式地采用TSO。按照这本书作者的说法，目前似乎并没有x86内存模型的形式化描述，因此这一论断没有被严格证明，而是基于观察给出的。"},"articles/2018.08.16.AGI-Capter-4":{"title":"光照传输杂项","links":[],"tags":["Graphics"],"content":"主要是Advanced Global Illuminations第四章的内容。\n渲染方程\n简要地复习一下渲染方程，首先是原版：\nL(x→Θ)=Le​(x→Θ)+∫Ωx​​fr​(x,Ψ↔Θ)L(x←Ψ)cos(Nx​,Ψ)dωΨ​\n这是个第二类Fredholm积分方程，其中L(x→Θ)表示从位置x向Θ发射的辐射亮度；Le​是自发光项；Nx​是x处法线；Ωx​是以Nx​为中心的半球立体角；fr​(x,Ψ↔Θ)是BRDF，其形式化定义为：\nfr​(x,Ψ→Θ)=L(x←Ψ)cos(Nx​,Ψ)dωΨ​dL(x→Θ)​\n通常，BRDF函数的两个方向参数是对称的，所以也可以写做Ψ←Θ甚至Ψ↔Θ。\n令r(x,Ψ)表示从x处向Ψ方向发射射线所获得的最近交点，y=r(x,Ψ)，则有：\nL(x→Θ)=Le​(x→Θ)+∫Ωx​​fr​(x,Ψ↔Θ)L(y→−Ψ)cos(Nx​,Ψ)dωΨ​\n上述积分是在x的半球立体角上进行的，也可以把它改写成在场景中所有表面上的形式：\nL(x→Θ)=Le​(x→Θ)+∫A​fr​(x,Ψ↔Θ)L(y→yx​)V(x,y)G(x,y)dAy​\n其中G(x,y)=cos(Nx​,Ψ)cos(Ny​,−Ψ)/rxy2​为场景中任两个表面点间的几何因子。\n这些公式都是出射的，也可以写出入射形式：\nL(x←Θ)=Le​(x←Θ)+∫Ωy​​fr​(y,Ψ↔−Θ)L(y←Ψ)cos(Ny​,Ψ)dωΨ​\nL(x←Θ)=Le​(x←y)+∫A​fr​(y,Ψ↔yz​)L(y←yz​)V(y,z)G(y,z)dAz​\n重要性函数\n由于无法无限精确地表示场景中所有点朝所有方向的辐射亮度，几乎所有的照明算法都是在计算一些点集朝一些方向的辐射亮度均值。设S=As​×Ωs​表示希望纳入计算的、局部的表面点集和方向，则：\nΦ(S)=∫As​​∫Ωs​​L(x→Θ)cos(Nx​,Θ)dωΘ​dAx​\n若定义：\nWe​(x←Θ)={1,(x,Θ)∈S0,(x,Θ)∈/S​\n则S上的平均辐射亮度可以被表示为：\nLavg​=∫A​∫Ω​We​(x←Θ)cos(Nx​,Θ)dωΘ​dAx​∫A​∫Ω​L(x→Θ)We​(x←Θ)cos(Nx​,Θ)dωΘ​dAx​​\n这个Importance函数的意义是什么呢？给定场景中某个感兴趣的集合S，若将某单个的L(x→Θ)放置在场景的某个表面点上，它会对Φ(S)产生的贡献可以用来衡量x→Θ在S中的“重要程度”。形式化地，可以将W(x←Θ)定义如下：\n​We​(x←Θ)={1,(x,Θ)∈S0,(x,Θ)∈/S​W(x←Θ)=We​(x←Θ)+∫Ωz​​fr​(z,Ψ↔−Θ)W(z←Ψ)cos(Nr(x,Θ)​,Ψ)dωΨ​​\n其中z=r(x,Θ)。重要性函数值仅与场景的几何和材质特征有关，传递方式与辐射亮度的传播相似。\n由于重要性函数的定义形式和入射版本的渲染方程一模一样，于是可以对照着定义一个出射版（可以理解为某种“重要性发射器”）。令W(x→Θ)=W(r(x,Θ)←−Θ)，容易证明：\nW(x→Θ)=We​(x→Θ)+∫Ωx​​fr​(x,Ψ↔Θ)W(x←Ψ)cos(Nx​,Ψ)dωΨ​\n有了重要性函数，在实际计算辐射通量的时候，间接传播所作的贡献都被重要性函数纳入怀中了，因此有下面两个等价的公式：\n​Φ(S)=∫A​∫Ωx​​Le​(x→Θ)W(x←Θ)cos(Nx​,Θ)dωΘ​dAx​Φ(S)=∫A​∫Ωx​​Le​(x←Θ)W(x→Θ)cos(Nx​,Θ)dωΘ​dAx​Φ(S)=∫A​∫Ωx​​L(x→Θ)We​(x←Θ)cos(Nx​,Θ)dωΘ​dAx​Φ(S)=∫A​∫Ωx​​L(x←Θ)We​(x→Θ)cos(Nx​,Θ)dωΘ​dAx​​\n这样一来，我们就有了两种计算全局照明的思路：从S出发按照渲染方程“寻找”光源，或是从光源出发，计算光源对S的重要性函数。\n伴随方程\n首先引入两个线形算子：\n​TL(x→Θ)=∫Ωx​​fr​(x,Ψ↔Θ)L(r(x,Θ)→−Ψ)cos(Nx​,Ψ)dωΨ​QW(x←Θ)=∫Ωr(x,Θ)​​fr​(r(x,Θ),Ψ↔−Θ)W(r(x,Θ)←Ψ)cos(Nr(x,Θ)​,Ψ)dωΨ​​\n设L→表示出射辐射亮度，L←表示入射辐射亮度，W→,W←类似，则有：\n​L→=Le→​+TL→L←=Le←​+QL←W→=We→​+TW→W←=We←​+QW←​\n现定义A×Ω上的出射函数和入射函数间的内积为：\n⟨F→,G←⟩=∫A​∫Ω​F(x→Θ)G(x←Θ)cos(Nx​,Θ)dωΘ​dAx​\n则：\n​Φ(S)=⟨L→,We←​⟩Φ(S)=⟨Le→​,W←⟩Φ(S)=⟨L←,We→​⟩Φ(S)=⟨Le←​,W→⟩​\n容易验证T=Q∗，即T是Q的伴随算子，于是乎：\n​L←=Le←​+T∗L←W←=We←​+T∗W←​\n全局反射分布\n一切L都来自于Le​，这一关系由辐射亮度的传输方程给出。但是传输方程给出的式子是递归的，接下来给出一个非递归版本，称为全局反射分布函数（GRDF），记作Gr​(x←Θ,y→Ψ)。GRDF描述了场景中任意两处之间的光照传输属性，它满足：\nL(y→Ψ)=∫A​∫Ωx​​Le​(x→Θ)Gr​(x←Θ,y→Ψ)cos(Nx​,Θ)dωΘ​dAx​\n上式两边微分可得：\nGr​(x←Θ,y→Ψ)=Le​(x→Θ)cos(Nx​,Θ)dωΘ​dAx​d2L(y→Ψ)​\n事实上，BRDF可以被看作GRDF的一种特例。\n有了GRDF过后，辐射通量可以这样计算：\nΦ(S)=∫A​∫Ωx​​∫A​∫Ωy​​Le​(x→Ω)Gr​(x←Θ,y→Ψ)We​(y←Ψ)×cos(Nx​,Θ)cos(Ny​,Ψ)dωΨ​dAy​dωΘ​dAx​\nGRDF的好处在于，它提供的光照传输描述仅仅依赖于场景几何与材质。尽管重要性函数也具有这一特征，但它依赖于特定的S。话虽如此，由于参数空间维度太高，很难直接计算GRDF，而多采用蒙特卡罗之类的方法来估计。著名的双向路径追踪算法就可以被认为是基于GRDF的。"},"articles/2018.08.20.Monte-Carlo-Integration-Review":{"title":"蒙特卡洛积分入门","links":[],"tags":["Graphics"],"content":"最近脑子都快生锈了，复习一下基本方法。\n数值求积规则\n给定某定义域Ω（比如s维立方体[0,1]s）和其上的函数f:Ω→R，令测度函数为dμ(x)=dx1⋯dxs，则积分：\nI=∫Ω​f(x)dμ(x)\n常被用以下规则估值：\nI^=i=1∑N​wi​f(xi​)\n如何选择wi​和xi​？这可谓一个深不见底的大坑，常见的、针对一维情形的梯形法则、辛普森规则等大多具有形如O(n−r) (r∈N+)的收敛率。在高维情形下，这一规则可以被自然地推广为：\nI^=i1​=1∑n​i2​=1∑n​⋯is​=1∑n​wi1​​wi2​​⋯wis​​f(xi1​​,xi2​​,…,xis​​)\n推广版本的规则依然保持着O(n−r)的收敛率，但这要求N=ns个采样点。换言之，若保持采样数量N不变，则收敛率其实降低到了O(N−r/s)，维数一上去，效率就撑不住了。\n当然，不是所有高维求积规则都使用这种张量积的形式，但Bakhvalov定理已经说了，在座的各位都是垃圾：\nBakhvalow’s Theorem. 任给s维求积规则，存在具有r阶有界连续导数的函数f，f在该规则下的误差是O(N−r/s)。\n估计量\n给定积分：\nI=∫Ω​f(x)dμ(x)\n令估计量FN​为：\nFN​=N1​i=1∑N​p(Xi​)f(Xi​)​\n其中p是用于采样Xi​的概率分布函数。FN​的方差为\nV[FN​]​=V[N1​i=1∑N​p(Xi​)f(Xi​)​]=N21​i=1∑N​V[p(Xi​)f(Xi​)​]=N1​V[p(X)f(X)​]​\n可见FN​的收敛速度是O(N​)。即使V[f(X)/p(X)]是无穷，只要E[f(X)/p(X)]存在，根据强大数定律FN​也一定会收敛（只不过要慢一些）。\n随机变量采样\n\n已知分布函数P，令U是[0,1]上的均匀随机变量，X=P−1(U)，则X符合分布P。\n已知概率密度函数p，若存在概率密度函数q和常量M使得p(x)≤Mq(x)，则可先按q采样得到一个Xi​，然后在[0,1]内均匀采样得到一个Ui​，若\nUi​≤p(Xi​)/(Mq(Xi​))\n则令采样结果为Xi​，否则重来一遍。这样得到的采样点符合p。\nMetropolis方法，这里不详述。\n\n设FN​是某个量Q的一个估计量，则FN​−Q称为误差，误差的期望值称为偏差：\nβ[FN​]=E[FN​−Q]\n偏差为0的估计量被称为是无偏的（unbiased）。另一方面，一个估计量是一致的（consistent）当且仅当误差随N的增大以概率1收敛到0，即：\nPr{N→∞lim​FN​=Q}=1\n定义均方误差MSE[F]=E[(F−Q)2]，则：\nMSE[F]​=E[(F−Q)2]=(E[F2]−2E2[F]+E2[F])+(E2[F]−2E[F]Q+Q2)=E[(F2−2FE[F]+E2[F])]+E[(E2[F]−2E[F]Q+Q2)]=E[(F−E[F])2]+(E[F]−Q)2=V[F]+β2[F]​\n对无偏估计量而言，其MSE就等于方差。于是，对某个无偏估计量Y，设Y1​,Y2​,…,YN​是其N个独立采样值，则：\nV^[FN​]=N−11​⎩⎨⎧​(N1​i=1∑N​Yi2​)−(N1​i=1∑N​Yi​)2⎭⎬⎫​\n是无偏估计量\nFN​=N1​i=1∑N​Yi​\n的方差的无偏估计量。\n一些常见的减小方差的方法：\n用条件期望降维\n若能计算出：\nf(X)=∫f(x,y)dy    p(x)=∫p(x,y)dy\n则可作以下替换：\nF=p(X,Y)f(X,Y)​⇒F′=p(X)f(X)​\n这是因为：\nEY​[p(X,Y)f(X,Y)​]​=∫p(X,y)f(X,y)​p(y∣X)dy=∫p(X,y)f(X,y)​∫p(X,y′)dy′p(X,y)​dy=p(X)f(X)​​\n即F′(X)=EY​[F(X,Y)]。又注意到对随机变量G：\nV[G]​=E[G2]−E2[G]=EX​[EY​[G2]]−(EX​[EY​[G]])2=EX​[EY​[G2]−EY2​[G]]+(EX​[EY2​[G]]−(EX​[EY​[G]])2)=EX​[VY​[G]]+VX​[EY​[G]]​\n于是V[F]−V[F′]=EX​[VY​[F]]，可见这一变换消去了Y带来的方差。\n重要性采样\n如果采样所使用的概率密度函数和被积函数只差一个常数因子，那么方差甚至可以是0。然而要做到这一点需要事先知道积分结果，因此不具有实践意义。尽管如此，概率密度函数和被积函数形态还是越相似越好。一种常见的方法是随便拿什么拟合一下被积函数（比方说，分段线性），然后用归一化的拟合函数作为采样的概率密度。\nControl Variates\n这个翻译过来就是控制变量？总觉得怪怪的。若能找到一个形态与被积函数f相似但可以积出解析结果的函数g，则可以把原积分改写为：\nI=∫Ω​f(x)dμ(x)=∫Ω​g(x)dμ(x)+∫Ω​(f(x)−g(x))dμ(x)\n估计量也就变成了：\nF=∫Ω​g(x)dμ(x)+N1​i=1∑N​p(Xi​)f(Xi​)−g(Xi​)​\n这或许能有效地降低方差：\nV[p(Xi​)f(Xi​)−g(Xi​)​]≤V[p(Xi​)f(Xi​)​]\n事实上这个方法和重要性采样作用的途径相仿，因此在有了一个之后再用另一个往往效果不佳。Control variates可能在f严格非负的情况下带来负样本值，还有一些别的毛病，因此在图形学中没什么存在感。\n分块采样\n将积分域分成多块，每块分别估值，最后合起来。这东西不适合被积函数有奇异点或变化剧烈的情形，因而也在图形学中没什么存在感。\nQuasi-Monte Carlo\n想办法把采样点均匀地散布开来，这就是耳熟能详的QMC方法。\n首先定义一个衡量采样方案好坏的标准：差异度（Discrepancy）。令：\nPB∗​={x1​,…,xN​}⊂[0,1]s={[0,u1​]×…[0,us​]∣0≤ui​≤1}​\nP是一堆采样点，B则是一堆有个角位于原点的轴对齐盒子。在（不存在的）理想情况下，对每个体积为λ(B)的B∈B，B中都恰好包含着λ(B)N个点。于是，可以把这个理想和现实的差距定义为差异度：\nDN∗​(P)=B∈B∗sup​​N#{P∩B}​−λ(B)​\n低差异度序列：称点列x1​,x2​,…是一个低差异度序列，当且仅当对其任意前缀P={x1​,…,xN​}均有：\nDN∗​(P)=O(NlogsN​)\n可以证明使用低差异度序列的蒙特卡罗积分的误差为O(logsN/N)。尽管这看起来并不是很突出（logsN可能会很大，只有在N极大的时候才有优势），但QMC在实践中表现非常优秀，这大概是因为图形学的被积函数对QMC而言性质良好。\nHalton序列：设i的b进制展开形式为\ni=k≥0∑​di,k​bk\n将ϕb​(i)定义为\nϕb​(i)=k≥0∑​di,k​b−1−k\n称序列：\n{xi​}={(ϕb1​​(i),ϕb2​​(i),…,ϕbs​​(i))}\n为Halton序列，其中b1​,…,bs​两两互质（最常用的就是前s个素数）。特别地，若N在一开始就是已知的，则点集：\n{xi​}={(i/N,ϕ2​(i),ϕ3​(i),…,ϕps−1​​(i))}\n被称做Hammersley点集，其差异度为O(logs−1N/N)。"},"articles/2018.09.04.Quaternion":{"title":"四元数基础","links":[],"tags":["Graphics"],"content":"学了这么久的graphics，居然连四元数都迷迷糊糊的，真是丢人急先锋，索性花点时间相关东西理清楚。\n相关内容的C++实现\n复数与二维旋转\n二维情形下，将某个点(x,y)绕原点(0,0)逆时针旋转θ的变换矩阵为：\n[cosθsinθ​−sinθcosθ​][xy​]=[xcosθ−ysinθxsinθ+ycosθ​]\n也可以利用复数乘法的几何解释来完成旋转：\neiθ(x+iy)=(cosθ+isinθ)(x+iy)=(cosθ−ysinθ)+i(xsinθ+ycosθ)\n籍由这两种旋转表示方式的等价性，可以将其拓展到三维空间。\n三维旋转公式\n现需要在右手系下将向量a绕单位向量d旋转θ度，显然a可以被分解为平行于d和垂直于d的两个分量，其中前者无需修改：\n​a=a⊥​+a∥​a⊥​=a−a∥​a∥​=Projd​a=(a⋅d)d​\n若将ea⊥​​视为x′轴，将d视为z′轴，则求它们的叉积即可得到y′轴。此时只需要将经典的二维旋转变换应用到x′y′z′坐标系中的x′y′平面上，即可求出旋转后的a⊥′​，也就求出了a′=a⊥′​+a∥​。设Lp​=∣a⊥​∣，则a⊥​在x′y′z′中的坐标为(Lp​,0,0)，此时在x′y′平面上进行旋转变换，得到：\na⊥′​​=[ex′​​ey′​​]([cosθsinθ​−sinθcosθ​][Lp​0​])=cosθa⊥​+sinθ(d×a⊥​)=cosθa⊥​+sinθ(d×a)​\n从而旋转后的a′为\na′=a⊥​+a∥′​=(1−cosθ)(a⋅d)d+cosθa+sinθ(d×a)\n四元数\n顾名思义，四元数包含一个实部和三个虚部，虚部单位分别以i,j,k表示，它们满足：\nij=k, jk=i, ki=j, i2=j2=k2=−1\n四元数被定义为1,i,j,k的线性组合（没错，四元数定义到这就算结束了），加法减法乘法共轭以及范数都可以直接拓展复数的相关定义得到：\n(a+ib+jc+kd)+(e+if+jg+kh)(a+ib+jc+kd)−(e+if+jg+kh)(a+ib+jc+kd)×(e+if+jg+kh)(a+ib+jc+kd)∗∣a+ib+jc+kd∣​=(a+e)+i(b+f)+j(c+g)+k(d+h)=(a−e)+i(b−f)+j(c−g)+k(d−h)=(ae−bf−cg−dh)+i(be+af−dg+ch)+j(ce+df+ag−bh)+k(de−cf+bg+ag)=a−ib−jc−kd=a2+b2+c2+d2​​\n四元数a+ib+jc+kd常被记作[a,v]，其中：\nv=​bcd​​\n可以验证：\n[s,v]×[t,u][s,v]+[t,u][s,v]∗∣[s,v]∗∣​=[st−v⋅u,su+tv+v×u]=[s+t,v+u]=[s,−v]∗=∣[s,v]∣​\n最后来个逆：四元数q的逆是指满足qq−1=q−1=1的四元数q−1。根据q∗和q的长度关系，有：\n∣q∣2qq∗​=1⇒q−1=∣q∣2q∗​\n特别地，单位四元数的逆就是其共轭。\n四元数和三维旋转\n根据之前的讨论，有：\na⊥′​=cosθa⊥​+sinθ(d×a⊥​)\n若令四元数a⊥​=[0,a⊥​],d=[0,d]，则da⊥​=[0,d×a⊥​]，于是a⊥′​=[0,a⊥′​]满足：\na⊥′​=[0,cosθa⊥​+sinθ(d×a⊥​)]=cosθa⊥​+sinθ(da⊥​)=(cosθ+sinθd)a⊥​\n可见这一旋转可以认为是将四元数cosθ+sinθd作用到a⊥​上得到的。\n验证可知若d为单位向量，则[cosθ,sinθd]2=[cos(2θ),sin(2θ)d]，其意义很直观——如果把单位四元数q视为一个旋转变换，那么q2相当于进行两次这样的变换，即将旋转角翻倍。基于此，若令：\na′a∥​p​=[0,a]=[0,a∥​]=[cos(21​θ),sin(21​θ)d]​\n则有：\na′=a∥​+ppa⊥​=pp−1a∥​+ppa⊥​=pp∗a∥​+ppa⊥​\n容易验证pa∥​=a∥​p，pa⊥​=a⊥​p∗，代入上式得：\na′=pa∥​p∗+pa⊥​p∗=p(a∥​+a⊥​)p∗=pap∗\n这就得到了用四元数进行绕任意轴旋转的公式。\n球面线性插值\n我们通常用旋转矩阵来进行三维空间中的旋转操作，但这在需要对旋转角进行插值时（比如涉及到旋转的动画）并不好用，因为这不能通过直接对矩阵元素进行线性插值来实现。四元数则提供了一种方便的插值方式——由于旋转角θ在四元数中直接出现，因此可以把将θ线性插值的四元数用于旋转操作，这将提供一个平滑的旋转过程，称为球面线性插值（Spherical Linear Interpolation，Slerp）。\n设初始旋转四元数是q，结束旋转四元数是q′，插值系数为t∈[0,1]，若令：\nΔq=q′⇒Δ=q′q−1=q′q∗\n则Δ也是一个旋转四元数，它必然具有[cos(21​θ),sin(21​θ)d]的形式，此时对Δ的旋转角在[0,21​θ]间进行线性插值即可，即：\nq(t)=[cos(2t​θ),sin(2t​θ)d]\n在实际应用中，Slerp有个小坑——朝某个方向旋转θ角度和朝它的反方向旋转2π−θ在结果上是等价的，在插值过程中却表现得完全不同，因此，若q和q′间的夹角超过π，即q⋅q′&lt;0，则有必要将q′换成−q′后再进行插值。"},"articles/2018.10.12.Direct-Indirect-Path-Tracing":{"title":"路径追踪中的直接光照","links":[],"tags":["Atrc","Graphics"],"content":"问题\n最近开始写自己的离线渲染器Atrc，撸个暴力的路径追踪器很是容易，代码甚至只有十几行：\nSpectrum PathTracer::Trace(const Scene &amp;scene, const Ray &amp;r, uint32_t depth) const\n{\n​    if(depth &gt; maxDepth_)\n​        return SPECTRUM::BLACK;\n \n    Intersection inct;\n    if(!FindClosestIntersection(scene, r, &amp;inct))\n        return SPECTRUM::BLACK;\n    \n    Spectrum ret;\n    if(inct.entity-&gt;AsLight())\n        ret += inct.entity-&gt;AsLight()-&gt;Le(inct);\n    \n    auto bxdf = inct.entity-&gt;GetBxDF(inct);\n    auto bxdfSample = bxdf-&gt;Sample(-r.direction, BXDF_ALL);\n    if(!bxdfSample)\n        return ret + bxdf-&gt;AmbientRadiance(inct);\n    \n    auto newRay = Ray(inct.pos, bxdfSample-&gt;dir, 1e-5);\n    ret += bxdfSample-&gt;coef * Trace(scene, newRay, depth + 1)\n         * SS(Abs(Dot(inct.nor, bxdfSample-&gt;dir)) / bxdfSample-&gt;pdf)\n         + bxdf-&gt;AmbientRadiance(inct);\n    \n    return ret;\n}\n这里用一个最大追踪深度来截断过长的路径会导致渲染结果是有偏的，不过这一问题很容易解决（比如引入Russian Roulette策略等），不是本文要讨论的重点。从代码可以看出，路径追踪算法从摄像机镜头出发，沿着一条随机路径不断追寻光源，只有恰好击中了光源的路径才能为最终结果贡献出非零的辐射值（Radiance）。因此，光线越容易击中光源，算法收敛得越快；反之，如果光源很小或是被遮挡得很厉害（需要经过多次反射/折射才能击中），那么一条路径会以很小的概率击中光源并得到一个很亮的点，同时又以极大的概率无法击中光源从而得到黑色，这会导致画面上出现许多噪点。\n\n图中，中间是场景的几何形体，左边是用淡蓝色的“天空”把场景包裹起来后用100spp渲染的结果，右边则是在场景中添加一个很小的发光球体后用100spp渲染的结果。可以看到，左边的场景中路径很容易击中天空这一无比巨大的光源，而右边的场景中要击中这个小球则是一个概率很小的事件，这导致同为100spp，右边的噪点比左边的明显得多。这并不是场景的明暗导致的，而是光源过小或散射次数过多，很难被采样到导致的（小光源常常意味着较暗的场景，因此有许多人以为噪点多是由于场景亮度低）。\n理论\n回顾路径追踪的理论基础——渲染方程：\nL(x→Θ)=Le​(x→Θ)+Ls​(x→Θ)=Le​(x→Θ)+∫S2​fs​(Φ→x→Θ)L(x←Φ)dωΦ⊥​\n其中左侧的L(x→Θ)表示从x处沿方向Θ的出射辐射量，Le​(x→Θ)是该点作为光源贡献出的辐射，右侧的积分（积分域S2是球面立体角）则收集了从各个方向照射到x处的光，并计算被反射/折射（fs​描述了x处物体材质的反射/折射特点）到Θ方向的部分。大部分渲染方面的算法都和这一方程有千丝万缕的联系。\n该方程对应的蒙特卡洛估计量L^N​是：\nL^N​(x→Θ)=Le​(x→Θ)+N1​i=0∑N​p(Φi​)fs​(Φi​→x→Θ)L^N​(x←Φi​)∣Nx​⋅Φi​∣​\n其中对外来光的方向采样了N次，采样所使用的概率密度函数为p。路径追踪算法所使用的估计量就相当于L^1​，发射100条路径就等于是将100个L^1​的估值结果综合起来，这样得到的整体依然是一个L(x→Θ)的估计量。\n估计量L^N​(x→Θ)采样的对象是照射到x点处的外来光的方向。如果光源很小，那么能够采样到光源的立体角也就很小，而这些方向往往是L(x→Θ)的主要来源。依照重要性采样的原则，我们应当适当地修改p，使得采样到这些方向的概率变得更大。这个方案在实现上比较困难，因此我们考虑另一种方案——将对光源的采样分离出来。由于任意一个L都一定可以被分解为Le​+Ls​两部分，我们将渲染方程右侧的积分用此式稍微展开一下，得到：\nL(x→Θ)​=Le​(x→Θ)+∫S2​fs​(Φ→x→Θ)(Le​(x←Φ)+Ls​(x←Φ))dωΦ⊥​=Le​(x→Θ)+∫S2​fs​(Φ→x→Θ)Le​(x←Φ)dωΦ⊥​                        +∫S2​fs​(Φ→x→Θ)Ls​(x←Φ)dωΦ⊥​​\n根据立体角微元和面积微元间的关系：\ndω=r2dA⊥​\n可以将立体角上的积分转换为场景中所有表面M上的积分：\n​∫S2​fs​(Φ→x→Θ)Le​(x←Φ)dωΦ⊥​=                      ∫M​fs​(x′→x→Θ)Le​(x′→x)V(x,x′)∣x′−x∣2∣Nx′​⋅ex′→x​∣∣Nx​⋅ex→x′​∣​dAx′​​\n其中dA是M上的面积微元，V(x′,x)在x′与x间没有阻碍时为1，否则为0。根据自身性质，M可以被划分为发光表面Me​和不发光表面Mn​，其中Mn​上的任意一点x′对应的Le​(x′→x)均为0，于是上式的积分域M可以被缩减为Me​。这样一来，原本在S2上很难采样到小光源对应的方向，现在采样范围变成了光源的表面，哪有采不到的道理？\n综上，散射量Ls​可以被分割为Ls​=E+S两部分，E是光源直接照射到x点产生的散射，S则是由其他表面散射到x点并再次发生的散射。原来的渲染方程现在变成了：\nL(x→Θ)E(x→Θ)S(x→Θ)​=Le​(x→Θ)+Ls​(x→Θ)=Le​(x→Θ)+E(x→Θ)+S(x→Θ)=∫M​fs​(x′→x→Θ)Le​(x′→x)V(x,x′)∣x′−x∣2∣Nx′​⋅ex′→x​∣∣Nx​⋅ex→x′​∣​dAx′​=∫S2​fs​(Φ→x→Θ)Ls​(x←Φ)dωΦ⊥​​\n对应的估计量也发生了相应的改变：\nL^(x→Θ)E^(x→Θ)S^(x→Θ)​=Le​(x→Θ)+E^(x→Θ)+S^(x→Θ)=NE​1​i=0∑NE​​∣xi′​−x∣2p(xi′​)fs​(xi′​→x→Θ)Le​(xi′​→x)V(xi′​,x)∣Nxi′​​⋅exi′​→x​∣∣Nx​⋅ex→xi′​​∣​=NS​1​i=0∑NS​​p(Φi​)fs​(Φi​→x→Θ)(E^+S^)(x←Φi​)∣Nx​⋅Φi​∣​​\n初步实现\n改进后的PathTracer似乎要复杂许多，实际上也就是抄上面的估计量公式而已。用新的路径追踪器和旧的各自以10spp渲染一幅图像，对比如下：\n\n可以看到，在图像中绝大部分被照亮的地方，右侧新的追踪器（以后称为PathTracerEx）都比左侧的旧版本（称为PathTracer）不知高到哪里去了，正和我们的预期相符。\n当然，我们可以用两个追踪器各自以高采样数渲染一幅图像，对比结果以确保改进版本的正确性，这里不再详述。\n值得注意的是右侧光源正下方的一小块地面噪点明显，表现得还不如改进前的版本，这是因为此处地面离光源很近，Shadow Ray（用来判定光源上的采样点与物体表面间是否有障碍物）非常容易被光源自身遮挡住，很难产生实际有效的光源采样。这一问题可以通过修改光源采样策略，根据待照射点的位置进行重要性采样来改善。\n处理Specular表面\n看起来一切都很美好？让我们试试镜面球体——\n\n上图中左侧是改进后的结果，右侧是之前的结果。在高达1000spp的采样数下，改进后的追踪器依然比之前的有明显的收敛速度优势……等等，左边的镜子怎么不反射光源呢？\n事实上，这是一个比“收敛速度慢”要严重得多的问题。PathTracerEx通过在光源上采样来计算光照，但问题是镜面反射的反射分布是个δ-分布，连带着E也是在估值一个δ-函数的积分。而E^用一个非奇异的分布进行采样，能有效地采到δ​点才有鬼了。因此，对于镜面这样的特殊反射/折射分布（以后称这样的反射为Specular材质），在光源上采样是行不通的，还是得回到BRDF采样等能反映出其奇异性质的方法上来。\n既然知道了问题产生的原因，解决起来也不困难——每次求得射线与表面的交点时都根据交点处材质是否是Specular类型来决定使用哪一种采样方法即可。公式大而不难，就直接堆这儿了：\nL(x→Θ)Ls​(x→Θ)E(x→Θ)S(x→Θ)​=Le​(x→Θ)+Ls​(x→Θ)=⎩⎨⎧​​∫S2​fs​(Φ→x→Θ)L(x←Φ)dωΦ⊥​,E(x→Θ)+S(x→Θ),​fs​ is specular at xotherwise​​=∫M​fs​(x′→x→Θ)Le​(x′→x)V(x,x′)∣x′−x∣2∣Nx′​⋅ex′→x​∣∣Nx​⋅ex→x′​∣​dAx′​=∫S2​fs​(Φ→x→Θ)Ls​(x←Φ)dωΦ⊥​​\n对应的估计量：\nL^(x→Θ)L^s​(x→Θ)E^(x→Θ)S^(x→Θ)​=Le​(x→Θ)+L^s​(x→Θ)=⎩⎨⎧​​NLs​​1​i=1∑NLs​​​p(Φi​)fs​(Φi​→x→Θ)L^(x←Φi​)∣Nx​⋅Φi​∣​,E^(x→Θ)+S^(x→Θ),​fs​ is specular at xotherwise​​=NE​1​i=0∑NE​​∣xi′​−x∣2p(xi′​)fs​(xi′​→x→Θ)Le​(xi′​→x)V(xi′​,x)∣Nxi′​​⋅exi′​→x​∣∣Nx​⋅ex→xi′​​∣​=NS​1​i=0∑NS​​p(Φi​)fs​(Φi​→x→Θ)L^s​(x←Φi​)∣Nx​⋅Φi​∣​​\n小结\n再次改进的路径追踪器被称作PathTracerEx2，依然是抄上面的估计量公式。最后放上三个追踪器在10spp下的表现（选用如此低的采样数是为了充分表现不同采样器间的收敛速度差异）：\n\n中间的是普通的PathTracer，表现得一如既往地糟糕；左侧的PathTracerEx收敛得最快，可惜连镜面反射中的光源都漏掉了；右侧是最后的PathTracerEx2，运行效率比另外两个都略低一些，但正确性吊打PathTracerEx，收敛速度吊打PathTracer，令人满意。\n从上述的一系列实验和分析可以看到，收敛慢或结果有偏（比如PathTracerEx，在有镜面时可以说是有偏得不行了）几乎都是由与采样概率分布和函数形态差异太大导致的采样困难导致的。尽管本文最后给出的PathTracerEx2看似表现良好，若是面对接近Specluar但又不至于成为理想镜面的表面（比如略微粗糙的金属表面），按照在光源上采样的策略，可以预见收敛速度会很慢。这一缺陷可以用一些别的方法来改善，如多重重要性采样（Multiple Importance Sampling）等，那就不在本文讨论范围内了。\n本文所涉及到的三个路径追踪器的完整代码可以在这里找到。"},"articles/2018.10.15.Multiple-Importance-Sampling":{"title":"多重重要性采样","links":["articles/2018.10.12.Direct-Indirect-Path-Tracing"],"tags":["Atrc","Graphics"],"content":"前文提到当光源和物体表面材质都接近δ分布时，无论是在光源上采样还是按BSDF采样都可能带来很高的方差。本文讨论一种能很好地改善该问题的技术——多重重要性采样。\n我们常常需要通过采样来估计某个已知部分结构特征的函数的积分（比如f(x)=g(x)h(x)，但函数的具体值却又严重依赖于一组额外的参数，这导致我们很难在未知参数的情况下设计出一个足够好的采样策略。举个例子，基于光线追踪的离线渲染中每条路径上辐射值的系数都是一系列因子的乘积，如果仅仅按照其中某一个来采样（如在光源上采样，或是按BSDF采样等等），那么当其他未被该采样方法考虑的因子对乘积结果的形态有显著影响时，就会产生较高的方差，亦即较低的图像质量。\n多重重要性采样（multiple importance sampling，MIS）的思路是结合多种不同的采样方法，分别采样被积函数的不同部分，并将这些采样点结合起来，以达到接近于最优采样的结果。\n多采样模型（The multi-sample model）\n给定待求值的积分：\n∫Ω​f(x)dμ(x)\n和n种不同的Ω上的采样策略，其概率密度函数分别记为p1​,…,pn​。假设已经实现了以下操作：\n\n给定x∈Ω，可以求出f(x)和pi​(x)。\n对任意pi​，可以按其分布生成一个样本X。\n\n现假设我们已经决定了用pi​，来采样ni​≤1个样本，于是总采样数为N=∑i​ni​。记用第i个策略采样得到的第j (j=1,…,ni​)个样本为Xi,j​。现在的主要目标是用一种保证无偏的方式来结合所有的Xi,j​。考虑给每个采样策略赋予一个权重函数wi​ (i=1,…,n)，则多采样估计量可以被写作：\nF^=i=1∑n​ni​1​j=1∑ni​​wi​(Xi,j​)pi​(Xi,j​)f(Xi,j​)​\n要保证F是无偏的，以下两个条件必须被满足：\n\nf(x)=0⇒∑i=1n​wi​(x)=1。\npi​(x)=0⇒wi​(x)。\n\n基于这两点容易给出以下推论：对任意满足f(x)=0的x，至少存在某个i使得pi​(x)=0，即对f的每个非零点，至少要有一个pi​能采样到它。\nLemma. 若F^和wi​满足上面的两个无偏条件，且ni​≤1，则：\nE[F^]=∫Ω​f(x)dμ(x)\nProof.\nE[F^]​=i=1∑n​ni​1​j=1∑ni​​∫Ω​pi​(x)wi​(x)f(x)​pi​(x)dμ(x)=∫Ω​i=1∑n​wi​(x)f(x)dμ(x)=∫Ω​f(x)dμ(x)​\nThe balance heurostic\n多采样模型给出了一个巨大的无偏估计量空间以及在形式上高度统一的表示方式，我们的目标是找到合适的wi​以得到具有最小方差的F^。\nTheorem. 令：\nw^i​(x)=∑k​nk​pk​(x)ni​pi​(x)​\n若F^使用w^i​作为权重函数，F^′是使用另一组权重函数的多采样估计量，μ=E[F^]=E[F^′]是被估值量，则：\nV[F^]−V[F^′]≤(mini​ni​1​−∑i​ni​1​)μ2\n这一定理表明w^i​无论如何都是一个相当不错的权重函数——存在比它更好的，但不会有远胜过它的。\n现在把w^i​代入F^中，得到：\nF^=i=1∑n​ni​1​j=1∑ni​​(∑k​nk​pk​(Xi,j​)ni​pi​(Xi,j​)​)pi​(Xi,j​)f(Xi,j​)​=N1​i=1∑n​j=1∑ni​​∑k​Nnk​​pk​(Xi,j​)f(Xi,j​)​\n如果把上式进一步改写——\nF^=N1​i=1∑n​j=1∑ni​​p^​(Xi,j​)f(Xi,j​)​   where p^​(x)=k=1∑n​Nnk​​pk​(x)\n这就得到了一个在形式上非常标准的蒙特卡洛估计量。p^​被称为组合采样密度函数（combined sample density），是某个样本点x在全部N个采样点意义上的概率密度。\n综上，我们得到了以下采样算法：\nfunction BALANCE-HEURISTIC(f, p, n)\n    F = 0\n    N = n_1 + n_2 + ... + n_n\n    for i = 1 to n\n        for j = 1 to n_i\n            X = TakeSample(p_i)\n            hp = 0\n            for k = 1 to n\n                hp += n_k * p_k(X) / N\n            F += f(X) / hp\n    return F / N\n\n在路径追踪中的应用\n估计量\n像路径追踪这样有节操的算法是不会在某一条路径的某个点处采样多次的，每次出发它都一条路走到底，只不过要出发很多次罢了。因此，将上面的MIS转换为采样单个点的形式是有必要的。\n考虑计算直接光照的方程（方程来源和符号含义参见前文）：\nE(x→Θ)=∫S2​fs​(Φ→x→Θ)Le​(x←Φ)dωΦ⊥​\n面对此式，常用的采用策略是按p∝cos⟨Nx​,Φ⟩fs​采样（即所谓的BSDF采样）和将采样域变换到光源表面Me​上按Le​采样（即所谓的光源采样）。若是使用前一种方法，则当光源分布对结果影响较大时，噪点会非常明显；按后一种策略，则当BSDF描述的是光滑的表面（近乎镜面）时，图像质量也会较差。\n现在考虑用重要性采样将这两种采样策略结合起来。设想以c1​的概率选用BSDF采样策略，以c2​=1−c1​的概率选用光源采样策略，BSDF策略以p1​概率密度采样得到Φ，光源策略以p2​概率密度采样得到x′。令n1​=n2​=1，则估计量是：\nE^(x→Θ)E^i​f1​(Φ)f2​(x′)G(x′,x)w1​(Φ)w2​(x′)​=cI​E^I​​   I∈{1,2} sampled with (c1​,c2​)=pI​(XI​)wI​(XI​)fI​(XI​)​   I∈{1,2}=fs​(Φ→x→Θ)Le​(x←Φ)∣Nx​⋅Φ∣=fs​(x′→x→Θ)Le​(x′→x)V(x′,x)G(x′,x)=∣x′−x∣2∣Nx′​⋅ex′→x​∣∣Nx​⋅ex→x′​∣​=p1​(Φ)+p2​(Castx​(Φ))p1​(Φ)​=p1​(ex→x′​)+p2​(x′)p2​(x′)​​\n验证\n稍微验证一下E[E^]，设Castx​(Φ)表示从x出发沿Φ方向的射线与全体表面M的最近交点，则：\nE[E^(x→Θ)]​=E[p1​(Φ)w1​(Φ)f1​(Φ)​]+E[p2​(x′)w2​(x′)f2​(x′)​]=E[p1​(Φ)+p2​(Castx​(Φ))f1​(Φ)​]+E[p1​(ex→x′​)+p2​(x′)f2​(x′)​]=∫S2​p1​(Φ)+p2​(Castx​(Φ))f1​(Φ)p1​(Φ)​dωΦ​+∫M​p1​(ex→x′​)+p2​(x′)f2​(x′)p2​(x′)​dAx′​​\n令：\nMx,V​​={x′∈M∣Le​(x′→x)=0∧V(x′,x)=1}​\n对每个x′∈Mx,V​，都一定存在一个Φ使得Castx​(Φ)=x′，于是:\n∫M​p1​(ex→x′​)+p2​(x′)f2​(x′)p2​(x′)​dAx′​​=∫Mx,V​​p1​(ex→x′​)+p2​(x′)fs​(x′→x→Φ)Le​(x′→x)G(x′,x)p2​(Castx​(Φ))​dAx′​=∫Castx−1​(Mx,V​)​p1​(Φ)+p2​(Castx​(Φ))fs​(Φ→x→Θ)Le​(x←Φ)p2​(Castx​(Φ))​dωΦ⊥​​\n若规定上式积分内的式子在Le​(x←Φ)为零时也为零，就可以上述积分的积分域扩展到S2上，得到：\n∫M​p1​(ex→x′​)+p2​(x′)f2​(x′)p2​(x′)​dAx′​=∫S2​p1​(Φ)+p2​(Castx​(Φ))f1​(Φ)p2​(Castx​(Φ))​dωΦ​\n将此式代入E[E^(x→Θ)]，得到：\nE[E^(x→Θ)]​=∫S2​p1​(Φ)+p2​(Castx​(Φ))f1​(Φ)p1​(Φ)​dωΦ​+∫S2​p1​(Φ)+p2​(Castx​(Φ))f1​(Φ)p2​(Castx​(Φ))​dωΦ​=∫S2​f1​(Φ)dωΦ​=∫S2​fs​(Φ→x→Θ)Le​(x←Φ)∣Nx​⋅Φ∣dωΦ​=∫S2​fs​(Φ→x→Θ)Le​(x←Φ)dωΦ⊥​​\n这就验证了E^(x→Θ)是E(x→Θ)的无偏估计量。结合前文的内容，辐射值L(x→Θ)的单采样估计量是：\nL^(x→Θ)L^s​(x→Θ)E^(x→Θ)E^1​(x→Θ)E^2​(x→Θ)S^(x→Θ)​=Le​(x→Θ)+L^s​(x→Θ)=⎩⎨⎧​​p(Φ)fs​(Φ→x→Θ)L^(x←Φ)∣Nx​⋅Φ∣​,E^(x→Θ)+S^(x→Θ),​fs​ is specular at xotherwise​​=p(I)E^I​(x→Θ)​=p(Φ)+p(Castx​(Φ))fs​(Φ→x→Θ)Le​(x←Φ)∣Nx​⋅Φ∣​=(p(Castx−1​(x′))+p(x′))∣x′−x∣2fs​(x′→x→Θ)Le​(x′→x)V(x,x′)∣Nx′​⋅ex′→x​∣∣Nx​⋅ex→x′​∣​=p(Φ)fs​(Φ→x→Θ)L^s​(x→Θ)∣Nx​⋅Φ∣​​\n这就是实现带有多重重要性采样的PathTracer时需要抄的公式了。当然，这只是在计算直接光照时使用了MIS，我（也许）会在以后逐步讨论更广泛的应用。\n为什么需要单独处理Specular表面\n在前文对直接光照的讨论中，遇到Specular表面时需要完全用BRDF进行采样，那是因为在光源上采样会无法命中Specular表面的δ散射分布上的非零点。而本文讨论MIS技术号称能融合多种采样策略，只要每个点被至少一种策略覆盖即可，对Specular表面而言，其BSDF采样无疑就是一种覆盖了δ散射分布的采样策略，那为什么在上面的估计量中还需要单独处理Specular表面呢？\nCorner case是谁都不喜欢的，因此这里引入对Specular表面的单独处理也是迫不得已——我们根本无法正确地按蒙特卡洛估值技术来采样Specular表面，即使是朴素的路径追踪算法的处理也带有一定的trick性质，MIS要在这里发挥作用就更是无稽之谈了。试考虑某个理想镜面，反射颜色为c，设其法线为n，入射方向为wi​，则反射方向为：\nwo​=Ref(wi​)=(wi​⋅n)n−wi​\n于是BSDF为：\nfs​(Φ→x→Θ)=⎩⎨⎧​​Nx​⋅Φδ(Θ−Ref(Φ))​c,0,​Nx​⋅Φ&gt;0otherwise​​\nBSDF采样所使用的概率密度函数则是：\np(Φ)=δ(Θ−Ref(Φ))\n再看看算法中按照BSDF采样的代码：\n// struct BSDFSample {\n//     Spectrum color;\n//     Vec3 phi;\n//     float pdf;\n// };\nBSDFSample sample = bsdf.Sample();\nSpectrum t = RecursivelyTrace(NewRay(pos, phi));\nSpectrum ret = t * sample.color * Dot(normal, sample.phi) / sample.pdf;\n\n试问：如何用BSDFSample::color和BSDFSample::pdf表示δ函数的取值？这当然是不可能的，所以实践中一般把pdf设为1，把color设为c，使得最后sample.color/sample.pdf的值保持不变。\n而MIS却把sample.color/sample.pdf给拆解开来，在其中插入了别的量，此时这个trick会导致错误的结果。这就是我们尽管引入了MIS技术，还是得单独处理Specular表面的原因。当然，如何用编程技巧正确地处理δ分布，以去掉这个corner case，就是与本文无关的另外一个问题了。\n实现\n实现代码可以在这里中的PathTracer.h/cpp找到。随便摆个场景看看——\n\n最左边的是按BSDF进行100spp采样（也就是前文最开始用的方案）的结果，在稍微远离光源的地方惨不忍睹，这是意料之中的；中间的是前文给出的PathTracerEx2的结果，在靠近光源的地方由于无法有效地采样光源产生了很严重的噪声；最右侧的则是本文所讨论的MIS技术应用的结果，它在很难有效采样光源的地方没有产生很高的方差，在远离光源的地方表现也还不错。应该说，在每一种特定的情境下，都存在比MIS更好的采样策略，但当各种情境齐聚一堂时，MIS能够集各家之所长，得到一个满意解（而未必是最优解）。\n当然，上图中光源采样造成的噪点可以通过改善光源采样策略来消除，因此这不算是个很好的显示MIS优越性的例子。在后续文章中，我会引入一些光泽感较强的材质，那时MIS才可一鸣惊人。"},"articles/2018.10.22.Reflection-Models":{"title":"物理材质模型","links":[],"tags":["Atrc","Graphics"],"content":"在实现了Multiple Importance Sampling后，我发现Atrc居然没有Glossy类型的材质，以至于我很难构造一个能够展现MIS技术优越性的场景。因此，下一步个小目标就是实现一个能用的材质系统了。\nBSDF\nBSDF的全称是Bidirectional Scattering Distribution Function，即双向散射分布函数。对场景中的某个物体表面的一点，设想从Φ方向射来一束光，这束光必然被反射/折射向空间中的各个方向，而每个方向所分得的“比例”就是由BSDF描述的。\n本文使用符号fs​(Φ→x→Θ)表示入射方向为Φ时，x处的材质将这些辐射量反射到Θ方向的比例。严格地说，是出射辐射和入射照度之比：\nfs​(Φ→x→Θ)=dE(x←Φ)dL(x→Θ)​\n根据Lambertian定律和L与E间的关系，有：\ndE(x←Φ)=L(x←Φ)cos⟨Nx​,Φ⟩dωΦ​\n其中Nx​是x处的表面法线。将dL(x→Θ)表示成fs​(Φ→x→Θ)dE(x←Φ)，再在各个可能的ωΦ​上积分，就得到了：\nLs​(x→Θ)=∫S2​fs​(Φ→x→Θ)L(x←Φ)∣Nx​⋅Φ∣dωΦ​\nLs​(x→Θ)就是从其他地方照射到x处，再散射向Θ方向的辐射量了。如果再加上x处本身的自发光，我们甚至可以立刻导出渲染方程：\nL(x→Θ)=Le​(x→Θ)+∫S2​fs​(Φ→x→Θ)L(x←Φ)∣Nx​⋅Φ∣dωΦ​\n考虑到大部分材料都是不透明的，其BSDF的非零范围仅限于表面法线方向的半立体角H2而已，我们可以把BSDF定义域中的方向限制到H2上，得到的函数称为Bidirection Reflectance Distribution Function，即双向反射分布函数，简记为BRDF，用符号fr​表示。类似的定义还有描述折射的BTDF ft​等，这里不再赘述。\nPerfect Diffuse Reflection\n完美漫反射表面会将入射光均匀地反射到法线方向半立体角上的每一个方向，这样的材质在真实世界中应该是找不到的，但却是一种非常基本的“分量”，绝大部分材质的BRDF中都或多或少地包含了漫反射成分。\n将“均匀反射到各个方向”形式化，就得到了下述公式：\nfr​(Φ→x→Θ)=CONST_VALUE    Φ,Θ∈H2\n也就是说fr​是个常值函数。现在假设我希望有一个表面，它反射入射光的能量比例为a，且反射到各方向的辐射都是相同的，则fr​必然具有形式：\nfr​(Φ→x→Θ)=ca\n如何计算这个c呢？设入射照度为I，则出射照度为E=aI，据此：\nEEI​=aI=∫H2​(∫H2​caL(x←Φ)dωΦ⊥​)dωΘ⊥​=∫H2​L(x←Φ)dωΦ⊥​​\n联立解得\nc=π1​\n因此理想漫反射表面的BRDF为：\nfr​(Φ→x→Θ)=πa​    Φ,Θ∈H2\n随便画个图意思一下：\n\nFresnel Formula\n一束光照射到一个平滑表面时，有多大的比例被反射、折射或是吸收？我们的第一反应可能是给个反射系数/折射系数作为材质参数。但这个问题是可以从Maxwell方程组解出来的（好像还在《电磁场与波》这门课上解过……），若是凭感觉乱写，在真实感图形绘制中反倒落了下乘。\n给定两种绝缘体介质，设光从折射率为ηi​的一侧照射到两种介质的（平滑）分界面上，另一侧介质的折射率为ηt​，若忽略入射和出射光可能带有的极化特征，反射光的占比为：\nFr​r∥​r⊥​​=21​(r∥2​+r⊥2​)=ηt​cosθi​+ηi​cosθt​ηt​cosθi​−ηi​cosθt​​=ηi​cosθi​+ηt​cosθt​ηi​cosθi​−ηt​cosθt​​​\n其中θi​和θt​分别是入射光和折射光与分界面在各自一侧的法线的夹角。这个公式过于复杂，在实践中最常用的其实是它的近似拟合版本，称为Schlick公式：\nR(Θ)=(n1​+n2​n1​−n2​​)2+(1−(n1​+n2​n1​−n2​​)2)(1−cosθΘ​)5\n它在计算Specular反射的Fresnel因子时十分有效。由于下文介绍的Torrance-Sparrow微表面模型在某种意义上也是Specular反射，因此Schlick公式在那里也能使用。\n导体的Fresnel系数计算依赖于一个更加一般的公式，其中导体本身的“折射率”以ηt​+ik′的复数形式给出，k′代表了材料对入射光的吸收率。设η=ηt​/ηi​,k=k′/ηi​，入射角度为θ​，则：\nFr​r∥​r⊥​a2+b2a​=21​(r∥2​+r⊥2​)=r⊥​cos2θ(a2+b2)+2acosθsin2θ+sin4θcos2θ(a2+b2)−2acosθsin2θ+sin4θ​=a2+b2+2acosθ+cos2θa2+b2−2acosθ+cos2θ​=(η2−k2−sin2θ)2+4η2k2​=21​(a2+b2+η2−k2−sin2θ)​​\nPerfect Specular Reflection\n带有很多镜面反射的场景很适合用来展示光线追踪技术的威力，光栅化（在我的知识范围内）算法则无能为力。因此我以很高的优先度实现镜面反射。\n一般材质会将从某个方向来的光反射到许多方向去，因此这些方向的反射量可以用分布函数来描述；而镜面反射将某个方向Φ的入射光全部反射到另一个特定的方向Θ上去，如果依然用分布函数来描述，会形成在Θ上值为无限大，而在其他方向上值为零的尴尬情境。这样的情境下，我们称反射分布是一个奇异分布，并用δ函数来表示它。\n此外，在使用BRDF来计算辐射值时，都会根据Lambertian定律在fr​旁边乘上cos⟨Nx​,Φ⟩因子，这对理想镜面反射来说反而是画蛇添足了，因此在fr​中我们得除一下它。最终fr​的表达式是：\nfr​(Φ→x→Θ)=Fr​cos⟨Nx​,Φ⟩δ(Θ−Refx​(Φ))​\n其中Fr​是之前提到的Fresnel项，Refx​(Φ)是根据法线Nx​和入射方向Φ计算镜面反射出射方向的函数，用初中物理学过的“入射角等于反射角”就能推出来（假设法线和方向向量都是归一化的）：\nRefx​(Φ)=2(Φ⋅Nx​)Nx​−Φ\n材质效果如下：\n\nPerfect Specular Transmission\n有了理想反射自然就要有理想折射，这两者凑在一起才能制作出玻璃钻石之类的特效。然而折射的天然特性使得它比反射更困难一些——\n\n折射角和介质折射率有关，服从Snell定律\n要考虑全反射\n折射角的变化会“压缩”或“扩张”立体角微元，使得辐射值等比例地发生变化\n\n首先是Snell定律，也是初中物理学过的：\nηi​sinθi​=ηt​sinθt​\n据此可以根据入射角θi​计算出折射角θt​。当按此式计算出的sinθt​≥1时，就发生了全反射，使得折射量为零。\n现在来计算入射辐射量和折射辐射量之间的关系。根据Fresnel公式，折射的能量在入射能量中占比满足：\nLt​cosθt​dAdωt​=(1−Fr​)cosθi​dAdωi​\n对Snell定律两边求导易得：\nηt​ηi​​=cosθi​dθi​cosθt​dθt​​\n代入上式可得：\nLi​Lt​​=(1−Fr​)ηi2​ηt2​​\n这样一来，就能给出完整的BTDF了：\nft​(Φ→x→Θ)=(1−Fr​)ηi2​cos⟨Nx​,Φ⟩ηt2​δ(Θ−Transx​(Φ))​    Φ∈H2,Θ∈−H2\n其中Transx​(Φ)是按照Snell定律计算出的理想折射方向，易证明：\nTransx​(Φ)=[ηt​ηi​​(Φ⋅Nx​)−cosθt​]Nx​−ηt​ηi​​Φ\n当然，发生全反射时，ft​的值强制归零。\n我想不出什么东西会只有折射没有反射，那样也太违和了，所以完美折射的例子就用玻璃球吧，即反射和折射的结合体。该材质每次采样时以一半的概率选择反射，以另一半的概率选择折射，并将计算结果乘二以达到无偏，效果如下方左侧所示：\n\n这噪点不免也太多了点，得改进一下。注意到当入射光线和法线方向相近时，Fresnel项几乎是零，折射成分居多；而当入射光线和法线接近垂直时，Fresnel项几乎是一，反射成分居多。据此，在进行折射/反射的选择时，可以先计算出Fresnel项Fr​来，然后以Fr​的概率选择反射，这是重要性采样的思想。应用这一策略后的效果如上图右侧所示，和左边相比改善颇多。\n需要注意的是，玻璃材质的反射项计算也需要判断是否发生了全反射，这一点是上面的Perfect Specular Reflection中没有考虑的。反射和折射是相当难以调试的材质，因为即使代码中有问题，往往也能呈现出很不错的效果。\nTorrance-Sparrow Model\n近年来，随着硬件性能的提升，微表面材质模型在实时渲染中名声大噪，作为PBR（physically based rendering）的主力模型，哪个3A大作都得来上一套。事实上，这些模型在离线渲染中的存在感更强，著名的Torrance-Sparrow模型比我上一辈人的年龄都大，本节就讨论它的一些应用。\n微表面模型（Microfacet Model）假设物体表面有许许多多的被称为微表面（microfacet）的细小结构，它们在宏观上不可见，但也不至于小到光的波长量级，以至于影响我们使用几何光学来进行推导的程度。“宏观上不可见”的意思是我们所看到的物体表面点x处的反射特性是由x附近的大量微表面的统计性质决定的，因而我们不必去计算每个微表面的行为。特定的微表面模型往往会假设这些微表面具有某些特殊的形态，比如Oren–Nayar假设它们是“V”字形的漫反射表面，常用来对粗糙绝缘体表面建模；而本节的Torrance-Sparrow模型则假设微表面都是理想镜面，能很好地表现材质的高光特性，如较光滑的金属等。\n本节中讨论的微表面模型假设微表面构成宏观表面上的一个高度场，即微表面中不含“洞穴”结构。\nMicrofacet Distribution Function\n给定入射点x、入射方向Φ和出射方向Θ，令：\nH=∣Φ+Θ∣Φ+Θ​\n此时令D(H)表示x处法线位于dωH​内的微表面的面积和宏观表面面积dAx​之比，称为微表面分布函数。注意，这里的Θ,Φ,H都是在x点的（以Nx​为z轴的）局部坐标系中讨论。以理想镜面反射为例，如果我们从微表面的角度来看待它，那么所有的微表面都是平行于表面本身的，其D(H)是：\nD(H)=δ(H−(0,0,1))\n对x处的面积微元dAx​，给定方向H和它附近的立体角微元dωH​，则法线在dωH​内的微表面总面积为D(H)dωH​dAx​。这些微表面是朝向H的，因此它们的面积投影到宏观表面上后就只剩下：\ndAx,H⊥​=D(H)cos⟨Nx​,H⟩dωH​dAx​\n所有dAx,H⊥​之和必须是宏观表面总面积dAx​，这就得到了D(H)的归一化约束：\n∫H2​D(H)cos⟨Nx​,H⟩dωH​=1\n来看个例子：上古时期的Blinn-Phong分布满足D(H)∝cose⟨Nx​,H⟩，将右侧归一化，就得到了实际使用的分布函数：\nDBlinn-Phong​(H)=2πe+2​cose⟨Nx​,H⟩\n另外一个常用的分布是Beckmann–Spizzichino分布（这个式子是PBRT上看来的，我是真不知道咋来的）：\nD(H)=πα2cos4⟨Nx​,H⟩e−tan2⟨Nx​,H⟩/α2​\n设σ为微表面斜率的均方根，则α=2​σ。\n最后再记一个Trowbridge-Reitz分布，也是PBRT上的，对此我表示放弃治疗：\nD(H)=παx​αy​cos4θH​(1+tan2θH​(cos2ϕH​/αx2​+sin2ϕH​/αy2​))21​\n其中θH​是H与Nx​的夹角，ϕH​是H的极坐标表示中的水平旋转角分量。这样写着实方便，以后就用(θΓ​,ϕΓ​)来表示方向Γ好了。\nGeometry Attenuation Factor\n就算微表面中不存在洞穴结构，相近的微表面之间也可能会形成遮蔽，进而使得部分朝向正确的微表面无法为反射做出贡献。我们用G1​(Θ,H)来表示从Θ角度看时，法线为H的微表面中有多大比例能够幸运地免于被挡住，称它为Smith遮蔽阴影函数（Smith’s Masking-Shadowing Function）。\n给定x出的宏观面积微元dAx​，并从Θ角度去看它，那么看到的面积其实是cosθΘ​dAx​。法线与Θ夹角不超过π/2的微表面只要没被遮住，都应该可以被看到。现给定H附近的立体角微元dωH​，若H和Θ夹角小于π/2，则法线在dωH​中的微表面被看到的面积为：\nG1​(Θ,H)D(H)dωH​dAx​\n对所有这样的dωH​积分，就得到了从Θ角度看到的微表面总面积，这肯定等于cosθΘ​dAx​，于是我们推出了G1​的归一化条件：\n∫H2,cos⟨Θ,H⟩&gt;0​G1​(Θ,H)D(H)dωH​=cosθΘ​\n如果G1​的值仅与Θ有关而和H无关，那么可以把它简写为G1​(Θ)，而这正是图形学一般所使用的假设。至于这个假设有什么道理，emmm，不知道。\n每一块被遮蔽的面朝我们的微表面，都一定对应着一块遮蔽它的背对我们的微表面，而且它们在Θ方向上的投影面积是相等的。我们把法线和Θ夹角小于π/2的微表面在Θ方向的投影面积为A+(Θ)，称其他微表面在Θ上的投影面积为A−(Θ)，G1​就可以用这两个量表示出来：\nG1​(Θ)=A+(Θ)A+(Θ)−A−(Θ)​\n现令：\nΛ(Θ)=A+(Θ)−A−(Θ)A−(Θ)​\n那么G1​和Λ间的关系是：\nG1​(Θ)=1+Λ(Θ)1​\n一般来说，D给出的信息量不足以让我们是推出Λ，但如果假设表面上相邻两点间的高度不相关（这个假设看起来简直扯淡，但验证表明它实际造成的影响小得可以忽略不计，只是我们很难严格地分析），就可以推出一些D对应的Λ。Beckmann–Spizzichino分布的Λ为：\nΛ(Θ)=21​(π​2​∫0a​e−t2dt−1+aπ​e−a2​)\n其中a=1/(αtanθΘ​)。\n同样地，可以推出Trowbridge–Reitz分布的Λ是：\nΛ(Θ)=2−1+1+α2tan2θΘ​​​\nG1​还不能完全满足要求——我们的最终目的是给定Φ和Θ，求出没有被遮蔽的光线比例G。如果G1​(Φ)和G1​(Θ)之间是相互独立的，那么G就是它们的乘积，但现实中它们之间往往相关，乘积会过低地估计实际的遮蔽值。目前被广泛使用的一个G构造是：\nG(Φ,Θ)=1+Λ(Φ)+Λ(Θ)1​\n需要注意的是，该式只是一个非常符合实际测量结果的结果，就好比Schlick公式一样。理论上的确有更为精密、严谨的G，但那又过于复杂，以至于使用不便。\nTorrance-Sparrow Framework\n有了微表面分布函数和几何遮蔽函数，我们还需要一个把他们整合起来形成BRDF的式子。之前提到过，我们假设所有的微表面都是理想镜面，于是对入射方向Φ和出射方向Θ，设入射光辐射为LΦ​，考虑到只有法线为H的微表面才能为BRDF值做出贡献，有效的入射光通量为：\ndΨH​=LΦ​dωΦ​cos⟨H,Θ⟩D(H)dωH​dAx​\n于是出射能量为：\ndΨΘ​=Fr​(Θ)dΨH​\n根据定义，出射辐射为：\ndLΘ​=dωΘ​cosθΘ​dAx​dΨΘ​​\n联立以上三式，解得：\ndLΘ​=dωΘ​dAx​cosθΘ​Fr​(Θ)LΦ​dωΦ​D(H)dωH​dAx​cos⟨H,Θ⟩​\n式中的dωH​与dωΘ​之间有如下关系：\ndωH​=4cos⟨H,Θ⟩dωΘ​​\n这个式子的由来我会专门写篇博客来讲，它本身倒不值什么篇幅，但我要好好批判一番查证它的过程中遇到的坑，气得我都想挂人了。总之我们把dωH​给换成dωΘ​，乘上一个几何项G，就得到了：\ndLΘ​=4cosθΘ​Fr​(Θ)LΦ​D(H)GdωΦ​​\n将dEΦ​=LΦ​cosθΦ​dωΦ​代入上式，终于得到BRDF形式了：\nfr​(Θ→x→Φ)=4cosθΘ​cosθΦ​Fr​(Θ)D(H)G(Θ,Φ)​\n本文所讨论的微表面模型只不过是Torrance-Sparrow框架下的冰山一角，关于更多D和G的选取可参考这里。\nShow Time\n在实践中，我们可以测量物体表面的反射特性，然后用上述模型去拟合，从而得到合理的模型参数，这些就不是本文所能讨论的了。下面我将漫反射和高光反射叠加起来，通过控制两者的比例以及Fresnel项的类型，很容易得到塑料或金属质感的表面：\n"},"articles/2018.10.28.LTE-with-Participating-Medium":{"title":"介质渲染","links":["articles/2018.10.15.Multiple-Importance-Sampling"],"tags":["Atrc","Graphics"],"content":"著名的渲染方程并未将传播路径中的介质考虑在内，因而无法处理雾、牛奶等物质，也不能算出我最喜欢的丁达尔效应。本文讨论带有吸收、散射等性质的介质中的光线传输方程，以及基于它的路径追踪算法。\n光线传输方程（LTE）\n原始的渲染方程是：\n⎩⎨⎧​​L(x→Θ)=Le​(x→Θ)+∫S2​fs​(Φ→x→Θ)L(x←Φ)cos⟨Nx​,Φ⟩dωΦ​L(x←Φ)=L(Castx​(Φ)→−Φ)​​\n而带介质的版本就装逼多了：\n⎩⎨⎧​​L(x→Θ)=Le​(x→Θ)+∫S2​fs​(Φ→x→Θ)L(x←Φ)cos⟨Nx​,Φ⟩dωΦ​L(x←Φ)=Tr​(x′→x)L(x′→−Φ)+∫0tm​​Tr​(x′+ex′→x​t→x)Ls​(x′+ex′→x​t→−Φ)dtLs​(x→Θ)=Le​(x→Θ)+σs​(x→Θ)∫S2​P(Φ→x→Θ)L(x←Φ)dωΦ​Tr​(x′→x)=∫0tm​​σt​(x′+ex′→x​t→ex′→x​)dtx′=Castx​(Φ)     tm​=∣x′−x∣​​\n其中各项的含义会在后文中逐个解释。\n吸收与外散射\n考虑一束方向为Θ的光在空间中的x点因介质吸收而减弱的情形，若衰减的比例仅与这一点的介质性质以及光束本身的方向、波长有关，那么衰减量为：\ndL(x→Θ)=−σa​(x→Θ)L(x←−Θ)dt\n其中σa​是单位距离被吸收的光强比例，L(x←−Θ)表示这束光进入该传播距离微元的方向是−Θ，这和BSDF所使用的“入射”“出射”符号习惯是一致的。容易证明，一束从t=0处传播到t=d处的光剩下的辐射亮度比例为：\nexp(−∫0d​σa​(xo​+teΘ​→Θ)dt)\n除去吸收，介质也可能将光散射到其他方向，从而造成光强的衰减，这种散射称为外散射（out-scattering）。单位距离因外散射而损失的光强比例记作σs​，在只考虑外散射时，有：\ndL(x→Θ)=−σs​(x→Θ)L(x←−Θ)dt\n既然吸收和散射都会使光减弱，且具有统一的定义形式，不妨将它们合起来，称为衰减系数（Attenuation Coefficient）：\nσt​(x→Θ)=σa​(x→Θ)+σs​(x→Θ)\n另外，外散射与衰减的比例被称为反照率（albedo），没错，就是BSDF里也常见到的albedo：\nρ=σt​σs​​\n利用σt​可以计算出一束光在穿过一段介质后还剩多少，剩余量和一开始的辐射亮度之比称为透射比，记作Tr​：\nTr​(x′→x)=exp(−∫0d​σt​(x′+ex′→x​t→x)dt)\n自发光与内散射\n介质本身可能会因为内部的一些物理/化学过程而称为光源，我们将一束光在介质中传播单位距离后因介质自发光而增加的光强记作Le​，即若仅考虑介质自发光，那么：\ndL(x→Θ)=Le​(x→Θ)dt\n在外散射中被散射到其他方向的光理所当然地会增强其他方向的光的强度，这种增强叫做内散射。不同方向上的散射量也是不同的，这一分布与介质性质有关。对一束方向为Θ的光，设它被散射掉的部分为LΔ​，那么Δ在Θ′方向上的密度为：\nP(Θ→Θ′)=LΔ​dωΘ′​dLout-scattering​(Θ→Θ′)​\nP被称为相函数（Phase Function）。\n光在介质中传播时可能因介质的自发光和内散射而增强，我们把单位距离增加的辐射亮度记作Ls​，即：\ndL(x→Θ)=Ls​(x→Θ)dt\n根据上面对自发光和内散射的讨论，易知Ls​可以通过下式计算：\nLs​(x→Θ)=Le​(x→Θ)+σs​(x→Θ)∫S2​P(Φ→Θ)L(x←Φ)dωΦ​\n从出射到入射\n到目前为止，一开始放上的大坨公式中除了第二个（用来计算L(x←Φ)）外，其他的都已经在上面的一系列定义中给出了。设x′是从x朝Φ的射线与场景的第一个交点，在普通版本的渲染方程中，辐射亮度不会在空间传播过程中衰减，因而有L(x←Φ)=L(x′→−Φ)；而在有介质的情况下，我们需要把传播过程中光与介质发生的所有交互都纳入计算中。首先是L(x′→−Φ)被吸收和外散射导致的衰减：\nTr​(x′→x)L(x′→−Φ)\n然后在传播过程中的每一点p，都会因为自发光和内散射而得到一些增量，且这一部分增量在后续的传播中也要受到吸收和外散射的影响：\ndL+​=Tr​(x′+ex′→x​t→x)Ls​(x′+ex′→x​t→−Φ)dt\n把dt上得到的增量在传播路径上积分，再加上上面的Tr​(x′→x)L(x′→−Φ)，就得到了L(x←Φ)：\nL(x←Φ)=Tr​(x′→x)L(x′→−Φ)+∫0tm​​Tr​(x′+ex′→x​t→x)Ls​(x′+ex′→x​t→−Φ)dt\n其中tm​是x′和x间的距离。\n相函数\n本文仅考虑介质是各向同性的情况，即P(Φ→Θ)可以被简写为P(θ)，其中θ是入射方向和出射方向间的夹角⟨Φ,Θ⟩。根据能量守恒，P必须满足：\n∫S2​P(Φ→Θ)dωΘ​=1\n据此，最为平凡的相函数——将入射光均匀散射到所有方向的相函数，是将常数1在S2上归一化后的结果：\nP(Φ→Θ)=4π1​\n1941年，Henyey &amp; Greenstein提出了一个能够仅用一个参数就很好地拟合现实中许多物质测量结果的相函数公式，称为HG函数：\nPHG​(θ)=4π(1+g2+2gcosθ)3/21−g2​\n其中g是反对称参数（asymmetry parameter），可负可正。g越大，介质越倾向于把更多的光散射到和−Φ相近的方向。\n路径追踪\n框架\n要将这一大坨LTE转换为可以用蒙特卡洛方法来估值的形式，还要融入MIS等采样技术，就需要把LTE细致地分解开来。首先我们约定：用x表示表面（其实也就是不同介质的分界面）上的位置，用p表示介质内部的位置，于是L(x←Φ)和L(p←Φ)就有了完全不同的含义。在这一符号约定下，LTE变成了：\n⎩⎨⎧​L(x→Θ)L(x←Φ)L(p←Φ)Ls​(p→Θ)Tr​(a→b)​=Le​(x→Θ)+∫S2​fs​(Φ→x→Θ)L(x←Φ)dωΦ⊥​=⎩⎨⎧​​Tr​(x′→x)L(x′→−Φ)+∫x′x​Tr​(p→x)Ls​(p→−Φ)dlp​,∫ray(x,Φ)​Tr​(p→x)Ls​(p→−Φ)dlp​,​x′ existsotherwise​​=⎩⎨⎧​​Tr​(x′→p)L(x′→−Φ)+∫x′p​Tr​(p′→p)Ls​(p′→−Φ)dlp′​,∫ray(p,Φ)​Tr​(p′→p)Ls​(p′→−Φ)dlp′​,​x′ existsotherwise​​=Le​(p→Θ)+σs​(p→Θ)∫S2​P(Φ→p→Θ)L(p←Φ)dωΦ​=∫ab​σt​(p→ea→b​)dlp​​​\n此时，我们将表面上某点的出射光分解为自发光和散射光：\nL(x→Θ)=Le​(x→Θ)+L2​(x→Θ)\n其中L2​表示x点散射其他入射光而产生的出射光，其定义为：\nL2​(x→Θ)=∫S2​fs​(Φ→x→Θ)L(x←Φ)dωΦ⊥​\n由于介质的参与，L(x←Φ)的计算相当不平凡。为了书写简便，后文不再列出x′不存在时的情形（即LTE中的“otherwise”）。现令：\nD1​(x←Φ)D2​(x←Φ)​=Tr​(x′→x)Le​(x′→−Φ)=Tr​(x′→x)L2​(x′→−Φ)+∫x′x​Tr​(p→x)Ls​(p→−Φ)dlp​​\n则：\nL(x←Φ)=D1​(x←Φ)+D2​(x←Φ)\n于是L2​也可以对应地分解为两项：\nL2​(x→Θ)E(x→Θ)S(x→Θ)​=E(x→Θ)+S(x→Θ)=∫S2​fs​(Φ→x→Θ)D1​(x←Φ)dωΦ⊥​=∫S2​fs​(Φ→x→Θ)D2​(x←Φ)dωΦ⊥​​\n对应的估计量是：\nL^2​(x→Θ)=E^(x→Θ)+S^(x→Θ)\nE是所谓的直接照明项，和前文一样使用MIS技术来采样，只不过计算辐射亮度时都要乘上一个透射比罢了。S的采样则要复杂一些，因为它的里面出现了介质发光和内散射产生的增益。\n间接照明\n在计算S(x→Θ)时，设想我们用概率密度ps​进行BSDF采样，选取了入射方向Φ，且x′=Castx​(Φ)存在（x′不存在的情形更加简单，因此这里略过），那么S的估计量是：\nS^(x→Θ)=ps​(Φ)D^2​(x←Φ)fs​(Φ→x→Θ)cos⟨Nx​,Φ⟩​\n要计算D^2​，我们首先需要在线段x′x上以概率密度px′x​采样点p，然后根据D2​的定义：\nD^2​(x←Φ)=T^r​(x′→x)L^2​(x′→−Φ)+px′x​(p)T^r​(p→x)L^s​(p→−Φ)​\nL^s​的计算又涉及到对相函数P进行重要性采样。设概率密度函数为pP​，采样得到的方向为Φ，则：\nL^s​(p→Θ)=Le​(p→Θ)+σs​(p→Θ)pP​(Φ)P(Φ→p→Θ)L^(p←Φ)​\nL(p←Φ)和L(x←Φ)在形式上一样，其估计量的计算也完全相同，这里就不再赘述了。\n透射比\n根据定义，有：\nTr​(x′→x)=exp(−∫0d​σt​(x′+ex′→x​t→x)dt)\n因此，我们可以在[0,d]中以概率密度函数pT​选取NT​个t，然后令：\nT^r​(x′→x)=exp(−NT​1​i=1∑NT​​pT​(ti​)σt​(x′+ex′→x​ti​→x)​)\n路径追踪算法通常把NT​设置为1。如果是在均匀介质中，那么σt​处处相等，可以这样计算：\nT^r​(x′→x)=exp(−σt​d)\n小结\n总结上面的讨论以及过去MIS的文章（用来计算E^），就得到了以下的一系列估计量，其中涉及到采样的地方都将采样的概率密度和随机变量标注在式子后方：\n⎩⎨⎧​L^(x→Θ)L^2​(x→Θ)E^(x→Θ)E^1​(x→Θ)E^2​(x→Θ)G(x′,x)S^(x→Θ)D^2​(x←Φ)L^s​(p→Θ)L^(x←Φ)L^(p←Φ)T^r​(a→b)​=Le​(x→Θ)+L^2​(x→Θ)=E^(x→Θ)+S^(x→Θ)=E^1​(x→Θ)+E^2​(x→Θ)=ps​(Φ)+pℓ​(x′)Le​(x′→−Φ)fs​(Φ→x→Θ)cos⟨Nx​,Φ⟩​=(ps​(ex→x′​)+pℓ​(x′))Le​(x′→ex′→x​)fs​(ex→x′​→x→Θ)V(x′,x)G(x′,x)​=∣x′−x∣2cos⟨Nx​,ex→x′​⟩cos⟨Nx′​,ex′→x​⟩​=ps​(Φ)D^2​(x←Φ)fs​(Φ→x→Θ)cos⟨Nx​,Φ⟩​=T^r​(x′→x)L^2​(x′→−Φ)+px′x​(p)T^r​(p→x)L^s​(p→−Φ)​=Le​(p→Θ)+σs​(p→Θ)pP​(Φ)P(Φ→p→Θ)L^(p←Φ)​=T^r​(x′→x)Le​(x′→−Φ)+D^2​(x←Φ)= same as L^(x←Φ)=exp(−pT​(p)σt​(p→ea→b​)​)​[ps​,Φ][pℓ​,x′][ps​,Φ][px′x​,p][pP​,Φ][pT​,p]​​\n实现\n实现见Atrc中的VolumetricPathTracer。随便画了点东西：\n\n此外，我现在有点不知道该如何处理室外场景中雾和太阳光这样的光源的关系，后面再慢慢探究吧。"},"articles/2018.10.31.Tagged-Union-in-C++":{"title":"C++中的Tagged Union","links":[],"tags":["C/C++"],"content":"C中的union在C++中一直没有很好的替代方案，直到C++17引入了std::variant。\nstd::variant的用法到处都查得到，我不想写废话。不过每次使用都要手写一个class visitor实在是太智障了，这里参照cppreference的示例写个方便使用的Match：\ntemplate&lt;typename...Ts&gt;\nusing Variant = std::variant&lt;Ts...&gt;;\n \ntemplate&lt;typename E, typename...Vs&gt;\nauto MatchVar(E &amp;&amp;e, Vs...vs)\n{\n    struct overloaded : Vs...\n    {\n        explicit overloaded(Vs...vss) : Vs(vss)... { }\n    };\n    return std::visit(overloaded(vs...), std::forward&lt;E&gt;(e));\n}\n用法是这样的：\nVariant&lt;int, float, std::string&gt; tu = 5\nauto v = MatchVar(tu,\n    [](float f) { return f;        },\n    [](int x)   { return x + 2.0f; },\n    [](auto v)  { return 0.0f;     });\nassert(ApproxEq(v, 7.0f));\n有点像Rust的enum，只不过不允许手动指定Tag，只能拿类型当标记。现在稍微解析一下那一小段代码的原理。\nMatchVar的第一个模板参数就是Variant的类型，无需多言。后面的变长模板参数则是针对不同类型的值做不同处理的可调用对象的类型。在内部，我定义了一个overloaded类，它继承了这些对象的类型，也就是说这些对象都地是类而不是函数指针之类的东西。overloaded在继承Vs...的同时也继承了它们的operator()方法，它的构造函数则把这一大堆Vs基类初始化。\n最后就是用Vs...构造一个overloaded，再将它传递给std::visit了，没什么好说的。\n使用时需要注意的有两点：\n\n每个处理对象的返回值类型必须相同，不然通不过编译；\n处理对象的参数类型必须覆盖Variant包含的所有类型，否则会爆出完全看不懂的编译错误。可以用auto参数类型的lambda来处理缺省分支，就像Rust中的_。\n"},"articles/2018.11.13.BDPT":{"title":"双向路径追踪","links":[],"tags":["Atrc","Graphics"],"content":"本文讨论双向路径追踪算法的理论与实现。\n（这篇文章说得不太清晰，一是因为BDPT本来就很难讲，我建议直接去看Veach的PhD thesis，网上的博客之类的直接忽略；二是因为我这段时间花了些精力在毕业设计上，没太多心思去写博客。）\nLTE的路径和形式\n对场景中表面上的某点x和某方向Φ，用Cast(x,Φ)表示从x点沿方向Φ的射线与场景的首个交点。此时，光线传播方程（light transport equation，LTE）可以写作：\nL(x→Θ)=Le​(x→Θ)+∫S2​fs​(Φ→x→Θ)L(Cast(x,Φ)→−Φ)cos⟨Nx​,Φ⟩dωΦ​\n现在我们稍微扩张一下符号的含义：\nL(x→y)fs​(x→y→z)​=L(x→exy​)=fs​(eyx​→y→eyz​)​\n再结合立体角微元和投影面积微元间的关系，便可以将LTE的积分域改写到场景表面M上：\nL(x′→x)=Le​(x′→x)+∫M​fs​(x′′→x′→x)L(x′′→x)G(x′′↔x′)dAx′′​\n其中：\nG(x′′↔x′)=V(x′′↔x′)∣x′′−x′∣2cos⟨Nx′​,ex′x′′​⟩cos⟨Nx′′​,ex′′x′​⟩​\nV(x′′↔x′)在x′′和x′间没有遮挡物时为1，否则为0。现在我们不断把新LTE的左侧代换到它的右侧：\nL(x1​→x0​)​=Le​(x1​→x0​)+∫M​Le​(x2​→x1​)fs​(x2​→x1​→x0​)G(x2​↔x1​)dAx2​​+∫M​∫M​Le​(x3​→x2​)fs​(x3​→x2​→x1​)G(x3​↔x2​)                ×fs​(x2​→x1​→x0​)G(x2​↔x1​)dAx3​​dAx2​​+…​\n就得到了这样一个和式：\nL(x1​→x0​)=n=1∑∞​P(xn​)\n其中xn​指长度为n的路径xn​→xn−1​→⋯→x1​→x0​，P(xn​)是光源经n段传播过程后为最终结果作出的贡献：\nP(xn​)=n−1∫M​⋯∫M​​​Le​(xn​→xn−1​)(i=1∏n−1​fs​(xi+1​→xi​→xi−1​)G(xi+1​↔xi​))dAxn​​⋯dAx2​​​\n这就是LTE的路径和形式，它的含义是：L(x1​→x0​)可以拆成以下部分的和：\n\n场景中的自发光经0次散射后从x1​点射向x0​的辐射亮度（其实就是x1​点的自发光）\n场景中的自发光经1次散射后从x1​点射向x0​的辐射亮度\n场景中的自发光经2次散射后从x1​点射向x0​的辐射亮度\n……\n场景中的自发光经n次散射后从x1​点射向x0​的辐射亮度\n\nMeasurement Equation\n在之前的讨论中，我们总是说：只要对任意x和Φ能求解L(x←Φ)，就算是大功告成了。但是仔细一想：把图像上的每个像素放到场景中都是一个矩形，该像素的颜色和函数L(x←Φ)之间的联系似乎也不是那么清晰？\n事实上，设像素j在场景中对应的矩形区域是Mj​，j的颜色是由穿过Mj​的radiance flux决定的，也就是得在Mj​上积分。而且不是随便从哪个方向穿过Mj​的radiance都能被计入该flux中，只有特定方向的才能抵达摄像机镜头。以最基本的透视摄像机为例，设视点位置为xe​，对像素j上的每个点x，只有沿着方向x→xe​穿过x的radiance才能计入其中。我们简单粗暴地取这些radiance的均值作为j的“颜色”：\nIj​=∫Mj​​L(x←exe​x​)dωΦ​dAx​/∫Mj​​dAx​\n在这个例子中，每个点x仅对应唯一的方向xe​→x。在更为一般的摄像机模型中（如需要考虑镜头半径、焦距等），每个x可能对应了一个方向的集合，记作立体角函数Ωx​。Ωx​中每个方向对x的“颜色”贡献可能是不一样的，我们用一个分布函数来表达，称为像素j的局部重要性函数Wj​，此时Ij​可以被写作：\nIj​=∫Mj​​∫Ωx​​Wj​(x→ω)L(x←ω)cos⟨Nx​,ω⟩dωdAx​/∫Mj​​∫Ωx​​Wj​(x→ω)cos⟨Nx​,ω⟩dωdAx​\n具体到基本透视摄像机的例子里，根据：\n​∫Mj​​L(x←exe​x​)dωΦ​dAx​/∫Mj​​dAx​=Ij​=∫Mj​​∫Ωx​​Wj​(x→ω)L(x←ω)cos⟨Nx​,ω⟩dωdAx​/∫Mj​​∫Ωx​​Wj​(x→ω)cos⟨Nx​,ω⟩dωdAx​​\n可以解得：\nWj​(x→ω)=cos⟨Nx​,ω⟩δ(ω−exe​x​)​\n我们不妨将像素j的局部重要性函数延拓到整个M和整个S2，把Mj​以外的x对应的函数值规定为0即可。此外，Ij​中的分母对每个像素而言都是一个常量，不妨用它归一化一下好了，于是我们得到了这玩意儿：\nWe(j)​(x→ω)=⎩⎨⎧​​Wj​(x→ω)/(∫Mj​​∫Ωx​​Wj​(x→ω)cos⟨Nx​,ω⟩dωdAx​),0,​x∈Mj​,ω∈Ωx​otherwise​​\nWe(j)​就是所谓的重要性函数了，用We(j)​表示的Ij​是这样的：\nIj​=∫M​∫S2​We(j)​(x→ω)L(x←ω)cos⟨Nx​,ω⟩dωdAx​\n用立体角-面积转换把S2换成M，记原来的x为x0​，用x1​表示换出来的M上的点，就得到了所谓的Measurement Equation：\nIj​=∫M​∫M​We(j)​(x0​→x1​)L(x1​→x0​)G(x0​↔x1​)dAx1​​dAx0​​\n现在把LTE的路径和形式代入上式：\nIj​​=∫M​∫M​We(j)​(x0​→x1​)L(x1​→x0​)G(x0​↔x1​)dAx1​​dAx0​​=∫M​∫M​We(j)​(x0​→x1​)(n=1∑∞​P(xn​))G(x0​↔x1​)dAx1​​dAx0​​=n=1∑∞​∫M​∫M​We(j)​(x0​→x1​)P(xn​)G(x0​↔x1​)dAx1​​dAx0​​=n=1∑∞​n+1∫M​⋯∫M​​​We(j)​(x0​→x1​)T(xn​)G(x0​↔x1​)Le​(xn​→xn−1​)dAxn​​⋯dAx0​​​\n其中：\nT(xn​)=i=1∏n−1​fs​(xi+1​→xi​→xi−1​)G(xi+1​↔xi​)\n路径采样\n从LTE的路径和形式看来，我们可以在路径空间上直接采样路径，以对Ij​进行估值。如果我们从摄像机出发一路采样出一条路径，就相当于是在使用路径追踪算法；如果我们从光源出发采样进入摄像机镜头的路径，就相当于是在使用“light tracing”。双向路径追踪则是两者的结合：从摄像机出发采样一条子路径（subpath），同时也从光源出发采样一条子路径，最后将这两条子路径连接起来。想法很简单，难点在于如何计算最后得到的路径的采样概率密度，以及一堆奇奇怪怪的corner cases。\n首先描述一下从摄像机出发得到子路径的过程：我们让摄像机发射一条射线，一路按照与场景中其他物体的交点处的BSDF进行采样，且使用轮盘赌策略来结束采样过程。现用x0​,x1​,…来表示该子路径上的点（x0​是镜头上的点），它们附带了一系列概率密度：\npeye​(x0​),p(ex0​x1​​∣x0​),p(ex1​x2​​∣x1​),⋯\npeye​(x0​)和p(ex0​x1​​∣x0​)是由摄像机给出的，后续的条件概率则是由每一次BSDF采样所使用的概率密度函数所决定的。注意条件概率中需要把轮盘赌的成功概率也算进去。类似地，对从光源出发的子路径y0​,y1​,…，也有相似的计算过程。\n最后，我们把x0​x1​⋯xs​和yt​yt−1​⋯y0​连接起来构成一条完整路径p​s,t​：\nx0​x1​⋯xs−1​xs​yt​yt−1​⋯y1​y0​\n它的throughput值是：\nT(p​s,t​)=×××​fs​(x2​→x1​→x0​)fs​(x3​→x2​→x1​)⋯fs​(xs​→xs−1​→xs−2​)fs​(yt​→xs​→xs−1​)G(xs​,yt​)fs​(yt−1​→yt​→xs​)fs​(yt−2​→yt−1​→yt​)⋯fs​(y1​→y2​→y3​)fs​(y0​→y1​→y2​)We​(x0​→ex0​x1​​)cos⟨Nx0​​,ex0​x1​​⟩Le​(y0​→ey0​y1​​)​\n整条路径的采样概率则是上面那一大堆概率密度之积：\np(p​s,t​)=peye​(x0​)p(ex0​x1​​∣x0​)⋯p(exs−1​xs​​∣xs​)p(eyt−1​yt​​∣yt−1​)⋯p(ey0​y1​​∣y0​)plight​(y0​)\n路径重用\n在刚刚已经推出的方案中，我们每次只采样一条路径，将该路径的throughput除以其概率密度函数值，就可以拿来对Ij​估值了。Veach很天才地想到：我们能不能把摄像机子路径的每个前缀和光源子路径的每个后缀都连接起来，从而得到一大堆子路径呢？这样做唯一的问题就是这一组路径间存在相关性，但只要我们重复这样的过程许多次，得到N组路径，那么某条长度为n的路径和这里面N−1个组中长度为n的路径都是无关的。随着N的增大，我们仍然可以保证估值无偏地收敛到正确的结果。并且当组数增大时，组内路径的相关性在全体路径中会显得愈发微不足道，即correlation也会收敛到0，不会对结果产生视觉可见的影响。\n在使用了路径重用技术后，我们注意到，在每一轮采样（生成两条子路径并连接它们得到一堆路径，这样的过程称为一轮采样）中，一条长度为k的路径有k+1个顶点，也就对应了k+1种采样方式。比如一条长度为2的路径有以下三种采样方式：\n\n长度为0的摄像机路径和长度为2的光源路径连接起来\n长度为1的摄像机路径和长度为1的光源路径连接起来\n长度为2的摄像机路径和长度为0的光源路径连接起来\n\n毫无疑问，这三种采样方式各有其擅长之处。譬如，1其实是light tracing的路径采样方式，擅长计算焦散等现象；3就是native path tracing；2是path tracing的直接照明项。我们能不能把这些采样方式的优点综合起来，而不是粗暴地求和呢？说到这里，一个名词已经呼之欲出了——多重重要性采样。\n使用多重重要性采样的要点，在于给定按某种采样策略A得到的采样结果a时，如何计算a在B、C、D等其他采样策略下对应的概率密度函数值。在这个情景下这个问题其实很好办——沿着路径走一遍，把各种策略下的概率密度都算出来就行了。\n几种特殊路径\ns != 0, t = 0：采用MIS策略，而不是老老实实地连接什么子路径。连接子路径在这里相当于在以前的路径追踪中使用光源采样来计算直接照明。\ns = 0, t != 0：这里连接子路径得到完整路径时，谁也不知道完整路径会对应到图像上的哪个像素去。因此要额外把这部分信息传递出去。这里会对系统的接口设计造成一点影响。\n摄像机子路径击中了光源：完全不需要光源子路径的一种特殊情况。\n光源子路径击中了镜头：要求镜头本身成为场景的一部分，不打算实现这个。\n实现\n综上所述，我把BDPT算法分为以下两个步骤：\n\n从摄像机和光源分别发射子路径，在子路径长度达到一定阈值后引入轮盘赌策略，记录下每个点相对于前一个点的条件概率。\n对摄像机子路径的每个前缀和光源子路径的每个后缀，连接它们得到一条完整的路径，计算其throughput和MIS技术下的概率，加到最终结果上。\n\n（施工中……）"},"articles/2018.11.17.Delta-Geometry-Factor":{"title":"delta函数积分换元","links":[],"tags":["Mathematics"],"content":"一个小坑。\n∫Ω​δ(ω−ω0​)dω=1    (ω0​∈Ω)\n将它转换为表面积形式后：\n∫M​δ(exx′​−exx0​​)∣x−x′∣2cos⟨Nx′​,ex′x​⟩​dAx​=∣x−x0​∣2cos⟨Nx0​​,ex0​x​⟩​\n这样肯定是不行的，所以在做这个立体角-表面积转换的时候要放缩一下δ：\nδ(ω−ω0​)⇒cos⟨Nx0​​,ex0​x​⟩∣x−x0​∣2​δ(exx′​−exx0​​)\n它的一般表述是这样的：\nδμ​(x−x0​)=dμdμ′​δμ′​(x−x0​)"},"articles/2018.11.20.SH-PRT":{"title":"基于球谐函数的预计算辐射传输","links":[],"tags":["Atrc","Graphics"],"content":"实时全特效GI（Global Illumination，全局光照）一直是图形学中可望而不可及的圣杯，前人为此作出了无数努力，尽管诸多想法距离圣杯都还有一定的距离，但依然产生了不少有趣的技术。本文讨论的基于球谐函数（Spherical Harmonics）的预计算辐射传输（Precomputed Radiance Transfer）算法就是其中的一项明珠。\n从渲染方程开始\n考虑渲染方程：\nL(x→Θ)=Le​(x→Θ)+∫S2​fs​(Φ→x→Θ)L(x←Φ)cos⟨Nx​,Φ⟩dωΦ​\nLe​(x→Θ)没啥好讨论的，是直接可以获得的场景数据，这里简单起见就假设它不存在好了；我们再把非直接光照也扔掉，于是原式就变成了：\nL(x→Θ)=∫S2​fs​(Φ→x→Θ)Le​(x←Φ)cos⟨Nx​,Φ⟩dωΦ​\n我们进一步做一个假设：整个场景中只有一个环境光源。所谓环境光源，可以理解为一个包裹整个场景的、和物体距离非常之大（比如无限远）的球形光源。它的一个特征是从辐射亮度只和方向Φ有关，和被照明点的位置x无关，因为不管x是多少，和光源的距离比起来也可以忽略。此时，渲染方程被简化为了：\nL(x→Θ)=∫S2​fs​(Φ→x→Θ)V(x→Φ)LE​(Φ)cos⟨Nx​,Φ⟩dωΦ​\n其中V(x→Φ)表示从x点朝Φ方向发射的射线是否没有被任何东西挡住，LE​(Φ)是环境光源沿−Φ方向的辐射亮度。\n投影与重建\n这里不太严格地介绍一下本文用到的投影与重建的思想。给定一组基函数β={β0​,β1​,…}和被投影的函数f，\nci​=∫f(x)βi​(x)dx\n可以用来衡量f与βi​的相似程度。将一系列的βi​用ci​加权求和，可以得到f的一个近似表示：\nf^​=i=0∑n​ci​βi​\n至于近似水平如何，就要看f性质好不好、βi​表现力如何以及n够不够大了。很多人大一学过的傅里叶级数就是非常好的示例。特别地，如果β满足如下性质：\n∫βi​(x)βj​(x)dx={​0,1,​i=ji=j​​\n就称β是一组单位正交基。单位正交基有一个超～棒的性质，令：\nci​di​​=∫f(x)βi​(x)dx=∫g(x)βi​(x)dx​\n则：\n≈==​∫f(x)g(x)dx∫(i=0∑n​ci​βi​(x))(i=0∑n​di​βi​(x))dxi=0∑n​ci​di​∫βi​(x)βi​(x)dx+i,j∈{0,…,n}i=j​∑​ci​dj​∫βi​(x)βj​(x)dxi=0∑n​ci​di​​\nPRT框架\n看看上面的简化版渲染方程，再看看“单位正交基的美妙性质”所计算的积分，是不是觉得它们之间有一分相似？我们把fs​、V和cos三项打包，把LE​单独打个包，分别看作f和g，就得到了：\nL(x→Θ)=∫S2​f(Φ→x→Θ)g(Φ)dωΦ​\n现令：\ntk​lk​​=∫S2​f(Φ→x→Θ)βk​(Φ)dωΦ​=∫S2​g(Φ)βk​(Φ)dωΦ​​\n于是L(x→Θ)的近似版就出现了：\nL^(x→Θ)=k=0∑n​tk​lk​\n这就是整个PRT的框架了——剩下的工作“只不过”是找到合适的β，以及计算f、g和β乘积的积分。PRT的思想就是尽可能地把更多的计算量挪到一劳永逸的预计算阶段，减小实时渲染阶段的负担。\n球谐函数的定义\n这里要介绍的球谐函数（Spherical Harmonics，SH）就是我们要使用的β。说实话，SH的定义实在是太蛋疼了，我觉得自己没法说清楚它的来龙去脉，这里直接摆上来吧。首先引入伴随Legendre多项式作为辅助函数：\n​for l∈N,m∈N,m≤l,x∈[−1,1]              Plm​(x)=⎩⎨⎧​​x(2m+1)Pmm​(x),(−1)m(2m−1)!!(1−x2)m/2,l−mx(2l−1)Pl−1m​(x)−(l+m−1)Pl−2m​(x)​,​l=m+1l=motherwise​​​\n然后球谐函数长这样子：\n​for l∈N,m∈Z,∣m∣≤l              ylm​(θ,ϕ)=⎩⎨⎧​​2​Klm​cos(mϕ)Plm​(cosθ),2​Klm​sin(−mϕ)Pl−m​(cosθ),Kl0​Pl0​(cosθ)​m&gt;0m&lt;0​​​\n其中，\nKlm​=4π(l+∣m∣)!(2l+1)(l−∣m∣)!​​\n是归一化系数。根据l的不同，可以把SH分成很多层，层数越高所代表的分量的频率也就越高。比如l=0对应1个SH，就只是个常量函数；l=1对应3个SH，有了一些粗粒度的变化；l=2对应5个SH，代表了具有更高频率的分量，等等：\n\n一般我们用“L阶SH”来代指前L层的SH。\n以(θ,ϕ)为参数的球谐函数有时不那么好用，可以把它们换成(x,y,z)坐标。Wiki上有一些三维欧氏空间上的低阶球谐函数的表达式，可以直接拿过来用。最后，l和m两个参数终归不太好使，我们可以利用公式k=l(l+1)+m将它们编码成一个线性下标，以后记作y(k)(θ,ϕ)。\n求解SH系数\n蒙特卡洛暴力即可，设在球面立体角上进行采样所使用的概率密度函数是pS2​，总采样数是N，估计量走起：\nt^k​l^k​​=N1​i=1∑N​pS2​(Φi​)fs​(Φi​→x→Θ)V(x→Φi​)cos⟨Nx​,Φi​⟩y(k)(θΦi​​,ϕΦi​​)​=N1​i=1∑N​pS2​(Φi​)LE​(Φi​)y(k)(θΦi​​,ϕΦi​​)​​\n当然，pS2​的选取还是可以讲究一番的，总之是按重要性采样的原则来，这里不多赘述。\n旋转SH系数\nSH函数还有个美妙的性质，就是我们可以通过旋转其系数来实现对原函数的旋转。这有什么用呢？可以用来高效地旋转我们的环境光。设想要是没有这个性质，那么环境光一转，就得用蒙特卡洛方法重新算l^k​；而有了这个性质，我们直接把一个线性变换作用到原来的l^k​上即可，岂不美哉。\n这个系数的旋转方法用起来简单，推导起来就没那么简单了。许多paper长篇累牍地讲述如何推导SH系数的旋转矩阵，以及如何减少这一过程需要的计算量。我在这里找到一个非常⑨的做法，下面讨论的算法即来源于此。\n首先我们需要一些SH的性质，它们的证明不在本文的讨论范围之内：\n\nSH系数旋转可以通过一个线性变换完成。\n每一阶的SH系数旋转可以分别完成。\n\n现在以l=2的SH系数旋转为例进行说明。假设投影函数P将笛卡尔坐标表示的三维方向向量投影为2阶SH函数的5个系数，我们希望进行的旋转是个线性变换，用3阶方阵M表示，R是用来旋转SH系数的5阶方阵，则对任意方向向量N，有：\nRP(N)=P(MN)\n现在随便选5个方向向量N0​,…,N4​，于是：\nR[P(N0​),…,P(N4​)]=[P(MN0​),…,P(MN4​)]\n记A=[P(N0​),…,P(N4​)]，若A可逆，则R可以被表示为：\nR=[P(MN0​),…,P(MN4​)]A−1\n于是我们得到了计算旋转矩阵R的方法——只需要适当地选取N0​,…,N4​以保证A可逆即可。不过，在实际使用的时候我们往往并不关心R本身是多少，而是希望计算出某个球谐系数向量x对应的Rx。这个就非常好说了：\nRx=[P(MN0​),…,P(MN4​)]A−1x\n至此问题已经解决了。给定旋转矩阵M和SH系数x，旋转后的SH系数可按如下步骤计算：\n\n预先选好N0​,…,N4​，计算出A−1。这一步可以直接硬编码结果。\n用M旋转N0​,…,N4​，得到N0′​,…,N4′​。\n用P计算出N0′​,…,N4′​对应的SH系数，以它们为列构造一个5x5矩阵S。\n计算S(A−1x)并作为结果输出。\n\n用这样的思路，可以推得任意阶SH系数的旋转方法。下面简单地罗列了一组前3阶的N和A：\nl = 0\n此时的SH是常量函数，旋转不会影响其系数值。\nl = 1\n结合Wiki上的SH函数公式，P可以表示为：\nP([x,y,z]T)=21​π3​​​y/rz/rx/r​​  where r=x2+y2+z2​\n现取N0​=[1,0,0]T,N1​=[0,1,0]T,N2​=[0,0,1]T，则：\nA−1=[P(N0​),P(N1​),P(N2​)]−1=​21​π3​​​001​100​010​​​−1=23π​​​010​001​100​​\nl = 2\n首先根据SH给出P。设r=x2+y2+z2​，则：\nP([x,y,z]T)=[4π15​​r2xy​,4π15​​r2yz​,16π5​​r2−x2−y2+2z2​,4π15​​r2zx​,16π15​​r2x2−y2​]T\n设k=1/2​，取：\nN0​=[1,0,0]T  N1​=[0,0,1]T  N2​=[k,k,0]T  N3​=[k,0,k]T  N4​=[0,k,k]T\n通过数值计算可以求得A−1为：\nA−1=​0k0​k1​00​k0​000k1​​0k2​000​−k0​−k0​0k1​0​k1​k0​000​​  where ⎩⎨⎧​k0​=0.91529123286551084k1​=1.83058246573102168k2​=1.5853309190550713​\n实现\n我简单地实现了1~5阶SH的投影、系数旋转和重建过程，代码放在这里。随便画个模型看看：\n\n环境光一开始在人像的右侧，上图中从左至右是将环境光绕垂直方向旋转了0度、90度、180度、270度后的结果，用了3阶SH，效果意外地很不错。\n拓展\n以下是一些更加高级的内容，我将它们实现在了代码中，但在这里不过多介绍。\n在之前讨论PRT的时候，我们一开始就舍弃了间接光照，这多多少少会让物体表面看起来暗淡了一些，在材质的反照率较高时尤为明显。如果我们不把间接光照舍弃呢？\n考虑将物体上某一点具有的亮度值L(x→Θ)视为该点对环境光的一种响应，那么对每个立体角微元dωΦ​而言，dL(x→Θ)/dLE​(Φ)都应该是一个和L无关、仅和Φ有关的量Ix→Θ​(Φ)。基于此，场景中只存在环境光源时的LTE可以被写作：\nL(x→Θ)=∫S2​Ix→Θ​(Φ)LE​(Φ)dωΦ​\nIx→Θ​(Φ)衡量了L(x→Θ)对来自Φ方向的环境光的敏感程度。我们可以把Ix→Θ​和LE​分别投影到SH上，从而得到包含了间接光照的结果。将Ix→Θ​投影到SH空间的过程和path tracing非常相似，我就直接放结果了：\n\n上图中最右侧的图像是用path tracing渲染的参考结果，上面的一排分别是用1~5阶SH投影和重建直接光照得到的结果，下面的一排则是考虑了间接照明的结果，可以“右键→在新窗口中查看图片”来查看大图。在阶数达到4、5阶时，下面的图像和参考图像间的差别已经很难用肉眼分辨了。"},"articles/2018.12.02.Camera-Models":{"title":"摄像机模型小结","links":[],"tags":["Atrc","Graphics"],"content":"Note. 我最近在重构Atrc，没有再采用本文对摄像机的建模方法，原因参见此文。\n原文\n最近在试着实现light tracing算法，需要手推各种摄像机模型的measurement function，打算把结果总结在这里。这篇文章内容是比较trivial的，只是需要把它们完全理清楚才好实现。\n本文一律使用右手坐标系，且视z轴正方向为垂直向上的方向。此外，本文的讨论并不立足于实时渲染，因此不会涉及到透视投影变换、齐次坐标系等话题。\n所有内容的实现均可在我的GitHub上找到。\nPinhole Camera\n顾名思义，小孔摄像机模型中，光只能通过一个理论上大小可以忽略的孔洞进入摄像机内部，并命中成像平面上的感光元器件。我们假设这个布满感光元器件的接收设备是一个矩形，且在世界坐标系中宽度为wS​，高度为hS​，并以它的几何中心为原点，在该平面上建立一个简单的二维坐标系，用来表示元器件平面上的位置。这一坐标系被称为感光元器件坐标系，记作CS​，其有效的坐标取值范围是（注意像素下标虽然是整数，但像素坐标系中的点未必是）：\n(x,y)∈[−2wS​​,2wS​​]×[−2hS​​,2hS​​]\n元器件所接收到的信号最后要转换为一副二维图像上的颜色。设图像宽高分别为wI​像素和hI​像素，以左上角为原点，则有效的像素坐标范围为[0,wI​]×[0,hI​]。我们把这个坐标系称为像素坐标系，记作CI​。CI​和CS​间的关系是非常明显的：\nCI​⇒CS​:       CS​⇒CI​:       ​{xS​=wS​(xI​/wI​)−wS​/2yS​=hS​/2−hS​(yI​/wI​)​{xI​=(xS​/wS​+0.5)∗wI​yI​=(0.5−yS​/hS​)∗hI​​​\n除了CI​和CS​间的转换，我们还需要把CS​中的坐标转换为世界坐标系中的射线的能力。为了简化问题，我们先考虑一个本地坐标系CL​中的情况：摄像机的小孔位于原点，正面朝向ex​方向，小孔和元器件平面的距离为L，则给定CS​中的坐标(xS​,yS​)，CL​中的射线原点和方向可以表示为：\norigindirection​=[0,0,0]T=[L,xS​,−yS​]T​\n最后，我们引入图形学中非常常见的本地坐标系CL​与世界坐标系CW​间的变换。假设摄像机可以先被旋转，再被平移。令d表示摄像机旋转后的正面朝向，u为CL​中的xOz平面上任意一个不平行于ex​的单位向量被变换到CW​中的结果，则CL​中的ex​,ey​,ez​在CW​中分别对应：\nex​ey​ez​​⇒d⇒u×d⇒d×(u×d)​\n由于旋转是个线性变换，所以可以用一个矩阵RL→W​来表示，且RL→W​可以被构造为：\nRL→W​=[d​u×d​d×(u×d)​]\n再加上一个平移偏移量T，我们就得到了CL​和CW​间的转换方法：\nCL​→CW​:       CW​→CL​:       ​{vW​=RvL​p​W​=Rp​L​+T​{vL​=RTvW​p​L​=RT(p​W​−T)​​\n其中v表示方向，p​表示位置；RT表示的其实是R−1，因为旋转矩阵是单位正交矩阵，所以可以通过转置来快速求它的逆。CL​和CW​间的转换方法适用于后文中所有的摄像机模型。\nMeasurement Function\n在讨论基于光线追踪的真实感渲染技术时，我们总是说：只要对任意点p​和方向ω能够求解出L(x←ω)，就算是大功告成了。但是仔细一想：图像上的每个像素实际上都对应了场景中的一小块区域，L(x←ω)和该像素的颜色间是怎么建立起联系的呢？\n设像素j在场景中对应的元器件区域为Mj​，对每个x∈Mj​和方向ω∈S2，x处的元器件对来自ω的光都会产生一定的响应，并影响到最终我们观察到的j的颜色。设该响应的强度可以用函数We(j)​(x→ω)表示，那么像素j的颜色为：\nIj​=∫Mj​​∫S2​We(j)​(x→ω)L(x←ω)cos⟨Nx​,ω⟩dωdAx​\n以小孔摄像机为例，如果我们简单地认为像素j的颜色为在Mj​意义上通过小孔击中Mj​的所有radiance的平均值，那么We(j)​为：\nWe(j)​(x→ω)=cos⟨Nx​,ω⟩area(Mj​)δ(ω−Nor(RL→W​[L,xSj​​,−ySj​​]T))​\n其中Nor表示将向量归一化。这个式子的意思是对Mj​上的每个点x，只有从小孔所在的方向来的光可以对j的颜色作出贡献。\n把这一节和上一节的内容结合起来，就可以实现小孔摄像机模型了。随便画个图看看：\n\n其实它和图形学中常用的透视投影摄像机是等价的。此外，小孔摄像机拍摄的图像上下左右都颠倒了，为了方便展示，我把它翻转了回来。下文中展示的图像也做了类似的必要处理。\nThin Lens Camera\n理想的小孔摄像机在现实中是不存在的，因为光没法通过一个没有大小的孔洞来照亮整个传感元器件平面。本节讨论一种简化的凸透镜摄像机模型，它假设透镜的厚度可以被忽略。\n考虑将一个薄凸透镜放置在数轴的原点处，一束平行光沿着−ex​方向击中透镜，它们将汇聚于−x轴上的一点，该点和原点间的距离称为薄凸透镜的焦距，记作f。对位于距原点z（z&gt;f）的物体，它所发出的光穿过凸透镜后也会汇聚于一点，设该汇聚点距原点为z′（z′&lt;f），则z、z′、f满足以下关系：\nz′1​−z1​=f1​\n也就是说，给定元器件平面和透镜的距离z′，我们可以通过上式计算出z来。在三维空间中，这样一个和透镜中心距离为z的平面被称为焦平面，位于焦平面上的物体上的每个点所发出的光都将汇聚到元器件平面上的一点，而不在焦平面上的点所发出的光在穿过透镜后则会汇聚到元器件平面上的一个圆内，若该圆的大小超过了一个像素，那么我们将观察到模糊的物体，也就是所谓的景深效果。\n简单起见，给定元器件平面上的点x，我们认为薄凸透镜上的每一点y​都会对x所响应的亮度作出同等的贡献，而每个x∈Mj​也都对像素j的颜色作出同等的贡献。此外，我们也希望We(j)​能够满足归一化约束：\n∫Mj​​∫S2​We(j)​(x→ω)cos⟨Nx​,ω⟩dωdAx​=1\n为此，我们首先把S2改写到MA​上，其中MA​是薄凸透镜在场景中对应的区域：\n∫Mj​​∫MA​​We(j)​(x→exy​)cos⟨Nx​,exy​⟩∣x−y​∣22​cos⟨Ny​,eyx​⟩​dAy​dAx​=1\n由于每个y​都对j的颜色作出同等的贡献，因而：\nWe(j)​(x→exy​)cos⟨Nx​,exy​⟩∣x−y​∣22​cos⟨Ny​,eyx​⟩​=C\nC表示某个和y​无关的数。代入归一化条件后我们可以得到：\n⇒ ​∫Mj​​∫MA​​CdAy​dAx​=1C=area(Mj​)area(MA​)1​​\n这就成功解出了We(j)​：\nWe(j)​(x→exy​)=cos⟨Nx​,exy​⟩cos⟨Ny​,eyx​⟩area(Mj​)area(MA​)∣x−y​∣22​​\n容易验证以下三个关系的正确性：\ncos⟨Ny​,eyx​⟩∣x−y​∣22​MA​​=cos⟨Nx​,exy​⟩=cos2⟨Nx​,exy​⟩L2​=πr2​\n其中L是元器件平面和凸透镜间的距离，r是凸透镜半径。把这三个式子代入上面的We(j)​表达式中，再把Nx​换成与之相等的摄像机朝向d，就得到了：\nWe(j)​(x→ω)=πr2cos4⟨d,ω⟩area(Mj​)L2​\n凸透镜半径取得越大，不在焦平面上的物体显得越模糊。下图的元器件平面宽度为2m，距离透镜1m，透镜半径为20cm（这参数已经超出我对摄像机的认知了，不过请不要在意这些细节），可以看到景深效果非常夸张：\n\nEnvironment Camera\n环境摄像机不是现实中能有的摄像机——它捕获四面八方的光线，将上下左右前后所有的景物都记录到一幅图像上。对任意一个入射方向ω，设θω​∈[0,2π)是它沿垂直轴的旋转角度，ϕω​∈[−π/2,π/2]是与水平面的夹角。令：\nuω​vω​​=1−2πθω​​=0.5−πϕω​​​\n并将(uω​,vω​)作为纹理坐标（原点在图像左上角），就能获得一幅描述了环境光照的图像。\n环境摄像机的感光元器件就比较邪门儿了，它是一个球。我们暂且把这个球放置在原点，用r表示其半径，则(uω​,vω​)对应球面上的点为：\n⎩⎨⎧​xω​=rcosϕω​cosθω​yω​=rcosϕω​sinθω​zω​=rsinϕω​​\n这个点上的感光器件只对一个方向来的光有响应，那就是来自[x,y,z]T的光。于是，给定像素坐标系CI​中的点(xI​,yI​)，其对应的射线是：\n​origin(xI​,yI​)=​rcos(2π​−hI​πyI​​)cos(−wI​2πxI​​)rcos(2π​−hI​πyI​​)sin(−wI​2πxI​​)rsin(2π​−hI​πyI​​)​​=​rsinhI​πyI​​cos(−wI​2πxI​​)rsinhI​πyI​​sin(−wI​2πxI​​)rcoshI​πyI​​​​direction(xI​,yI​)=Norigin​=∣origin∣2​origin​=​sinhI​πyI​​cos(−wI​2πxI​​)sinhI​πyI​​sin(−wI​2πxI​​)coshI​πyI​​​​​\n设像素j在CI​中的范围为[xj1​​,xj2​​]×[yj1​​,yj2​​]，则它所对应的元器件区域Mj​为：\nMj​={origin(x,y)∣(x,y)∈[xj1​​,xj2​​]×[yj1​​,yj2​​]}\n我们假设Mj​上的每个点对j的颜色有相同的贡献量，于是：\nWe(j)​(x→ω)=Ccos⟨Nx​,ω⟩δ(Nx​−ω)​∫Mj​​∫S2​We(j)​(x→ω)cos⟨Nx​,ω⟩dωdAx​=1​\n解得：\nWe(j)​(x→ω)=area(Mj​)δ(Nx​−ω)​\n随便画个图看看：\n\nMeasurement Equation on Film\n对环境摄像机的探究就算是大功告成了吗？其实不然。在之前讨论的两个摄像机模型中，如果我们在像素j中均匀采样像素平面上的点，那么这也等价于在Mj​上均匀采样，进而可以通过均匀采样和求均值来估计Ij​。而在环境摄像机模型中，像素j上的均匀分布并不等价于Mj​上的均匀分布，因而在CI​中，像素j范围内的各点对Ij​的贡献是不等的。我们把measurement equation中的Mj​换到CI​上试试：\nIj​=∫x0​x1​​∫y0​y1​​∫S2​Qe(j)​((x,y)→ω)L(W(x,y)←ω)dωdxdy\n其中，(x0​,y0​)是CI​中某个像素j的左上角，(x1​,y1​)则是j的右下角；W是将CI​中的点转换为Mj​上的点的函数，Qe(j)​则是衡量L(W(x,y)←ω)对Ij​的重要程度的函数，从计算的角度看比We(j)​更为直接。\n根据CI​的定义，x1​−x0​=y1​−y0​=1，因此如果我们在j内均匀采样，那么概率密度函数将是值为1的常函数，这就给出了用蒙特卡路方法估算Ij​的公式：\nI^j​​=N1​i=1∑N​p(xi​,yi​)p(ωi​∣(xi​,yi​))Qe(j)​((xi​,yi​)→ωi​)L(W(xi​,yi​)←ωi​)​=N1​i=1∑N​p(ωi​∣(xi​,yi​))Qe(j)​((xi​,yi​)→ωi​)L(W(xi​,yi​)←ωi​)​​\n其中N是采样数，(xi​,yi​)和ωi​分别是第i次采样得到的CI​中的点和入射方向，p(ωi​∣(xi​,yi​))是在选中了(xi​,yi​)后选中ωi​的条件概率密度。\n接下来我们来尝试导出We​和Qe​之间的关系。设Mj​可以被写作参数曲面Mj​(α,β)，(α,β)和CI​中像素j上的点间构成双射，且具有一大坨我在这里不想写的良好数学性质，那么我们可以把对Qe​的积分换到Mj​的参数空间Ω上：\nIj​​=∫x0​x1​​∫y0​y1​​∫S2​Qe(j)​((x,y)→ω)L(W(x,y)←ω)dωdxdy=∫Ω​∫S2​Qe(j)​((x(α,β),y(α,β))→ω)L(Mj​(α,β)←ω)​∂(α,β)∂(x,y)​​dωdαdβ​\n而We​所满足的方程在形式上和上式非常相似：\nIj​=∫Ω​∫S2​We(j)​(x→ω)L(x←ω)cos⟨Nx​,ω⟩​dαdβdAMj​​​​dωdαdβ\n于是Qe​和We​满足：\nQe(j)​((x,y)→ω)​∂(α,β)∂(x,y)​​=We(j)​(x→ω)cos⟨Nx​,ω⟩​dαdβdAMj​​​​\n其中x是(x,y)在Mj​上的对应点。我们把小孔摄像机的We​代入上式，就能得到它的Qe​：\nQe(j)​((x,y)→ω)​=area(Mj​)cos⟨Nx​,ω⟩area(Mj​)δ(ω−Nor(RL→W​[L,xSj​​,−ySj​​]T))​cos⟨Nx​,ω⟩=δ(ω−Nor(RL→W​[L,xSj​​,−ySj​​]T))​\n对薄凸透镜模型也有类似的结论：\nQe(j)​((x,y)→ω)​=area(Mj​)πr2cos4⟨d,ω⟩area(Mj​)L2​cos⟨Nx​,ω⟩=πr2cos3⟨d,ω⟩L2​​\n对环境摄像机，注意到：\nxy​=−2π1​wI​θ=−2hI​​+πhI​ϕ​​\n于是：\n​∂(θ,ϕ)∂(x,y)​​=​Det([−wI​/(2π)0​0hI​/π​])​=2π2wI​hI​​\n若取摄像机球体半径为1（这与最后的结论无关），那么：\n= ​∫θ1​θ2​​∫ϕ1​ϕ2​​∫S2​Qe(j)​((x,y)→ω)L(x←ω)​∂(θ,ϕ)∂(x,y)​​dωdϕdθ∫θ1​θ2​​∫ϕ1​ϕ2​​∫S2​We(j)​(x→ω)L(x←ω)cos⟨Nx​,ω⟩cosϕdωdϕdθ​\n其中θ1​,θ2​,ϕ1​,ϕ2​是Mj​对应的θ和ϕ的范围边界。从上式可以解得：\nQe(j)​((x,y)→ω)=wI​hI​∣(θ2​−θ1​)(sinϕ2​−sinϕ1​)∣2π2δ(Nx​−ω)cosϕ​"},"articles/2019.02.20.Disney-BRDF":{"title":"Disney Principled BRDF实现笔记","links":["{{site.url}}/2018/10/22/reflection-models"],"tags":["Atrc","Graphics"],"content":"Physically Based Rendering（PBR）是个很美好的概念，意为在物理意义上有据可依的渲染技术。PBR在物体材质上的应用主要立足于各种反射/折射模型上，然而，诸如微表面法线分布函数、导体的复数折射率等花里胡哨的公式和概念对使用者极不友好。Disney Principled BRDF（以后简称Disney BRDF）为PBR材质提供一组直观的参数和编辑方式，在“直观”、“多样”和“基于物理”三者间取得了很好的均衡。我寒假在家无事，决定实现一下看看效果。\n本文记叙了我在实现Disney BRDF过程中的推导和所使用的公式，而不是解释一些PBR相关的基础知识。大部分内容以Disney BRDF Shader和Disney Principled BRDF文档为参考。\n初入图形学，如有错误，欢迎指正。\n参数概览\n\n如上图所示，Disney BRDF有11项用于调节材质外观的参数，它们分别是：\n\nbaseColor，材质的基本颜色，通常设定为常数或由纹理提供。\nsubsurface，用于控制材质的漫反射成分向次表面散射靠拢的程度。\nmetallic，金属度，指材质的外观向金属靠拢的程度。\nspecular，高光度，控制材质中非金属部分的高光明亮程度。\nspecularTint，高光颜色向基本颜色靠拢的程度。\nroughness，材质粗糙程度。\nanisotropic，各向异性度，即材质反射的非对称程度。\nsheen，模拟一些纺织物边缘的明亮效果。\nsheenTint，sheen分量的颜色向基本颜色靠拢的程度。\nclearcoat，一个额外的高光项，用于模拟清漆的效果。\nclearcoatGloss，清漆的光滑程度。\n\n以上所有参数的有效取值范围均为[0, 1]，该范围内的任何取值组合都被认为是合法的（valid）材质。下面依次解析Disney BRDF的各分量模型以及上述参数在其中起到的作用。\n漫反射\n漫反射是光进入材质表面以下发生浅层散射后再从离入射点非常近的位置射出的结果，在物理意义上和次表面散射是相同的（只是尺度不同）。正因如此，许多材质模型会用fresnel公式计算折射光比例作为漫反射分量的乘积因子。\nDisney BRDF使用了魔改的Schlick公式——他们丢弃了折射率的概念，转而让fresnel项和物体表面的粗糙度挂钩。我没看出这有什么道理，不过原文称“这能很好地拟合实际数据，对artists也很友好”，那就暂且接受吧。公式如下：\n​fdiffuse​=πbaseColor​(1+(FD90​−1)(1−cosθi​)5)(1+(FD90​−1)(1−cosθo​)5)FD90​=0.5+2cos2θd​roughness​\n其中θd​是入射方向wi​与half vector ωh​=normalize(wi​+wo​)的夹角。\n既然漫反射和次表面散射具有类似的原理，那么就可以用一个参数来在二者之间过渡，也就是Disney BRDF中的subsurface参数。Disney BRDF会计算出一个漫反射值和一个次表面散射值，然后用subsurface在二者间进行插值。\n对于次表面散射的计算，Disney BRDF并未使用人们所熟知的Jensen BSSRDF等复杂模型（否则计算效率也太低了），而是用一个BRDF来近似计算。他们的次表面散射公式是从Hanrahan-Krueger BRDF改进而来的：\n​fsubsurface​=1.25πbaseColor​(Fss​(1/(cosθi​+cosθo​)−0.5)+0.5)Fss​=(1+(Fss90​−1)(1−cosθi​)5)(1+(Fss90​−1)(1−cosθo​)5)Fss90​=cos2θd​roughness​\n高光\n如今几乎所有的PBR材质模型中的高光都是用Torrance-Sparrow微表面模型来模拟的，其形式如下：\nf=Fr​(θd​)4cosθi​cosθo​D(θh​)G(θi​,θo​)​\n其中Fr​(θd​)是fresnel项；D(θh​,ϕh​)是微表面法线分布函数值，θh​为wh​与法线的夹角，ϕh​为wh​的水平极角；G(θi​,θo​)为法线为wh​的微表面中没有被其他微表面遮蔽的比例。D和G在不同的材质模型中有不同的选择，下方的4cosθi​cosθo​则是Torrance-Sparrow模型固有的一部分。Torrance-Sparrow模型的来历可简单参见这里（该公式框架最早来自此文，Cook-Torrance改变了其中的归一化常数，给出的式子在图形学中更加常用）。\n微表面法线分布\nDisney BRDF中的高光项也使用了该模型，其微表面法线分布函数具有如下形式：\nD(θh​,ϕh​)=(sin2θh​(αx2​cos2ϕ​+αy2​sin2ϕ​)+cos2θh​)γc​\n其中c是归一化常数；αx​和αy​是衡量表面粗糙度的参数，它们相等时材料为各向同性，不等时则为各向异性；γ是一个用来调整函数曲线的参数，为2时就恰好等价于近来流行的GGX（Trowbridge-Reitz）函数。由于这一函数在Trowbridge-Reitz的基础上添加了γ参数，因此被称为Generalized-Trowbridge-Reitz函数，简称GTR。Disney BRDF中有两处使用了GTR函数，一处是这里的高光项，另一处是清漆的反射。在高光项中，γ值恰好被设定为2。αx​、αy​与Disney BRDF参数间的关系为：\nαx​αy​a​=roughness2/a=roughness2∗a=1−0.9anisotropic​​\n考虑到D应满足归一化约束：\n∫H2​cosθh​D(θh​,ϕh​)dωh​=1\n取γ=2，稍微积个分：\n==​∫H2​(sin2θh​(αx2​cos2ϕ​+αy2​sin2ϕ​)+cos2θ)2ccosθh​​dωh​c∫02π​∫0π/2​(sin2θh​(αx2​cos2ϕ​+αy2​sin2ϕ​)+cos2θ)2sinθh​cosθh​​dθh​dϕh​2c​∫02π​αx2​cos2ϕh​​+αy2​sin2ϕh​​1​dϕh​=παx​αy​c=1​\n解得c=1/(παx​αy​)，即：\nD(θh​,ϕh​)=παx​αy​(sin2θh​(αx2​cos2ϕ​+αy2​sin2ϕ​)+cos2θh​)21​\n这公式写着太费劲了，不妨设：\nΦ(ϕh​)=αx2​cos2ϕh​​+αy2​sin2ϕh​​\n于是：\nD(θh​,ϕh​)=παx​αy​(sin2θh​Φ(ϕh​)+cos2θh​)21​\n如果要在离线渲染中使用这一分布函数，我们还需要对BRDF进行重要性采样。具体到这里，我们选择按D(θh​,ϕh​)cosθh​设计采样所用的概率密度函数。令ph​(θh​,ϕh​)dθh​dϕh​=D(θh​,ϕh​)cosθh​dωh​，那么：\n⇒ ​ph​(θh​,ϕh​)dθh​dϕh​=D(θh​,ϕh​)cosθh​dωh​=D(θh​,ϕh​)sinθh​cosθh​dθh​dϕh​ph​(θh​,ϕh​)=D(θh​,ϕh​)sinθh​cosθh​​\n两边在[0,π/2]上对θh​积分，得：\n∫0π/2​ph​(θh​,ϕh​)dθh​=∫0π/2​D(θh​,ϕh​)sinθh​cosθh​dθh​ ⇒ ph​(ϕh​)=2παx​αy​Φ(ϕh​)1​\n自然而然地：\nph​(θh​∣ϕh​)=ph​(ϕh​)ph​(θh​,ϕh​)​=2παx​αy​Φ(ϕ)D(θh​,ϕh​)sinθh​cosθh​\n有了概率密度函数ph​(ϕh​)和ph​(θh​∣ϕh​)，对其积分就能得到分布函数Ph​(ϕh​)和Ph​(θh​∣ϕh​)。首先是Ph​(ϕh​)：\nPh​(ϕh​)=∫0ϕh​​ph​(x)dx=2παx​αy​1​∫0ϕh​​Φ(x)1​dx=2π1​arctan(αy​αx​​tanϕ)\n设ξ1​是[0,1)上的服从均匀分布的随机变量，令Ph​(ϕh​)=ξ1​，解得：\nϕh​=arctan(αx​αy​​tan(2πξ1​))\n这个式子有些问题：里面的tan对ξ1​=0.25或ξ1​=0.75是无意义的，外面的arctan的取值范围又是(−π/2,π/2)而不是我们想要的[0,π/2)，如下图所示：\n\n可以看到这一函数被分为三段，我们把中间的一段向上平移π，最后一段向上平移2π，并专门处理0.25和0.75附近的值以保持函数曲线平滑、避免出现数值问题即可。事实上，我们并不直接需要ϕh​的值，只要求出sinϕh​和cosϕh​即可，这样就能绕开tan和arctan的糟糕性质——\nsinϕh​cosϕh​​=rαy​​sin(2πξ1​)=rαx​​cos(2πξ1​)​\n其中r是保证sin2ϕh​+cos2ϕh​=1的归一化系数。\n最后是求ph​(θh​∣ϕh​)对应的条件分布：\nPh​(θh​∣ϕh​)​=∫0θh​​2παx​αy​Φ(_h)​D(x,ϕh​)sinxcosxdx=∫0θh​​(sin2xΦ(ϕh​)+cos2x)22Φ(ϕh​)sinxcosx​dx=(1−Φ(ϕh​))cos(2θh​)+(1+Φ(ϕh​))Φ(ϕh​)(1−cos(2θh​))​​\n令Ph​(θh​∣ϕh​)=ξ2​，解得：\n⇒ ​(1−Φ(ϕh​))cos(2θh​)+(1+Φ(ϕh​))Φ(ϕh​)(1−cos(2θh​))​=ξ2​θh​=arccos((1−Φ(ϕh​))ξ2​+Φ(ϕh​)Φ(ϕh​)(1−ξ2​)​​)​\n最后推导一下按这种方式采样ωh​，然后依据它计算出入射方向ωi​的概率密度。注意到：\np(ωh​)dωh​=p(θh​,ϕh​)dθh​dϕh​⇒p(ωh​)=D(θh​,ϕh​)cosθh​\n又根据dωi​=4cosθd​dωh​，有：\np(ωi​)=p(ωh​)dωi​dωh​​=4cosθh​p(ωh​)​=4cosθd​D(θh​,ϕh​)cosθh​​\n我在对高光进行采样的时候没有考虑fresnel项和遮蔽项，主要原因是考虑了之后我就推不出来了，emmmm……\n遮蔽项\n接下来是Torrance-Sparrow公式中的G，Disney BRDF选择了Smith遮蔽函数：\nG(ωi​,ωo​)=G1​(ωi​)G1​(ωo​)\n至于G1​，就直接用各向异性GGX分布对应的遮蔽函数好了：\n​G1​(ω)=1+Λ(ω)1​Λ(ω)=−21​+21​1+(αx2​cos2ϕ+αy2​sin2ϕ)tan2θ​​\n其中的αx​和αy​还是按之前的方法通过roughness和anisotropic计算出来的。值得一提的是，最初的Disney BRDF在计算高光的遮蔽项时将roughness做了如下变换：\nroughnessg​=21+roughness​\n并称这样能够更好地拟合MERL数据库中的材质数据。后来随着理论分析的进步，他们认为MERL中对光滑材料的数据测量并不准确，去掉了这一trick。\n边缘处的光泽\n当我们从几乎垂直于法线的方向去观察诸如丝绸或一些布料时，它们会显得比普通的漫反射更明亮一些。Disney BRDF直接用一个缩放后的Schlick公式去模拟这一现象，即(1−cosθd​)5sheen。\n清漆\n诸如车漆、木质地板等材料可以通过一个两层模型来渲染：上面是一层透明材料，通常比较光滑，下面则是漫反射或金属等其他材料。如果要仔细地渲染这一模型，我们需要考虑两层间的多次反射和折射，并用fresnel公式来分配每次反射/折射的比例。Disney BRDF采用的方案要简单粗暴得多——加上一个额外的高光，称为清漆（clearcoat）项。\n清漆项同样采用Torrance-Sparrow模型，其遮蔽项是取粗糙度为定值0.25的GGX遮蔽项，fresnel项固定取折射率为1.5的绝缘体，微表面法线分布函数则是取γ=1的各向同性GTR函数（记作GTR1），其中1 - clearcoatGloss被映射到[0.01,0.1]范围内作为粗糙度。下面稍微推一下GTR1的归一化系数和采样方法。\nGTR1函数\nGTR1具有如下形式：\nD(θh​)=α2cos2θh​+sin2θh​c​\n其中c是归一化系数。利用归一化约束：\n∫H2​D(θh​)cosθh​dωh​=c∫02π​∫0π/2​α2cos2θh​+sin2θh​sinθh​cosθh​​dθh​dϕh​=α2−12πc​lnα=1\n解得c=(α2−1)/(2πlnα)，于是：\nD(θh​)=2πlnα(α2cos2θh​+sin2θh​)α2−1​\n接下来是重要性采样。由于GTR1对ϕh​而言是各向同性的，我们可以直接取ϕh​=2πξ1​，并且θh​和ϕh​相互独立，于是可以求出ph​(θh​)：\nph​(θh​)=ph​(ϕh​)ph​(θh​,ϕh​)​=2πD(θh​)cosθh​sinθh​=(α2cos2θh​+sin2θh​)lnα(α2−1)cosθh​sinθh​​\n积分之：\n=​Ph​(θh​)=∫0θh​​ph​(t)dt=∫0θh​​(α2cos2t+sin2t)lnα(α2−1)costsint​dt2lnα1​ln[(α2−1)cos(2θh​)+(α2+1)2α2​]​\n令Ph​(θh​)=ξ2​，解得：\nθh​=arccos​α2−1α2−2ξ2​−1​​​\nBRDF\n上面说了这么多“项”，我们还需要将它们融合起来变成一个BRDF。能量守恒这种高端要求是不指望了（像Smith G这种函数本身就会带来能量损失），但至少看起来不能太离谱。设：\nCσm​σss​σs​σst​σr​σa​σsh​σsht​σc​σcg​​=baseColor=metallic=subsurface=specular=specularTint=roughness=anisotropic=sheen=sheenTint=clearcoat=clearcoatGloss​\n并设入射方向ωi​为(θi​,ϕi​)，出射方向ωo​为(θo​,ϕo​)，half vector ωh​为(θh​,ϕh​)，ωi​与ωh​的夹角为θd​，则Disney BRDF为：\nfdisney​(ωi​,ωo​)= + + ​(1−σm​)(πC​mix(fd​(ωi​,ωo​),fss​(ωi​,ωo​),σss​)+fsh​(ωi​,ωo​))4cosθi​cosθo​Fs​(θd​)Gs​(ωi​,ωo​)Ds​(ωh​)​4σc​​4cosθi​cosθo​Fc​(θd​)Gc​(ωi​,ωo​)Dc​(ωi​,ωo​)​​\n其中fd​为漫反射：\nfd​(ωi​,ωo​)FD90​​=(1+(FD90​−1)(1−cosθi​)5)(1+(FD90​−1)(1−cosθo​)5)=0.5+2cos2θd​σr​​\nfss​为次表面散射项：\nfss​(ωi​,ωo​)Fss​Fss90​​=1.25(Fss​(1/(cosθi​+cosθo​)−0.5)+0.5)=(1+(Fss90​−1)(1−cosθi​)5)(1+(Fss90​−1)(1−cosθo​)5)=cos2θd​σr​​\nfsh​为sheen项：\nfsh​(ωi​,ωo​)Ctint​​=mix(one,Ctint​,σsht​)σsh​(1−cosθd​)5=lum(C)C​​\nlum是求相对亮度的函数，对线性颜色空间中的RGB值C，有：\nlum(C)≈0.2126×C.r+0.7152×C.g+0.0722×C.b\nFs​是高光的frensel项，用Schlick公式做了近似。对绝缘体而言，Schlick公式中的R0​可以用一个实数表示；而对金属而言，R0​是带有颜色信息的，因此Disney BRDF利用金属度参数在两种情况间进行了插值：\nFs​(θd​)Cs​​=Cs​+(1−Cs​)(1−cosθd​)5=mix(0.08σs​mix(one,Ctint​,σst​),C,σm​)​\nGs​是高光的遮蔽项，采用各向异性GGX对应的Smith函数：\nGs​(ωi​,ωo​)Gs1​(ω)Λs​(ω)​=Gs1​(ωi​)Gs1​(ωo​)=1+Λs​(ω)1​=−21​+21​1+(αx2​cos2ϕ+αy2​sin2ϕ)tan2θ​​\nDs​是高光的微表面法线分布函数，采用各向异性GTR2函数（其实就是GGX）：\nDs​(ωh​)αx​αy​a​=παx​αy​(sin2θh​(αx2​cos2ϕ​+αy2​sin2ϕ​)+cos2θh​)21​=σr2​/a=σr2​a=1−0.9σa​​​\nFc​是清漆的fresnel项，采用折射率固定为1.5的绝缘体对应的Schlick公式：\nFc​(θd​)=0.04+0.96(1−cosθd​)5\nGc​是清漆的遮蔽项，采用粗糙度为0.25的各向同性GGX对应的Smith函数：\nGc​(ωi​,ωo​)Gc1​(ω)Λc​(ω)​=Gc1​(ωi​)Gc1​(ωo​)=1+Λc​(ω)1​=−21​+21​1+α2tan2θ​​\nGc​居然没和σcg​挂钩，官方解释是这样效果看起来很好，太真实了……\nDc​是清漆的微表面法线分布，采用各向同性的GTR1函数：\nDc​(ωh​)α​=2πlnα(α2cos2θh​+sin2θh​)α2−1​=mix(0.1,0.01,σcg​)​\n至此，Disney BRDF的计算就介绍完毕，可以在Shader中实现了。\n实现效果\n我依次实现了Disney BRDF中的各个部分，最终将它们组合起来。第一步是漫反射：\n\n接下来是高光：\n\n这里有两个和直觉相悖的现象：\n\n粗糙度越大，物体表面显得越暗。\n粗糙度较大时，物体边缘显得比中间更暗。\n\n对此我尝试在自己的知识范围内作出解释。第一个现象的原因应该是随着粗糙程度的增加，Smith遮蔽函数的值会越来越小；此时微表面间的间接反射也会增加，Torrance-Sparrow模型忽略了这部分反射，从而导致物体显得暗淡。至于第二个现象，fresnel现象会增加金属物体边缘的亮度，但这里的参数恰好将fresnel现象的影响降得极低；而当光从几乎垂直于物体表面法线的方向入射时，部分反射光方向是朝向表面下方的，这部分也应该作为被微表面间的间接反射进行处理的光没有被模型纳入考虑，也就造成了金属物体边缘的暗淡。\n最后是清漆，它是另一个弱一些的高光项，就不放图了。清漆的强度参数取值范围是[0,1]，实际使用时被映射到了[0,0.25]，我在使用时一直觉得很难看出来，这可能是由于我所使用的环境光中的高频能量不够，使得清漆的高光效果不明显。\n在将各部分结合起来时，需要对各部分进行重要性采样。我们以min(0.8,1−σm​)的概率采样漫反射；若未采样漫反射，又以1/(1+σc​/2)的条件概率采样高光，并以最后剩下的概率采样清漆。至于sheen项，它的能量占比太小，就忽略好了。在最终计算概率密度函数值时，设漫反射、高光和清漆对应的pdf分别为pd​,ps​,pc​，则根据全概率公式：\np=min(0.8,1−σm​)pd​+(1−min(0.8,1−σm​))(2+σc​2​ps​+2+σc​σc​​pc​)\n这里显然是可以改进的，不过我已经等不及要看看效果了，就先这样吧。实现过程完全是抄公式，没什么好说的。现在来展示一下。首先我们把metallic和specular设为0，分别取roughness为0.1, 0.35, 0.65和1，来画一只茶壶：\n\n然后再把roughness固定为0.25，调整metallic来观察茶壶外观的变化：\n\n也可以加上法线贴图、通过纹理来指定物体表面各点的Disney BRDF参数，不过这个茶壶模型没有纹理坐标，所以就到这里吧。最后放个东西多一点的场景（茶壶材质来自这篇paper）：\n\n这颜色……我的审美没救了。\n以上渲染使用的佛像来自Stanford 3D Scanning Repository，人像和螃蟹来自3D Scans，茶壶来自Benedikt Bitterli，环境光来自HDRI Heaven。代码可以在我的github上找到，水平比较渣，见笑了。\nNEXT STEP\nDisney BRDF的一个显著缺点是无法处理透明和半透明的材质，这在之后的扩展版——Disney Principled BSDF中得到了解决。BSDF版本不仅引入了透射，还支持了介质吸收和Normalized Diffusion BSSRDF，这需要渲染算法加以支持。不出意外的话，我以后会有一篇关于它的实现笔记。"},"articles/2019.03.18.White-Furnace-Test":{"title":"White Furnace Test","links":["{{site.url}}/2019/02/20/disney-brdf"],"tags":["Atrc","Graphics"],"content":"本文没什么内容，只是一时兴起试了一下。\n在不考虑fresnel项时，在一个各方向各位置radiance相同的环境光中放置一个物体，该场景能够测试材质是否满足能量守恒的特性，被称为白炉测试（white furnace test）。\n如果设环境光对任意方向的radiance为定值，那么一个理想的渲染算法 + 一个能量守恒的材质应该会使得场景中的物体完全隐形，因为看到的物体表面任意一点的颜色都和周围环境完全相同。要证明这个结论也很简单：已知路径追踪算法是无偏的，我们把路径追踪算法使用的路径样本按照路径长度分类，然后从低到高使用强数学归纳法即可。严格的证明我就懒得写了，总之原理是这么一回事。值得注意的是在实践中有些和材质无关的因素可能会导致测试失败，比如路径追踪算法截断了路径的最大长度、使用法线贴图这种没有物理依据的技术等，都会造成一定的能量损失或增益。现在来测试一下Atrc中的一些材质。\n首先是理应能量守恒的玻璃：\n\n咦，说好的不可见呢，难道我用了这么久的玻璃材质写得有问题？检查了半天，注意到path tracer的最大深度被设置在了20，会不会是这个值太低了（不过这么大的能量损失实在太夸张了），索性一下改到1000：\n\n灰蒙蒙一片，这就对了，话说如果我按照传统选用球体作为测试模型，是不是就不会遇到这个问题了？\n理想漫反射材质（BRDF为常量）肯定是能量守恒的，结果和玻璃一样，就不放图了。\n接下来是Roughness分别为0、0.5以及1的disney brdf中的diffuse部分：\n\n可以看到粗糙度越高，反射总能量越多，最右边的茶壶简直像一锅发光的魔法物质。怪不得我总觉得高roughness的disney diffuse物体就跟光源似的（见此实现）。一种可能的解释是这样的设计是为了补偿粗糙度较高时高光lobe没有考虑multiple scattering造成的能量损失，但我觉得这说不通，因为disney brdf给diffuse赋予了一个1 - metallic的权重，导致金属材质并不能获得这个补偿。也就是说，disney brdf中的diffuse更偏向于这种解释，而没有把微表面间的multiple scattering纳入考虑。\n接下来看看使用GGX分布的Torrance-Sparrow模型。忽略fresnel项，将粗糙度分别设为0、0.5和1，得到：\n\n这个高光模型会造成明显的能量损失也是意料之中的事情——一来Smith遮蔽函数会稍微过高地估计被遮蔽的微表面比例，二来微表面间的multiple scattering被模型忽略了，而粗糙度较高时这部分能量也会很多。"},"articles/2019.07.10.Light-Tracing":{"title":"Light Tracing：算法概述和实现","links":[],"tags":["Atrc","Graphics"],"content":"传统的path tracing算法从摄像机镜头向外发射射线，并不断散射、寻找光源；与之相对地，我们也可以从光源向外发射射线，并不断散射，寻找镜头。这样的算法被称作“light tracing/particle tracing”，本文将简单地介绍其原理。在这之前要声明一下，这算法基本没什么应用，最多拿来检验一下自己对光线传播理论的理解。\nImportance Propagation\n我们用来做path tracing的理论基础一般是所谓的rendering equation和measurement equation。非volumetric的rendering equation长这样：\nL(x→ωo​)=Le​(x→ωo​)+∫S2​fs​(ωi​→x→ωo​)L(x←ωi​)∣cos⟨nx​,ωi​⟩∣dωi​\n其中L(x→ωo​)是场景中从x点向方向ωo​传播的辐射亮度（radiance），Le​是x点的自发光，S2表示整个单位球面对应的立体角，fs​是BSDF，nx​是x​点的法线。一些基本概念在这里就不再解释了，总之这个方程告诉了我们如何求在场景中任意一点朝任意一个方向观察到的亮度。\n另一个方程measurement equation对许多人来说要陌生一些，长这样：\nIj​=∫sensor​∫S2​We​(x→ω)fj​(x)L(x←ω)dωdAx​\n其中Ij​是像素j的值，x是摄像机传感器上的某点，We​(x→ω)表示x点对来自ω方向的radiance产生的响应强度（就是用来把radiance转换成颜色的映射），fj​则是用来重建像素j的filter（参见此文）。这里我写出的形式可能和其他一些文献给出的形式不同，比如把pbrt里的一个cos项塞到We​里了，这不会影响算法的正确性。不得不说measurement equation对理解path tracing来说是比较鸡肋的，即使不显式借助于它也能写出正确的渲染器。但是要反过来做light tracing，也就是要以光源为起点建立以摄像机传感器为终点的路径时，We​就比较重要了。\n现在我们理想化地在场景中某点p​放置一小束朝向ω​方向的光，如果这束光恰好朝向传感器，那么它的radiance乘上传感器上对应点x​的We​(x→−ω)​，就是它让x​点产生的直接响应。而如果这束光没有照射到传感器，那么它也会在场景中的物体间散射，并有可能在多次散射后击中传感器，让其产生间接响应。由此可见，“响应”可以定义在场景中的每个点和方向上，表示此处的光源对摄像机传感器的影响有多大。我们把“响应比”记作W(x,p←ω)​，其含义是一小束光源L(p→ω)dωdAp⊥​​对传感器上的x​点会造成的响应与L(p→ω)​的比值。这样一来，下述积分可以求出传感器上的x​点对整个场景中的光源产生的响应：\n∫light area​∫S2​Le​(p→ω)W(x,p←ω)∣cos⟨np​,ω⟩∣dωdAp​\n而Ij​​也就可以从measurement equation变形出来了：\nIj​=∫sensor​fj​(x)(∫light area​∫S2​Le​(p→ω)W(x,p←ω)∣cos⟨np​,ω⟩∣dωdAp​)dAx​\n早在超过20年前，学界就给“响应比”W起了个名字——importance function，并且指出W,We​间的关系与L,Le​间的关系非常相似，按下面的规律传播：\nW(x,p←ω)=We​(q→−ω)+∫S2​fs∗​(ωi​→q→−ω)W(x,ωi​→q)∣cos⟨nq​,ωi​⟩∣dωi​\n其中q是从p出发沿着ω方向与场景的第一个交点，fs∗​是BSDF的伴随（adjoint）形式（具体可以参考Veach大佬的thesis）。正如光源的Le​充当了所有L值的根本来源一样，We​充当了W值的来源，也就是说我们可以用和路径追踪相似的方式来采样路径，只不过是以光源上的点为起点、以传感器为最终目标。\nLight Tracing\n至此，light tracing算法似乎已经可以按上一节中给出的Ij​​计算式以及W​的传播方程来编写了，唯一剩下的问题在于——对一条从光源出发的路径，我们无法规定它最后会落到sensor上的哪一点，也就是说我们不能像path tracing那样想在film上的哪个位置采样就在那个位置采样。\n假设我们一共从以光源为起点采样了N条路径，分别记作X1​,X2​,…,XN​，现以fj​为基础定义路径空间P上的扩展滤波函数fj′​​，使得它适用于所有路径：\nfj′​(X)={​fj​(x),0,​X的末端为传感器上的x点otherwise​​\n基于此，可以将measurement equation改写到路径空间P上：\nIj​=∫P​T(X)fj′​(X)dμX​\n其中T是路径的throughput，也就是路径起点处的Le​，乘上路径上所有的cos项、BSDF以及最后的We​等（那些没落到传感器上有效区域的路径的throughput当然就是0了）。据此，Ij​的蒙特卡洛估计量为：\nI^j​=N1​i=1∑N​p(Xi​)T(Xi​)fj′​(Xi​)​\n其中p表示采样路径的概率密度函数。这就给出了light tracing的算法流程：\nfor i = 1 to N\n\tconstruct path Xi from light source to camera\n\tfor j in all pixels\n\t    I[j] += (1 / N) * T(Xi) * fj&#039;(Xi) / p(Xi)\n\n实现效果\n实现时有一些细节需要注意，比如：\n\n一般在构造路径时都是用BSDF来采样，但在使用像小孔摄像机这样的We​里含有δ函数的摄像机模型时，路径中的最后一段必须在摄像机上采样，否则什么也看不见。\n必须仔细构造像素颜色与We​的关系，才能保证图像反映的是radiance，而不是其他的某种被错误放缩的量。我的考虑是：将We​在sensor上归一化，并在最后的图像上乘个总像素数。\n\n总的来说，我感觉light tracing的思想很简单，正确实现起来却比path tracing费力多了。下面看看效果：\n\n好像还不错？等等，我们和mis path tracing对比一下，虽然有实现水平的干扰，不过结果还是很明确的：\n\n收敛得是真的很慢——正如许多文献所说，这算法没什么用……也就渲染caustic的时候比path tracing好些：\n\n注意到上图中light tracing画出来的玻璃球完全是黑的，这是因为玻璃本身的BSDF是δ分布，而小孔摄像机模型的We​也是δ分布，采样任何一个分布都不能在二者间得到一条有效路径，也就没法画出来了。"},"articles/2019.07.26.Breakfast-Room":{"title":"Breakfast Room","links":[],"tags":["Atrc","Graphics"],"content":"果然决定效果好不好的主要是美术而不是技术啊……一个什么优化也不带的path tracer也能画得有模有样。\n\n场景模型来自这里，各物体材质参数是我凭感觉随便给的。"},"articles/2019.11.20.Float-to-Int-Exact-Range":{"title":"可用浮点数精确表示的整数范围","links":[],"tags":["C/C++"],"content":"我们知道，IEEE 754中的浮点数是对实数的近似表示，其取值密度在越远离0的地方越稀疏。那么，究竟在多远处浮点数会无法精确地cast到整数呢？本文对此进行了实验和分析。\n实验代码很简单：\nint main()\n{\n    for(int i = 0; i &lt; std::numeric_limits&lt;int&gt;::max(); ++i)\n    {\n        float f = static_cast&lt;float&gt;(i);\n        if(i != static_cast&lt;int&gt;(f))\n        {\n            cout &lt;&lt; i &lt;&lt; endl;\n            break;\n        }\n    }\n \n    for(int i = 0; i &gt; std::numeric_limits&lt;int&gt;::min(); --i)\n    {\n        float f = static_cast&lt;float&gt;(i);\n        if(i != static_cast&lt;int&gt;(f))\n        {\n            cout &lt;&lt; i &lt;&lt; endl;\n            break;\n        }\n    }\n}\n这段代码在VS2019中的输出如下：\n16777217\n-16777217\n\n也就是说，从+-16777217开始，我们就无法保证一个int被转为float后，还能完好无损地转回来了。对二进制数比较敏感的人可以注意到：\n16777217=224+1\n即浮点数能精确表示整数的范围为±224。这数字实在太“整”了，让我们试着从IEEE 754的浮点数格式中一探究竟。\n注意到我们讨论的数值落在float的规格化表示范围内。float包含1个符号位，8个指数位，以及23位的尾数。设符号位为s，阶码的无符号整数解释为e，尾数的位表示为\nf1​f2​…f23​\n则规格化的浮点数取值为：\n(−1)s×(1+2−1f1​+2−2f2​+⋯+2−23f23​)×2e−127\n当e−127=23时，上式变为：\n(−1)s×(223+222f1​+221f2​+⋯+2f22​+f23​)\n此时根据f每一位的值，该式可以取遍[−224+1,224−1]中的每一个整数。而当e−127=24且f的所有位均为0时，±224也可以被精确地表示。一旦超过了这个范围，就出现了相邻的两个浮点值间的距离超过1的情况，也就无法再精确表示剩余的整数了。"},"articles/2020.02.02.An-Interesting-Bug":{"title":"C++中的一个由析构顺序引发的bug","links":[],"tags":["C/C++"],"content":"今天刚解决的一个小bug，觉得很有意思，记录一下。\n本文有一些事实错误，待修改\n\n在C++中的构造/析构函数里调用虚函数通常不是个好主意。考虑如下代码：\nclass A\n{\npublic:\n \n    ~A()\n    {\n        cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; endl;\n    }\n};\n \nclass Base\n{\npublic:\n \n    ~Base()\n    {\n        cout &lt;&lt; &quot;Base destructor&quot; &lt;&lt; endl;\n    }\n};\n \nclass Derived : public Base\n{\n    A a;\n \npublic:\n \n    ~Derived()\n    {\n        cout &lt;&lt; &quot;Derived destructor&quot; &lt;&lt; endl;\n    }\n};\n \nint main()\n{\n    Derived derived;\n}\n运行这个程序得到的输出是：\nDerived destructor\nA destructor\nBase destructor\n\n可以看到，如果在Base::~Base()里调用了虚函数，此时Derived::A已经析构掉了，而调用的虚函数是有可能访问到Derived::A的，这会引发未定义行为。\n这个坑的原理非常简单，熟悉构造/析构函数执行顺序的人会觉得：这有什么有趣的，非常trivial的bug而已。的确，直接写出这个bug显得有点蠢，但有时这一问题会被一堆乱七八糟的其他逻辑藏起来。我今天遇到的这个bug出现在需要多线程的离线渲染里，被隐藏在好几层继承以及多线程之后，原理是这样的：\nclass Base\n{\n    // ... : some other members\n \n    atomic&lt;bool&gt; stop_ = false;\n \n    thread worker_;\n \nprotected:\n \n    virtual void foo() = 0;\n \npublic:\n \n    virtual ~Base()\n    {\n        stop();\n    }\n \n    void start()\n    {\n        stop_ = false;\n        worker_ = thread([this]\n        {\n            // do something\n \n            while(!stop_)\n                foo();\n \n            // do something\n        });\n    }\n \n    void stop()\n    {\n        stop_ = true;\n        if(worker_.joinable())\n            worker_.join();\n    }\n};\n \nclass Derived : public Base\n{\n    // ... : some other members\n \nprotected:\n \n    void foo() override\n    {\n        // do something\n    }\n};\n \nint main()\n{\n    Derived derived;\n    derived.start();\n}\n如上述代码，对虚函数的调用被隐藏在由Base创建的另一个线程中。Base::~Base()对worker_执行了join，但此时Derived::~Derived()已经被调用了；也就是说，在“Derived::~Derived()被调用”到“Base::~Base()完成对worker_的join”之间的这段时间里，worker_对应的线程可能会调用虚函数foo，进而访问Derived实例中已经被销毁的各种设施，引发未定义行为。"},"articles/2021.05.013.Mod-Operator":{"title":"取模运算","links":[],"tags":["C/C++"],"content":"对常见取模运算规则的总结。\nIntro\n给定整数a和b，在几乎所有的编程语言中，r=a%m都符合以下条件：\nqa∣r∣​∈Z=qb+r≤∣b∣​\n但是，这还不足以严格地定义r——其符号仍然是未知的。不同的编程语言中亦有不同的决定符号的方法，本文对这些方法稍做总结。\nTruncated Division\n一种常见的方法是通过：\nr=a−b×trunc(ba​)\n来定义r，其中trunc把一个数的小数部分直接丢弃掉，即向0取整。注意到：\n​b×trunc(ba​)​≤∣a∣\n故r若非0，则其符号总是和a相同。\nFloored Division\nr=a−b×⌊ba​⌋\n此时容易验证，若r非0，则其符号总是和b相同。\nEuclidean Division\nr=a−∣b∣⌊∣b∣a​⌋\n此时，r总是非负的。这一定义比较符合我们的常识——数论中一般也是这样约定的。\nImplement FD/ED with TD\nC/C++等语言提供的%运算符是按Truncated Division定义的，但我们常常需要另外两种取模语义，因此需要对其进行转换：\nint floor_div_rem(int a, int b)\n{\n    int r = a % b;\n    if((r &gt; 0 &amp;&amp; b &lt; 0) || (r &lt; 0 &amp;&amp; b &gt; 0))\n        r += b;\n    return r;\n}\n \nint euclidean_div_rem(int a, int b)\n{\n    int r = a % b;\n    if(r &lt; 0)\n    {\n        if(b &gt; 0)\n            r += b;\n        else\n            r -= b;\n    }\n    return r;\n}"},"articles/2021.06.011.Atmosphere-Rendering":{"title":"预计算大气散射模型：原理与实现","links":[],"tags":["Graphics"],"content":"最近在学习实时渲染的常见技术。这里用自己的语言整理一下最近阅读和实现的实时大气渲染方法，主要参考《A Scalable and Production Ready Sky and Atmosphere Rendering Technique》和《Precomputed Atmospheric Scattering》两文。\n大气散射模型\n我们把大气散射模型建立在对“星球”这一概念的近似上。星球大致是一个半径为R的球体，在此基础上通过一个高度场来描述地表起伏。在地表以外、半径小于R′（显然R&lt;R′）的空间中存在着非均匀的大气层。由于大气中的空气折射率随着位置的不同而不同，光线穿过大气层时会弯曲，这在实时渲染中很难模拟，因而本文忽略光线的偏转现象。\n渲染方程\n对介质中或物体表面的某个位置x，从x向方向ω传输的辐射亮度（radiance）L(x→ω)由下述渲染方程给出：\nL(x→ω)​=Le​(x→ω)+ T(x,y)∫S2​fs​(ωi​→y→−ω)∣cos⟨ny​,ωi​⟩∣L(y←ωi​)dωi​+ ∫xy​T(x,p)σs​(p)(∫S2​ρ(ωi​→p→−ω)L(ωi​→p)dωi​)dlp​​\n其中y=raycast(x→−ω)；ρ是介质的相函数（phase function）；fs​是物体表面的BSDF；T(a,b)表示a,b之间的透射率（transmittance），其定义为：\nT(a,b)=exp(−∫ab​σt​(p)dlp​)\nσs​为介质散射系数，σt​为介质衰减系数。更多关于此渲染方程的相关内容可见文介质渲染，这里只是回顾一下符号，不再赘述。\nRayleigh\n在大气层中，空气分子带来的散射可以用Rayleigh theory近似描述：\nσRt​(h,λ)σRs​(h,λ)ρR​(μ)​=σRs​(h,λ)=σRs0​3Nλ48π3(n2−1)2​e−HR​h​=16π3​(1+μ2)​Rayleigh衰减率Rayleigh散射率Rayleigh散射相函数​\n其中，h是位置的海拔高度（与球心的距离减去球面半径R），λ是波长，n是空气折射率，N是海平面R处的空气分子密度，μ表示cos⟨−ωi​,ωo​⟩，HR​是一个与大气性质相关的常数。\nMie\n除了Rayleigh散射外，大气中还存在小颗粒（气溶胶，小水珠等）带来的散射与吸收现象，由Mie theory近似描述：\nσMt​(h,λ)σMs​(h,λ)σMa​(h,λ)ρM​(μ)​=σMs​(h,λ)+σMa​(h,λ)=σRs​(0,λ)e−HM​h​=βσMs​(h,λ)=8π3​(2+g2)(1+g2−2gμ)3/2(1−g2)(1+μ2)​​Mie衰减率Mie散射率Mie吸收率Mie散射相函数​\n其中g是相函数的非对称因子；β,HM​均为常数。\nOzone\n臭氧层对地球大气层外观也有较大的影响，当太阳靠近地平线时，是臭氧的吸收效应使得天空的大部分区域呈现为蓝色。在本文中，其吸收率由下式近似表示：\nσOa​(h,λ)=σO0​(λ)max{0,1−15km∣h−25km∣​}\n汇总\n在实时渲染中，我们不可能逐波长地去计算光的散射，而是采用RGB三个分量对光谱上的能量分布进行了近似，故λ参数也只能进行取定为某个值，记作λ0​。由此，我们在计算大气散射时使用的σt​,σs​以及ρ为：\nσt​(h)σs​(h)ρ(μ)​=σRs​(h)+σMt​(h)+σOa​(h)=σRs​(h)+σMs​(h)=σs​(h)σRs​(h)​ρR​(μ)+σs​(h)σMs​(h)​ρM​(μ)​\n拆解和近似\n透射率\n透射率T(a,b)描述了一束光从a点传播到b点后，尚未被吸收或衰减的辐射亮度比例。T(a,b)仅与a和b的位置有关，和地形无关，因此，我们可以在假定星球上没有任何凸起（即所有地表到球心的距离都是R）的情况下讨论T的计算。\n对大气层中的某一点po​和某个方向ω，我们总是可以通过刚体坐标变换将po​点变换到球心O的正上方，且ω位于xOy平面上。此时，设pe​是射线p=po​+tω(t≥0)与大气层外侧边缘或地表的最近交点，则T(po​,pe​)仅依赖于两个标量：r=∥po​∥以及ω在xOy平面上的角度θ：\n\n我们将这一信息记录在预计算的表格T(r,θ)中。对大气中的任意两点a,b，T(a,b)都可以根据这个表格计算出来：\nT(a,b)=T(a,c)/T(b,c)=T(ra​,θa​)/T(rb​,θb​)\n\n零散射项\n\n设想从大气中某一点p向ω发射一条射线，正好可以命中太阳，那么L(p←ω)无疑包含了从太阳直接发出的光。这部分辐射亮度可以由下式给出：\nL0​(p←ω)=Le​T(rp​,θpω​)\n其中，Le​是从太阳表面出发的辐射亮度。L0​可以通过在天空中单独绘制一个表示太阳的“圆盘”来添加，因此和其他的部分几乎没有实现上的耦合。\n单次散射项\n\n所谓单次散射，是指光自光源出发以来仅经过了一次介质散射后就进入了观察者的眼睛。大气层的散射率不高，因此我们观察到的光的大部分能量都来自单次散射光线。记单次散射的辐射亮度为Ls​，那么：\nLs​(p←ω)=∫ppe​​T(p,q)σs​(hq​)(∫S2​ρ(cos⟨ωi​,ω⟩)L0​(p←ωi​)Vsun​(q,ωi​)dωi​)dlq​\n其中Vsun​表示q点ωi​方向上太阳的可见性（取值为0或1）。如果我们做一个简化，假设太阳在这里可以被视为一个理想方向光，Le​被替换为Ee​δsun​，那么上式可以简化为：\nLs​(p←ω)​=∫ppe​​T(p,q)σs​(hq​)ρ(cos⟨ωsun​,ω⟩)Ee​T(rq​,θqωsun​​)Vsun​(q)dlq​​\n在实现中，Vsun​可以通过Shadow Mapping技术求出，外层积分则在ray marching过程中近似计算，T(p,q)也在ray marching时一并求出：\nLs​(p←ω)=q∑​T(p,q)σs​(hq​)ρ(cos⟨ωsun​,ω⟩)Ee​T(rq​,θqωsun​​)Vsun​(q)Δlq​\n单次反射项\n\n单次反射项是指从太阳出发，仅在地表反射一次，然后就进入观察者眼中的光。和之前一样，我们假设太阳光是方向光。记单次反射项为Lr​(p←ω)，从p点往ω方向观察到的地面点为x，地表BSDF为fs​，那么：\nLr​(p←ω)=T(p,x)fs​(ωsun​→x→−ω)cos⟨nx​,ωsun​⟩Ee​Vsun​(x)T(rx​,θxωsun​​)\n多次散射项\n\n多次散射项确实比较难算，我们先引入几个简化：\n\n对使用path tracing算法产生的ground truth观察可知，当散射次数增加时，相函数的非对称性对结果的影响会迅速下降，表现得越来越趋近于各向同性的相函数（即pu​=1/(4π)），据此，我们在计算二次及以上次数的大气散射时，均可以尝试把相函数替换为pu​。\n多次散射时的光线路径很难用像Shadow Mapping那样的技术来快速判定散射点之间的可见性，再考虑到这些路径遍布整个大气层，通常不会被遮挡得很严重，不妨在计算多次散射时忽略可见性函数，即假设V的值总是1。\n忽略地面反射在多次散射中的贡献。\n\n对大气层中的某一点p，下式描述了p处恰好经过两次散射后的内散射（in-scattering）项：\nL2​(p)=∫S2​(Ls​(p←ω)+Lr​(p←ω))ρu​dω\n对应地，三次散射项为：\nL3​(p)=∫S2​(∫0D​T(p,q)σs​(q)L2​(p)dlq​)ρu​dω   where   D=∣raycast(p,ω)−p∣\n这里忽略了地面在多次散射中贡献的能量。四次散射项、五次散射项等均可以通过与上式相似的公式计算，只需要把其中的L2​对应地替换为L3​,L4​即可。\n根据多次散射结果在空间中非常低频的特性，我们假设L2​,L3​,L4​等在点p的周围的取值可以被近似为L2​(p),L3​(p),L4​(p)等，于是积分内部的Li​可以被近似为Li​(p)，并提到外面来：\nL3​(p)L4​(p)L5​(p)​=L2​(p)∫S2​(∫0D​T(p,q)σs​(q)dlq​)ρu​dω=L3​(p)∫S2​(∫0D​T(p,q)σs​(q)dlq​)ρu​dω=L4​(p)∫S2​(∫0D​T(p,q)σs​(q)dlq​)ρu​dω⋯⋯​\n这个近似有个很大的槽点——虽然说Li​在空间中确实变化缓慢，但将其视为一个常量也只应局限于某个小范围内；而上式中，D可能有非常大的值，其对应的q点离p点有数百公里也是很正常的，将这样的q处的Li​也近似为Li​(p)，我只能说效果好就必有其合理性了……\n现令：\nf=∫S2​(∫0D​T(p,q)σs​(q)dlq​)ρu​dω\n那么L3​(p)=L2​(p)f,L4​(p)=L2​(p)f2。然后把上面的多次散射项都加起来：\nL∗​(p)=L2​(p)(1+f+f2+⋯)=1−fL2​(p)​\n由于忽略了地表起伏产生的遮蔽，根据球体的对称性，L2​(p)中的p实质上可以被简单地参数化为p的海拔高度hp​。再加上另一个参数——太阳光的方向相对于p的角度，我们就得到了另一张二维查找表M。输入p的海拔高度和太阳角度，就能从表中查得单位太阳光强度下p处的L∗​。\n当然，我们不一定需要这么多近似才能计算出M——在忽略地貌起伏的前提下，我们不需要略去地面反射，也不用假设Li​在局部可被当作常量，就可以用path tracing精确地计算出M来。但上述方法提供了一种快速产生M的技术，使得实时编辑大气参数成为了可能。\n汇总\n综上所述，L(p←ω)可由下式计算：\nL(p←ω)​=Le​Vsun​(p)T(rp​,θpω​)+ T(p,x)fs​(ωsun​→x→−ω)Ee​Vsun​(x)T(rx​,θxωsun​​)+ q∑​T(p,q)σs​(hq​)(ρ(cos⟨ωsun​,ω⟩)Ee​T(rq​,θqωsun​​)Vsun​(q))+M(hq​,ωsun​))Δlq​​太阳本身地表反射单/多次散射​\n其中太阳本身作为一个“圆盘”，可以在大气绘制完成之后单独叠加上去；地表反射项可以在绘制地表时计算，单次散射和多次散射则需要通过一个ray marching过程计算。此外，有的透射率项被写成T，表示它的值通过查表获得，而有的则被保留成T(a,b)的形式，这表示它的值是在ray marching时累积得到的。\n实现\n我用C++和DirectX 11实现了本文所述的大气渲染模型，代码仓库位于AtmosphereRenderer。\n天空纹理\n由于天空颜色分布比较低频，可以计算一个低分辨率的天空纹理，然后在渲染时采样它，以此提高性能。在靠近地平线的角度，天空的颜色变化往往会比其他区域要剧烈一些，因此可以通过调整天空纹理坐标和方向的关系来改善其效果，譬如：\nv=0.5(1+sign(l)π/2∣l∣​​)     (l∈[−π/2,π/2])\n其中l是方向向量与水平面的夹角。这个纹理只需要在太阳角度改变时重新计算，其计算代价也不高，即使每帧进行也不会带来很严重的负担。典型的天空纹理如下图所示：\n\n空气透视表\n在渲染场景中的物体时，我们需要从摄像机到物体表面进行ray marching，以计算这段路径上的积分。为了提高效率，可以预先将摄像机视锥体划分为一个较低分辨率的三维表格A，然后填充每个表项对应的位置与摄像机之间的透射率和内散射积分。在渲染场景中的物体时，直接查表即可。\n在考虑了遮蔽项（Vsun​）时，如果表格A的分辨率太低，其中的体积阴影容易产生“锯齿感”，如下图：\n\n提高A的分辨率自然可以改善这一现象，但要将其完全掩盖，需要相对较高的分辨率，这会带来不小的计算开销。因此，我们退而求其次，抖动A的采样点位置来掩盖锯齿。依照屏幕空间的蓝噪声将每个采样点在一定范围内随机抖动可得：\n\n这把锯齿状的artifact转化成了噪声，更容易被人眼忽略。\n效果图\n\n\n\n调整大气参数可以观察到一些信息：\n\n在自然情形下，除非有比较强的雾/霾，否则地形遮蔽产生的体阴影应该是很难看出来的（我是没在现实中见到过）。可以把阳光调得更亮或削减大气层的厚度会使得体积阴影显得更为明显\n太阳周围那一圈灰白色的光晕主要是Mie散射带来的\nRayleigh散射是大气颜色的主要决定者。白天散射蓝光较多，使得天空呈蓝色；黄昏/日出时光路变长，蓝光更多地被散射到其他方向上了，于是太阳附近呈橙色\nOzone吸收会使得天空更加偏向蓝色，在黄昏/日出时尤为明显\n\n性能\n渲染质量和耗时之间存在tradeoff，这里仅以我自己认为视觉质量可以接受的参数做性能测试。在GTX 1060上，用Nsight Graphics测得的数据如下：\n\n天空纹理（64 * 64分辨率）：0.03~0.04 ms\n空气透视表（无体阴影，64 * 64 * 32分辨率，积分步数32）：0.03 ms\n空气透视表（有体阴影，200 * 150 * 32分辨率，积分步数32）：0.2 ms\n\n其他渲染阶段只是查这两个表，比如渲染地形时查空气透视表，或者把天空纹理铺到屏幕上等等，它们的性能消耗主要不在大气系统上，故不进行测试。\n在启用地形遮蔽造成的体阴影时，空气透视表的分辨率过低会产生严重的artifact，因此需要适当提高其分辨率，并且在光线步进过程中需要频繁读取太阳对应的shadow map，因此其性能相比无体阴影的版本会大幅下降。\n不足\n\n需要path tracing产生reference，以判断结果的正确性和衡量误差。\n没有考虑星球尺度的渲染，代码都是以摄像机在大气层内为假设而编写的，因此把摄像机抬高到大气层之外时效果会暴毙\n"},"articles/2021.06.28.SDF-Gen":{"title":"符号距离场生成","links":[],"tags":["Graphics"],"content":"3D SDF的快速生成\n本文所述内容的GPU实现：SDFGenerator\nSDF\n给定封闭表面M，可以根据M定义一个空间中的标量函数：\nu(p)=q∈Mmin​∣p−q∣\nu(p)表示网格表面到p的最近距离，称为无符号距离场（unsigned distance field，UDF）。基于u，我们可以定义出另一个函数：\ns(p)={​+u(p),−u(p),​p is inside Motherwise​​\ns就是本文的主角，被称为有符号距离场（signed distance field，SDF）。\n对一般的M，SDF不具备解析形式，且计算非常耗时。因此，我们通常会预计算物体的SDF，供运行时快速查询使用。SDF的压缩/近似是一个非常困难的问题，不在本文覆盖的范围内。本文仅讨论三维空间下针对三角网格的SDF生成，生成结果以三维数组的形式存储。\n既有方法\n根据定义，可以很容易想到下述暴力方法：\nfor each voxel v:\n    # compute udf\n    udf = infinity\n    for each triangle T on M:\n        udf = min(udf, distance(v, T))\n    # compute sdf\n    if is_inside(v, M):\n        sdf[v] = udf\n    else\n        sdf[v] = -udf\n\n当三角形数目和三维数组分辨率都较大时，这一算法耗时会长到令人无法忍受。\n人们提出了各种各样的加速SDF生成的方法，譬如：\n\n引入空间加速数据结构，减少对每个体素需要检测的三角形数量\n反转暴力算法，对每个三角形，计算它到每个体素中心的距离，并更新到体素数组上\n一类被统称为扫描转换的算法，用于计算物体表面附近小范围内的SDF（narrow-band SDF）\n\n生成算法\n我们使用上一节提到的第一种优化措施——引入空间加速数据结构来减少需要遍历的三角形数量。以下将这一数据结构记作A，A需要以下操作：\n\n对空间中的任意一个球体，判断是否有三角形与该球体相交\n对空间中的任意一个球体，给出与该球体相交的三角形列表\n\n满足这一需求的空间加速数据结构很多，诸如BVH树，KD树等都可以，可以根据实际性能选取，这里不再赘述。然后就可以用A来加速计算UDF了：\nr = find_proper_radius(A, p)\nTs = find_intersected_triangles(A, p, r)\nudf[p] = compute udf(p) with Ts\n\n其中，find_proper_radius会以p点为中心找到一个合适的球体半径rp​，它需要满足：\n\n存在三角形与该球体相交\nrp​尽可能小\n\n我们可以采用二分搜索等算法来搜索一个比较合适的rp​。在得到rp​之后，只需要遍历rp​范围内的所有三角形，用它们计算UDF。当然，对每个体素都运行一遍二分搜索仍然是非常耗时的，我们可以利用UDF的局部性来改善这一问题。对空间中任意两点p,q，有：\nu(q)≤u(p)+∥p−q∥\n也就是说，假如我们已经计算出了p点的UDF值，那么以q点为中心，以u(p)+∥p−q∥为半径的球体内一定存在三角形。倘若p和q点非常接近，我们就可以直接把u(p)+∥p−q∥当作rq​，用于计算u(q)。这样一来，我们只需要在最开始用二分搜索估计某个体素的r，而对其他体素，可以直接用与之相邻的体素处的SDF值结合这两个体素的距离快速得到半径。\n综上，计算UDF的算法如下：\nr0 = find_proper_radius(A, p0)\nT0 = find_intersected_triangles(A, p0, r0)\nudf[p0] = compute udf(p0) with T0\nfor each voxel pi other than p0:\n    let pj be a neighboring voxel with known udf\n    ri = udf[pj] + |pi - pj|\n    Ti = find_intersected_triangles(A, pi, ri)\n    udf[pi] = compute udf(pi) with Ti\n\n对每个体素，我们都只需要遍历很少的一部分三角形，就可以精确地计算出其UDF值。\n符号判定\n在计算了UDF之后，我们还需要判断体素在物体的内部还是外部。由于在实践中，并不是所有的物体都严格满足watertight的要求，我们不会简单地根据最近三角形的法线来判定内外，而是发射多条射线，并在击中物体表面的射线中有一半以上命中物体外侧时，判定SDF为UDF，否则为-UDF。这一判断方法付出了一定的时间代价，但极大地提高了符号判定的鲁棒性。此外，射线和三角形的求交可以重用之前的空间加速数据结构A。\n实现效率\n我用DirectX 11 Compute Shader在GPU上实现了本文所述的SDF生成算法。在GTX 1060上，对结构比较复杂、三角形数量在十万左右的物体，生成512^3分辨率的高精度SDF，并且在每个体素处用多达12条射线来判定符号，整个生成流程也可以在十几秒内完成。这样的计算效率离实时非常遥远，但对预计算来说是可以接受的。"},"articles/2022.04.03.LPM":{"title":"Lightweight Photon Mapping","links":[],"tags":["Atrc","Graphics"],"content":"我们知道，VCM（Vertex Connection &amp; Merging）把PM（Photon Mapping）和BDPT（Bidirectional Path Tracing）融合了起来，可以鲁棒地handle一些比较难的场景。但是对大多数应用来说VCM的overhead实在太大了，大多数时候我们只需要用PT（Path Tracing）绘制不算复杂的照明，然后加上用PM画的焦散，所以这里讨论以下怎么把这两个算法结合起来，算是VCM的简化版。\n长度不超过3的路径\n对长度为2的路径x1​x2​，我们简单地从摄像机镜头上的点x1​发出射线，击中x2​处的光源，不需要做什么特别的处理。\n对长度为3的路径x1​x2​x3​，我们使用MIS（Multiple Importance Sampling）结合BSDF采样和光源采样，也不需要PM的参与。\n长度超过3的路径\n对长度k&gt;3的路径xˉ=x1​x2​⋯xk​，采样该路径的方法一共有三类：\n\nUnidirectional PT，直接用一系列BSDF采样构造出整个路径\nUnidirectional PT，但在到达xk−1​后转而使用光源采样得到xk​\n在x2​,…,xk−2​处使用VM（Vertex Merging），融合光子图中的顶点，得到剩下的路径\n\n这些方法对应的路径pdf为：\npPTbsdf​​(xˉ)pPTlight​​(xˉ)pVMt​​(xˉ)​=p(x1​)i=2∏k​p(xi−1​→xi​)=p(x1​)i=2∏k−1​p(xi−1​→xi​)plight​(xk​∣xk−1​)=p(x1​)i=2∏t​p(xi−1​→xi​)i=t∏k−1​p(xi​←xi+1​)p(xk​)πr2​\n其中p(a→b)是使用BSDF采样从顶点a采样顶点b的area pdf，p(a←b)是其adjoint版本，plight​是光源采样的area pdf，p(x1​)是摄像机镜头上的area pdf，p(xk​)是光子发射源的area pdf。现假设一共发射了NVM​个光子，那么对采样方法v，其MIS权重是：\nwv​(xˉ)=pPTbsdf​​(xˉ)+pPTlight​​(xˉ)+NVM​∑t=2k−2​pVMt​​(xˉ)pv​(xˉ)​\n计算wPT\n我们做一些形式上的变换：\nwPTbsdf​​(xˉ)1​​=1+p(xk−1​→xk​)plight​(xk​∣xk−1​)​+NVM​πr2t=2∑k−2​∏i=2k​p(xi−1​→xi​)∏i=2t​p(xi−1​→xi​)∏i=tk−1​p(xi​←xi+1​)p(xk​)​=1+p(xk−1​→xk​)plight​(xk​∣xk−1​)​+p(xk−1​→xk​)NVM​πr2p(xk​)​t=2∑k−2​p(xt​←xt+1​)i=t+1∏k−1​p(xi−1​→xi​)p(xi​←xi+1​)​​\n令：\ndPTm​​​=t=2∑m​p(xt​←xt+1​)i=t+1∏m+1​p(xi−1​→xi​)p(xi​←xi+1​)​=p(xm​→xm+1​)p(xm​←xm+1​)p(xm+1​←xm+2​)​+t=2∑m−1​p(xt​←xt+1​)p(xm​→xm+1​)p(xm+1​←xm+2​)​i=t+1∏m​p(xi−1​→xi​)p(xi​←xi+1​)​​\n把m换成τ=m+2，那么：\ndPT3​​dPTτ​​wPTbsdf​​(xˉ)​=0=p(xτ−2​→xτ−1​)p(xτ−2​←xτ−1​)p(xτ−1​←xτ​)​+p(xτ−2​→xτ−1​)p(xτ−1​←xτ​)​dPTτ−1​​=1+p(xk−1​→xk​)plight​(xk​∣xk−1​)​+p(xk−1​→xk​)NVM​πr2p(xk​)​dPTk​​1​​\n同理：\nwPTlight​​=1+plight​(xk​∣xk−1​)p(xk−1​→xk​)​+plight​(xk​∣xk−1​)NVM​πr2p(xk​)​dPTk​​1​\n计算wVM\n整理一下形式：\nwVMt​​(xˉ)1​​=∏i=2t​p(xi−1​→xi​)∏i=tk−1​p(xi​←xi+1​)p(xk​)πr2∏i=2k−1​p(xi−1​→xi​)(plight​(xk​∣xk−1​)+p(xk−1​→xk​))​+NVM​r=2∑k−2​∏i=2t​p(xi−1​→xi​)∏i=tk−1​p(xi​←xi+1​)∏i=2r​p(xi−1​→xi​)∏i=rk−1​p(xi​←xi+1​)​=W1​+NVM​W2​​\nW1​用于融合VM和PT，W2​用于融合不同位置处的VM，接下来分别计算这俩。\n计算W1\nW1​​=∏i=2t​p(xi−1​→xi​)∏i=tk−1​p(xi​←xi+1​)p(xk​)πr2∏i=2k−1​p(xi−1​→xi​)(plight​(xk​∣xk−1​)+p(xk−1​→xk​))​=∏i=tk−1​p(xi​←xi+1​)p(xk​)πr2∏i=t+1k−1​p(xi−1​→xi​)(plight​(xk​∣xk−1​)+p(xk−1​→xk​))​=p(xt​←xt+1​)p(xk​)πr2plight​(xk​∣xk−1​)+p(xk−1​→xk​)​i=t+1∏k−1​p(xi​←xi+1​)p(xi−1​→xi​)​​\n记yi​=xk+1−i​，则：\nW1​=p(xt​←xt+1​)p(y1​)πr2plight​(y1​∣y2​)+p(y2​→y1​)​i=1∏k−(t+1)​p(yi​→yi+1​)p(yi+1​←yi+2​)​​\n令：\ndVMTm​​=i=1∏m​p(yi​→yi+1​)p(yi+1​←yi+2​)​\n并将m替换为τ=m+2，那么：\ndVMT1​​dVMTτ​​W1​​=dVMT2​​=1=p(yτ−2​→yτ−1​)p(yτ−1​←yτ​)​dVMTτ−1​​   (3≤τ≤k−t+1)=p(xt​←xt+1​)p(y1​)πr2plight​(y1​∣y2​)+p(y2​→y1​)​dVMTk−t+1​​​\n计算W2\n把W2​按和式的下标拆成三项：\nW2​​=r=2∑k−2​∏i=2t​p(xi−1​→xi​)∏i=tk−1​p(xi​←xi+1​)∏i=2r​p(xi−1​→xi​)∏i=rk−1​p(xi​←xi+1​)​=1+r=2∑t−1​∏i=2t​p(xi−1​→xi​)∏i=tk−1​p(xi​←xi+1​)∏i=2r​p(xi−1​→xi​)∏i=rk−1​p(xi​←xi+1​)​+r=t+1∑k−2​∏i=2t​p(xi−1​→xi​)∏i=tk−1​p(xi​←xi+1​)∏i=2r​p(xi−1​→xi​)∏i=rk−1​p(xi​←xi+1​)​=1+W21​+W22​​\n然后分别整理W21​和W22​：\nW21​W22​​=r=2∑t−1​∏i=2r​p(xi−1​→xi​)∏i=r+1t​p(xi−1​→xi​)∏i=tk−1​p(xi​←xi+1​)∏i=2r​p(xi−1​→xi​)∏i=rt−1​p(xi​←xi+1​)∏i=tk−1​p(xi​←xi+1​)​=p(xt−1​→xt​)1​r=2∑t−1​p(xr​←xr+1​)i=r+1∏t−1​p(xi−1​→xi​)p(xi​←xi+1​)​=r=t+1∑k−2​∏i=2t​p(xi−1​→xi​)∏i=tr−1​p(xi​←xi+1​)∏i=rk−1​p(xi​←xi+1​)∏i=2t​p(xi−1​→xi​)∏i=t+1r​p(xi−1​→xi​)∏i=rk−1​p(xi​←xi+1​)​=p(xt​←xt+1​)1​r=t+1∑k−2​p(xr−1​→xr​)i=t+1∏r−1​p(xi​←xi+1​)p(xi−1​→xi​)​=p(xt​←xt+1​)1​r=3∑k−t​p(yr​←yr+1​)i=r+1∏k−t​p(yi−1​→yi​)p(yi​←yi+1​)​​\n令：\ndVM→m​​dVM←m​​​=r=2∑m​p(xr​←xr+1​)i=r+1∏m​p(xi−1​→xi​)p(xi​←xi+1​)​=p(xm​←xm+1​)+r=2∑m−1​p(xr​←xr+1​)p(xm−1​→xm​)p(xm​←xm+1​)​i=r+1∏m−1​p(xi−1​→xi​)p(xi​←xi+1​)​=r=3∑m​p(yr​←yr+1​)i=r+1∏m​p(yi−1​→yi​)p(yi​←yi+1​)​=p(ym​←ym+1​)+r=3∑m−1​p(yr​←yr+1​)p(ym−1​→ym​)p(ym​←ym+1​)​i=r+1∏m−1​p(yi−1​→yi​)p(yi​←yi+1​)​​\n并将m替换为τ=m+1，那么：\ndVM→1​​dVM←1​​dVM→τ​​dVM←τ​​W21​W22​​=dVM→2​​=0=dVM←2​​=dVM←3​​=0=p(xτ−1​←xτ​)+p(xτ−2​→xτ−1​)p(xτ−1​←xτ​)​dVM→τ−1​​   (3≤τ≤t)=p(yτ−1​←yτ​)+p(yτ−2​→yτ−1​)p(yτ−1​←yτ​)​dVM←τ−1​​   (4≤τ≤k−t+1)=p(xt−1​→xt​)1​dVM→t​​=p(xt​←xt+1​)1​dVM←k−t+1​​​\nSpecular Event\n如果某个顶点xi​(2≤i≤k−2)或yi​(3≤i≤k−t+1)处的散射是specular，那么在这里没法做vertex merging，有几个d需要对应地做出修改。\n注意到：\ndPTτ​​=t=4∑τ​p(xt−2​←xt−1​)⋯\n在∑中，t=t0​所代表的项对应了在xt0​−2​处进行的VM。因此，xi​为specular顶点意味着dPTi+2​​的递推式中只包含上一项的乘积项，不包含另一个求和项。\n类似地：\ndVM→τ​​dVM←τ​​​=r=3∑τ​p(xτ−1​←xτ​)⋯=r=4∑τ​p(yτ−1​←yτ​)⋯​\n在∑中，r=r0​代表的项对应xr0​−1​或yr0​−1​处进行的VM，因此xi​或yi​为specular意味着dVM→i+1​​或dVM←i+1​​的递推式中只包含乘积项。\n实现\n光子图生成\n注意到dVMTτ​​的计算依赖于p(yτ−2​→yτ−1​)和p(yτ−1​←yτ​)，前者在构造光子路径时可以顺便记下来，但是后者的完整形式是p(yτ−1​←yτ​←yτ+1​)，其中的yτ+1​为Camera Subpath的末端倒数第二个顶点，在构造光子图时是未知的。也就是说，光子yi​处记录的数据只能是dVMTi−1​​/p(yi−2​→yi−1​)，实际的dVMTi​​只有在VM时才能计算。类似地，yi​处只记录dVM←i−1​​/p(yi−2​→yi−1​)。\n整理一下，光子yi​需要携带的信息至少包括βp​,pdfp​,dVMTi−1​​,dVM←i−1​​,plight​(y1​∣y2​),p(y2​→y1​),p(y1​)：\n\nβp​,pdfp​\ndVMTi−1​​/p(yi−2​→yi−1​)\ndVM←i−1​​/p(yi−2​→yi−1​)\n(plight​(y1​∣y2​)+p(y2​→y1​))/p(y1​)\n\n其中第四项可以预先乘到第二项上。\n路径追踪\n追踪一条路径的时候，需要携带的信息包括：\n\nβ,pdf\ndPTi−1​​,p(xi−2​→xi−1​),p(xi−2​←xi−1​)\ndVM→i−1​​,p(xi−2​→xi−1​)\n\n每追踪到一个新顶点xa​(a&gt;=2)，都需要执行下面的操作：\n\n如果xa​是光源表面的点，那么：\n\na = 2，则构成一条长度为2的路径，直接计算最终计算\na = 3，则存在BSDF采样和光源采样两种构成路径的技术，MIS之\na &gt; 3，则存在两种PT技术和许多种PM技术，利用dPT​计算出MIS权重\n\n\n在光源表面采样一点xa+1​，连接xa​和xb​构成完整的路径，此时：\n\na + 1 = 3，则存在BSDF采样和光源采样两种构成路径的技术，MIS之\na + 1 &gt; 3，则使用dPT​计算MIS权重\n\n\n搜索光子图中xa​周围的光子，对每个光子做VM，并用dVM→​计算其MIS权重\n"},"articles/2022.05.28.DX-Matrix-Storage":{"title":"关于HLSL中的矩阵传参","links":[],"tags":["DirectX","Graphics"],"content":"一个非常简单的问题，但是网上的资料群魔乱舞，这里备忘一下。\n首先定义好数学意义上的两种写法，和存储方式无关：\nTL​=​1000​0100​0010​xyz1​​      TR​=​100x​010y​001z​0001​​\n利用它们对点进行变换的方式分别是u′=TL​u和v′=vTR​，其中u是列向量，v是行向量。\n然后我们定义两种存储方式：行主序（row-major）和列主序（col-major）。对某个矩阵：\nM=​m11​m21​m31​m41​​m12​m22​m32​m42​​m13​m23​m33​m43​​m14​m24​m34​m44​​​\n行主序在内存中把它排成这样：\nm11​​m12​​m13​​m14​​m21​​⋯​m44​​\n而列主序则是这样：\nm11​​m21​​m31​​m41​​m12​​⋯m44​​\n现在假如我们使用DirectXMath作为host端的数学库，它是行主序存储的，构造变换矩阵的方式是上面的TR​那种。如果我们把要把它的矩阵传进shader用，那么就需要做一个行-列存储方式的转换。这可以通过一个转置操作来完成。转置是个纯数学操作，但是反映到内存排布上，就恰好等价于“数学上没做操作，存储上换了种方式”。\nDone."},"articles/2023.07.02.Statically-Get-Class-Type":{"title":"在C++中获得当前类的类型","links":[],"tags":["C/C++"],"content":"比我一开始以为的要困难许多，不知道有无更简单的方法。\n来看一个C++填空题：\n// 完善此宏，使下面的断言成立\n#define DEFINE_SELF ?\nstruct A { DEFINE_SELF };\nstruct B { DEFINE_SELF };\nstatic_assert(std::is_same_v&lt;A::Self, A&gt;);\nstatic_assert(std::is_same_v&lt;B::Self, B&gt;);\n一个比较直观的想法是利用this的类型，把Self提取出来：\n#define DEFINE_SELF using Self = std::remove_pointer_t&lt;decltype(this)&gt;;\n让我们看看llvm-cl怎么说：\nerror : invalid use of &#039;this&#039; outside of a non-static member function\n\n我尝试了很多次，如用非静态成员函数做中转、从成员函数指针萃取等，都宣告失败；简单地google一下，得到的也是满屏幕的“寄”。\n不过，我最终还是在某个犄角旮旯里发现了一个repo（链接），虽然没什么star，却确实地解决了问题。\n以下是简化过的代码实现，在我的渲染器Rtrc中有使用：\ntemplate&lt;typename T&gt;\nstruct SelfTypeReader\n{\n    friend auto GetSelfTypeADL(SelfTypeReader);\n};\n \ntemplate&lt;typename T, typename U&gt;\nstruct SelfTypeWriter\n{\n    friend auto GetSelfTypeADL(SelfTypeReader&lt;T&gt;) { return U{}; }\n};\n \nvoid GetSelfTypeADL();\n \ntemplate&lt;typename T&gt;\nusing SelfTypeResult = std::remove_pointer_t&lt;decltype(GetSelfTypeADL(SelfTypeReader&lt;T&gt;{}))&gt;;\n \n#define DEFINE_SELF                                                         \\\n    struct SelfTypeTag{};                                                   \\\n    constexpr auto SelfTypeHelper() -&gt;                                      \\\n        decltype(SelfTypeWriter&lt;SelfTypeTag, decltype(this)&gt;{}, void()) { } \\\n    using Self = SelfTypeResult&lt;SelfTypeTag&gt;;\n之前提到过，我一直没找到怎么把decltype(this)利用起来，问题的核心在于没法静态地访问this。那么这段代码的思路就是利用auto函数返回值类型可以被延迟推导的特点，在一个可以访问this的地方把decltype(this)给记录到某个外部函数的返回类型上。\n首先，SelfTypeReader声明了一个函数auto GetSelfTypeADL(SelfTypeReader)，此时我们还不知道它的返回类型是什么。接着，DEFINE_SELF在一个可以合法地使用this的地方把decltype(this)塞给了SelfTypeWriter，它内部提供了auto GetSelfTypeADL(SelfTypeReader)的实现，将decltype(this)以GetSelfTypeADL返回类型的方式记录下来。最后，我们借助之前定义的SelfTypeReader拿到需要的结果。\nSelfTypeTag的存在只是为了确保不同对每个不同的类型，都有唯一对应的SelfTypeReader/SelfTypeWriter。\n这套做法令人十分眼熟……仔细一想，这不就是臭名昭著的Stateful Metaprogramming吗……\nC++，很奇妙吧~"},"articles/2024.02.23.VDM-Baking":{"title":"Vector Displacement Map生成二三事","links":[],"tags":["Graphics"],"content":"小结一下春节在家搞的玩具。\n引言\n本文相关代码，注意我用的optimal transport第三方实现因为license的问题，暂时没有以代码的形式放在里边儿，以后可能会换个别的实现包含进去。\n所谓vector displacement map，就是把普通displacement map的每个元素给换成一个三维向量，使得被displace的表面不仅能向法线方向移动，也能在切平面上移动，就像这样：\n\n（上图来源于这里）\n可以看到，只要VDM的分辨率足够高、作为其基底的uniform grid mesh足够精细，它就可以扭出任意我们想要的形状来（当然，拓扑不能变）。\n我所面临的需求是使用很低精度的VDM，尽可能精确地表达出给定的形状。\n相关工作\n略。关键词如下，有兴趣可以去查已有的文献：\n\nVector Displacement Map\nRegular Quadrilateral Mesh\nGeometry Images\n\nNaive Solution\n来看这个mesh：\n\n首先给它自动生成一套UV。严格地说，是做个固定边界的mesh parameterization。这会给mesh的每个顶点赋予一个uv。我们把uv作为“位置”，把mesh在[0,1]2上绘制出来，会得到这样的效果：\n\n现在想象一下把uniform grid覆盖在这个[0,1]2区域上，那么这张图就告诉了我们uniform grid上的每个顶点v对应原始mesh的位置pm​(v)。将v在uniform grid上的原始位置记作po​(v)，那么v对应的displacement vector就是：\nd(v)=pm​(v)−po​(v)\n至此，我们得到了一张能把uniform grid扭出mesh形状的vdm：\n\nGrid Density Optimization\n这张VDM似乎还不错，但经不起细看。原始mesh的上半部分在世界空间中的表面积较大，但在参数空间中的面积较小，这导致uniform grid中只有很少的顶点是用来描述这部分mesh的，进而其细节损失了不少；与此相对，mesh底座的平面部分没有任何细节，却有大量grid顶点聚集在上面，既浪费了vdm的存储，又浪费了gpu处理顶点的算力。\n我们把grid精度降低到32x32，问题会更明显：\n\n显然，grid的许多顶点被浪费在了无关紧要的地方，真正重要的形状特征却没采样到。这就是接下来需要解决的问题，我们将其划分为两个子问题：\n\n如何确定mesh的哪些区域更加重要？\n如何让grid在mesh的重要区域分布得更密集？\n\nVertex Importance\n第一个问题比较简单，可以很容易地设计出成吨的启发式方案，比如计算原始mesh上的曲率、计算上述vdm拟合结果和原始mesh之间的差异等。我采用的方法如下：\n记三角形f的法线为nf​；对非边界边e，记包含e的两个三角形为{f1​(e),f2​(e)}；对每个顶点v，记与其相接的非边界边构成的集合为E(v)。那么顶点v的重要度为：\nI(v)=e∈E(v)max​{0.5−0.5(nf1​(e)​⋅nf2​(e)​)}\n说人话就是：与顶点相连的边对应的棱越是尖锐，此顶点就越是重要。\n重要度计算无疑有更好的方案，但目前这个效果挺好，暂时就这样了。\nDensity Optimization\n我们可以从以下两个思路出发来调整网格的密度：\n\n调整mesh parameterization的结果，使得高重要度的顶点在参数空间分布得稀疏些。这在理论上是可行的，我之前仅仅是简单粗暴地使用了LSCM(least squares conformal maps)。然而我们需要在优化重要度分布的同时避免distortion，有点复杂，搁一边儿待考虑。\n在参数空间把uniform grid的采样位置扭一扭，使之多采样重要度高的区域。这个实现起来要简单很多，有不少思路，比如把让重要顶点在参数空间吸引附近的grid顶点，然后把grid转换为弹簧模型求解。在这里，我采用的是另一个实现方法：\n\n以每个顶点为中心，以其重要度为强度，随便选个kernel，把所有顶点splat到参数空间，得到一个importance field。\n把importance field归一化成一个概率分布，在固定边界点的情况下计算均匀分布到它的optimal transport，得到一个bijective transport map，那么transport的目标位置就是uniform grid的采样位置。\n\n\n\n方案2的optimal transport虽然也很难求解，但这是个标准问题，可以直接用第三方实现，不像方案1那样需要自己修改parameterization metric。 事实上，“用相对简单的方式做平面参数化，再在参数空间中进行调整”也是一种经典的参数化流程，其目的正是降低优化的难度。\n来看看效果，第一步得到的importance field如下：\n\n绿色的是mesh parameterization的结果，红色的是importance field。可以看到，石头和地面连接的部分因为变化比较锐利，形成了一圈高重要度区域；整个参数空间的正中间则对应mesh的上半部分，因顶点密集，同样形成了高重要度区域。\n接下来跑个uniform distribution到importance distribution的optimal transport，就得到了对应的uniform grid扭法：\n\n左边是transport map中grid顶点对应的位移，右边是按transport map调整grid采样位置后的结果。如我们所愿，重要度较高的区域现在有更高的grid密度。\n最后，用新grid采样原始mesh，效果如下：\n\n左边是原始版本，右边是新版本，棒极了。\nPS：在把顶点重要度splat到参数空间前，可以给背景板赋予一个初始重要度。调整这个值，就能控制顶点在不重要区域的密度，就像这样：\n\nSharp Feature Alignment\n在优化了grid density后，VDM表达形状的能力已经比初始版本强许多了，但它仍然对锐利的棱角无能为力。比如：\n\nMesh与底座相接的部分（红框中）接近于直角，在VDM中却表现得平滑了。事实上，即使我把这个VDM的分辨率翻两倍、翻四倍，问题也只是被缓解，无法根除。\n显然，如果能微调grid的采样点位置，让其顶点正好落在mesh的角上，让其边正好落在mesh的棱上，就能精确地把mesh的棱角表达出来。我们把这些棱角统称为“sharp feature”，具体规定如下：\n\n两个相邻三角形之间法线差异超过指定阈值时，将它们共享的边称为sharp edge。\n与超过两条sharp edge相连的顶点被称为sharp corner。\n\n在找到mesh中所有的sharp features后，就可以依照下述规则在参数空间微调grid的采样位置：\n\nGrid vertex离某个sharp corner很近时，把该grid vertex挪到corner在参数空间的位置上。\nGrid edge和某条sharp edge相交时，把grid edge上离交点近的那个grid vertex挪到交点处。\n挪动前检查下会不会产生fold over，会的话别挪。\n每个grid vertex至多被挪动一次。\n\n来看看微调前后的效果对比：\n\n完美！\n再看来个极端点的，用16x16的VDM拟合下面的方盒子：\n\nGrid density optimization和sharp feature alignment的效果都很明显\n对角线方向\nGrid由四边形构成，然而实际渲染时我们仍然需要把四边形都拆成三角形。此时，斜边的方向可能会受到sharp edge的影响。比如对四边形abcd，如果恰好有一条sharp edge穿过ac，那么我们就需要把abcd拆成abc，acd。\n这意味着，每个quad都可能有自己的斜边方向，这对vdm的渲染是很不利的。如果想避免每个uniform grid都有自个儿的index buffer，就需要mesh shader之类的技术，在shader中根据vdm中额外记录的斜边方向信息动态生成三角形。\n\n左边是全局统一斜边朝向的效果，右边是根据sharp edge情况调整了斜边朝向后的效果，难以忽视其间差异。\n后话\n有了如此高效的VDM，快扛起大旗，向每个人宣扬VDM的美好，让VDM的春风吹遍全世界吧！\n什么，你问为什么不直接摆一个mesh在这？\n嗯，好问题……\n\n2025.08 补充：看看正规军的工作《Adaptive Surface Meshes from Harmonic Maps》，啧……"},"articles/2024.04.13.Fast-Marching-Methods":{"title":"Fast Marching Methods","links":[],"tags":["Graphics"],"content":"参考资料\nA Fast Marching Level Set Method for Monotinically Advancing Fronts\nA Second-Order Fast Marching Eikonal Solver\nOn the Implementation of Fast Marching Methods for 3d Lattices\nEikonal Equation\n考虑一团以一定的速度往外扩散的东西，需要计算空间中每个地方p被这东西覆盖的时刻T(p)（称为抵达时间）。将扩散速度记作F (F&gt;0)，显然有：\n∣∇T∣F=1, T=0 on Γ\n其中Γ是起始区域。说人话就是距离 = 速度 x 时间，且起始区域的“抵达时间”为0。如果F仅依赖于p，那么就得到了Eikonal Equation。\nFMM\n基本就是Dijkstra算法，但是在“传播”这一步上做了点手脚，把距离的更新换成了基于Eikonal Equation的版本，其目标是使得：\nDmax​(min{∇D+​T,0})2=F21​\n其中∇D+​T是T沿D方向的单边方向导数，−argmaxD​实际上就是波前法线方向。\n\n将domain离散化，得到一堆点，记作P；将所有与点p (p∈P)直接相邻的点记作N(p)。\n有一小部分点对应起始区域，其T一定为0，其他点的T为∞。\n把所有位置划分为三类：F,A,U。F是已经求出T的点，A是正在求的，U是暂时还没纳入考虑范围的。\n初始化这三个集合：\n\nFAU​←{p ∣ T(p)=0}←{p ∣ ∃n∈F,p∈N(n)∖F}←P∖(F∪A)​\n\n初始化T(A)：\n\nT(p)←n∈N(p)min​F(p)dist(p,n)​\n\n重复后面的步骤直到A为空。\n令p=argminp∈A​T(p)，将p转入F。\n对N(p)的每个点n，若n∈U，则将其转入A。\n对N(p)中的每个点n，若n∈/F，则根据Eikonal Equation更新T(n)。\n\nFMM on 2D Grid\n来撸个二维网格上的FMM实践一下。输入是N×N的均匀网格，每个格点与其上下左右的四个格点直接相邻，且距离为1，速度恒定为1。这些格点中有一部分是起始区域，其格点坐标记录在sources中。\n首先是初始化工作：\nfor each p in all_grid_points:\n    T[p] = infinity\n \nF = empty set\nA = empty set\nfor each p in sources:\n    T[p] = 0\n    F.add(p)\n \nfor each p in sources:\n    for each n in neighbors[p]:\n        T[n] = 1 # 从相邻的source point传播过来，距离为1，速度为1，故耗时为1  \n        A.add(n)\n然后是主循环，不断把活跃集A中抵达时间最小的元素挪进F中，并更新其邻居的抵达时间：\nwhile A is not empty:\n    p = find element with smallest T from A\n    A.remove(p)\n    F.add(p)\n \n    for each n in neighbors[p]:\n        if T[n] == infinity: # n是个未接触过的新格点\n            A.add(n)\n        update T[n]\nupdate T[n]是最关键的步骤。在Dijkstra算法中，这里的操作是：\nfor each nn in neighbors[n]:\n    T[n] = min(T[n], T[nn] + 1)\n然而，我们并不是在一个长得像均匀网格的图上求最短路，这个均匀网格实际上是一个连续区域的近似。按Eikonal Equation来更新的话，需要做的是找到一个新的T[n]值，使之满足下面的方程：\nd=±1max​(max{T(n)−T(n+[d,0]T),0})2+d=±1max​(max{T(n)−T(n+[0,d]T),0})2=F21​=1\n其实就是把∇D+​T平方了一下，然后分解到x,y两个方向上计算。\n怎么解这个方程呢？我们首先计算两个T(n+[d,0]T)中较小的那一个，存放在x中。这么做的理由是很直观的——从此方向传播而来，可以更快地到达n；此外，容易验证“x对最终结果产生了贡献”与“x是两个值中较大的那个”这两个命题间存在矛盾。\n写成代码就是：\nx = infinity\nif n[0] &gt; 0:\n    x = min(x, T[n + [-1, 0]])\nif n[0] + 1 &lt; N:\n    x = min(x, T[n + [1, 0]])\n类似地，我们把T(n+[0,d]T)中较小的那个值记作y。现在方程简化为了：\n(max{T(n)−x,0})2+(max{T(n)−y,0})2=1\n如果y的值非常大，以至于x+1≤y，那么方程左侧的第二项必定取0（否则第一项的大小就会超过方程右侧的1），此时直接令T(n)←x+1即可。类似地，如果y+1≤x，就直接令T(n)←y+1：\nif x + 1 &lt;= y:\n    T[n] = x + 1\nelif y + 1 &lt;= x:\n    T[n] = y + 1\nelse:\n    # ...\n如果代码进了else分支，那么我们已经知道T(n)比x,y都更大，因而可以丢掉方程中的max：\n(T(n)−x)2+(T(n)−y)2=1\n容易证明该方程一定有解，且两个解中只有更大的那一个比x和y都更大，因此，else分支中的代码为：\nelse:\n    a = 2\n    b = -(2*x + 2*y)\n    c = x*x + y*y - 1\n    delta = b * b - 4 * a * c\n    T[n] = (-b + sqrt(delta)) / (2 * a)\n完事儿了！来看看运行结果：\n\n左边是sources的分布，白色区域为起始区域；右边是normalize后的T。在本节高度简化的情境中（各处速度恒定为1，没有任何障碍物），FFM得到的正好就是距离场，看起来非常合理。\n如果我们把domain从2d grid换成体素化后的mesh，就能籍此近似计算mesh的geodesic distance field了。首先把mesh体素化，在体素构成的网格上运行FFM，得到每个体素的抵达时间。然后对体素的抵达时间进行简单的线性插值，就能得到mesh上任意一点的近似抵达时间——\n\n在速度恒定为1时，抵达时间和测地距离的值是相等的。"},"articles/2024.04.17.Discrete-Differential-Forms":{"title":"Discrete Differential Forms","links":[],"tags":["Mathematics"],"content":"参考资料\nCS 15-458/858: Discrete Differential Geometry. Keenan Crane\nDifferential forms crash course. Jiří Lebl.\nIntroduction to differential forms. Donu Arapura.\nDifferential Forms\nDerivative Operator\n一些基本规则：\ndf=n∑​∂xi​∂f​dxi​     f:Rn→R\ndx∧dy=−dy∧dx\nd(fdx)=df∧dx\nd(fg)=gdf+fdg\n在此基础上可以进行一些推导，比如：\nd(ω∧μ)=dω∧μ+(−1)kω∧dμ      ω  is a k-form\n(fdx+gdy+hdz)∧(adx+bdy+cdz)=(gc−hb)dy∧dz+(ha−fc)dz∧dx+(fb−ga)dx∧dy\nd(fdx+gdy+hdz)=(∂y∂h​−∂z∂g​)dy∧dz+(∂z∂f​−∂x∂h​)dz∧dx+(∂x∂g​−∂y∂f​)dy∧dx\n卧槽，叉乘和旋度！所以根据经典的∇×∇f=0，可以导出：\nd(df)=0\n事实上这一结论可以被推广到任意的k-form，结论仍然成立。\n几个有趣的对应关系——\ngradfcurlFdivFΔf:=div(gradf)​⟷df⟷⋆dω⟷⋆d⋆ω⟷⋆d⋆dω​\nd(dω)=0某种意义上和div(curlF)=0说的是同一回事：\ndiv(curlF)=0   ⟷   ⋆d⋆⋆dω=0   ⟷   d2ω=0\n特别注意一个小坑，针对k-form的laplacian operator是：\n⋆d⋆d+d⋆d⋆\n在k=0时第二项恰好为0。\n然而，d和⋆的适用范围可比grad,curl,div广得多。\n1-form\n所以到底什么是dx？这取决于我们是在什么样的上下文中进行的这一系列演算，换言之，演算出来的结果是拿来干嘛的。\n定义Rn中的1-formω为具有如下形式的表达式：\nω=n∑​fi​dxi​\n这里先把dxi​看作无特殊含义的记号，其意义要在确定了它能进行什么样的运算后才会浮现。现考虑某条性质良好的曲线C，定义ω在C上的积分为：\n∫C​ω=∫C​⟨f1​,…,fn​⟩⋅t^ds\n设想我们把曲线参数化为ϕ:D→S，则此积分可以被写成：\n∫C​ω=∫D​⟨f1​,…fn​⟩⋅⟨dtdx1​​,…,dtdxn​​⟩dt=∫D​(n∑​fi​dtdxi​​)dt\n其中ϕ(t)=(x1​,⋯,xn​)。可以看到，当使用参数t进行积分时，dxi​将被替换为：\ndxi​⟶dtdxi​​dt\n右侧的xi​是货真价实的Rn​中的坐标值。注意这里的dt也没什么特别含义，其意义仅仅是由积分运算赋予的，指明我们是在用什么来进行积分。（这符号系统也太垃圾了，上文中的dx,df,dt各具有不同的类型，真是整蛊小能手……）\n在这种诠释下，dx是由对它进行的积分定义的，对dx施加的一切运算规则都需要确保积分结果不变。\n这个诠释相当不错，dx在进行变量代换时不会受到影响，直到最后真的要用某个变量t进行积分时，才展开成与t有关的形式，不管中间进行了多复杂的变量代换，都蕴含在dx/dt中了。\n2-form\n考虑简化的情形：\nω=adx1​∧dx2​\n对参数化曲面ϕ:D→S，定义：\n∫S​ω=∫D​adx1​∧dx2​(∂y1​∂ϕ​,∂y2​∂ϕ​)dy1​dy2​\n其中，\ndx1​∧dx2​(v1​,v2​)=det(dx1​(v1​)dx1​(v2​)​dx2​(v1​)dx2​(v2​)​)\ndx1​(v1​)是v1​在dx1​方向上的长度。\n这就是说，dx1​∧dx2​在用dy1​dy2​积分时会变成：\n∫S​dx1​∧dx2​⟶∫D​∂(y1​,y2​)∂(x1​,x2​)​dy1​dy2​\n很容易将这套定义推广到k-form。\n验证\n上面的定义看起来很不错，还需要验证一下它是否满足我们熟悉的运算规则，这样才能大胆地用它来算东西。\n比如这是大家都喜欢的分配律：\ndx1​∧(dx2​+dx3​)=dx1​∧dx2​+dx1​∧dx3​\n验证如下：\n∫S​dx1​∧(dx2​+dx3​)​=∫D​det​dx1​(∂y1​∂ϕ​)dx1​(∂y2​∂ϕ​)​(dx2​+dx3​)(∂y1​∂ϕ​)(dx2​+dx3​)(∂y2​∂ϕ​)​​dy1​dy2​=∫D​det​dx1​(∂y1​∂ϕ​)dx1​(∂y2​∂ϕ​)​dx2​(∂y1​∂ϕ​)dx2​(∂y2​∂ϕ​)​​dy1​dy2​+∫D​det​dx1​(∂y1​∂ϕ​)dx1​(∂y2​∂ϕ​)​dx3​(∂y1​∂ϕ​)dx3​(∂y2​∂ϕ​)​​dy1​dy2​=∫S​dx1​∧dx2​+dx1​∧dx3​​\n这里省略了一些平凡的定义，比如2-forms之间的加法。在明确了各种定义后，这堆公式与其说是证明，不如说是平凡的同义反复。不过话说回来，整个数学都是同义反复（\n总而言之，透过积分和jacobian矩阵，我们终于可以拿着dx到处晃荡了。只是需要注意，这里differential k-forms的意义是由k维表面上的积分赋予的，如果我们处在一个相应的积分无数学意义的context中，就不能随意使用这些运算规则。\n当然，应该还有其他视角，进而适用范围也与此不同。不过我的学习态度比较功利，对此暂时不感兴趣。\nStokes’s Theorm\n∫Ω​dω=∫∂Ω​ω\n其中∂Ω表示Ω的边界。\n一个有趣的关联是，∂∂Ω=∅，于是——\n∫Ω​d2ω=∫∂Ω​dω=∫∂∂Ω​ω=∫∅​ω=0\n从而d2ω=0。\nInner Product\n对D⊆Rn上的k-formα,β，定义：\n⟨α,β⟩:=∫D​⋆α∧β\nVector-Valued k-form\nk-form是把k个向量映射成一个标量，Rm​-valued k-form则是把k个向量映射成一个m维向量。\n设α,β:V→R3，那么：\nα∧β(u,v)=α(u)×β(v)−α(v)×β(u)\nSurfaces\nInduced Metric. 对参数曲面f:D→S，设X,Y是D中的两个向量，它们在S上的夹角、长度等可以被这样反映：\ng(X,Y):=⟨df(X),df(Y)⟩\n注意到g(X,Y)=(Jf​X)T(Jf​Y)=XT(JfT​Jf​)Y，其中Jf​是f的Jacobian矩阵。我们把I:=JfT​Jf​称为first fundamental form，显然它是对称的。我没什么insight，看不出这哪里fundamental了……\n如果我们把眼光限制在二维曲面上的话，它上面的differential forms会相对简单，只有三种——\n\n0-form，标量函数\n1-form，就像曲面上的一个向量场\n2-form，scalar multiples of oriented area，某种意义上也像标量函数\n\n0/2-form之间对应的hodge star都非常平凡，1-form的hodge star则是在曲面上原地旋转90°。若将此曲面参数化为z:D→S，那么这个1-form hodge star可以表示成：\n⋆ω(X):=ω(JX)\n其中J是使得X在曲面上转90°的映射——\ndz(JX)=N×dz(X)\nDiscrete Differential Forms\n基本概念\nDiscrete differential k-form. oriented k-simplex → value。如果这个simplicial complex中的simplex是带编号的，那么上面的k-form就能直接用一个向量来表示，每个元素都代表一个oriented simplex对应的k-form值。\nde Rham Map. 设K是一个oriented simplicial complex，k-simplex σ∈K，可以像这样把k-formω离散化到σ上：\nω^σ​:=∫σ​ω\nBoundary. 设k-simplexσ=(v0​,v1​,⋯,vk​)，定义其边界为：\n∂σ:=i=1∑k​(−1)p(v0​,⋯,vi−1​,vi1​​,⋯,vk​)\n注意这里的加法就只单纯地组装出来一个oriented simplex的列表，这样的列表被称为“simplicial chain”。Simplex上的边界可以被自然地拓展到chain上：\n∂i∑​ci​σi​=i∑​ci​∂σi​\n美妙的事情来了，boundary of boundary是∅！\nSimplicial k-cochain：linear map taking a simplicial k-chain to a number——\nα(i∑​ci​σi​)=i∑​αi​ci​\n显然之前的discrete k-form可以被自然地视作一个simplicial k-cochain。k-chain就像k-vector，k-cochain则像k-form，也就是对k-vector的measurement：\n\n（图片来自CS 15-458/858）\nDiscrete Exterior Derivative\n既然discrete differential k-form是把differential k-form在oriented simplex上积分得来的，那么连续版derivative operator作用的结果在oriented simplex上积分，就能得到离散版本的d operator。\n考虑某个0-formϕ，它的离散版本是ϕ^​，即在顶点处采样ϕ得到的一堆值。我们知道，dϕ是个1-form，那么dϕ​就应该是把dϕ在1-simplex上积分的结果——\n(dϕ​)e​:=∫e​dϕ=∫∂e​ϕ=ϕ^​b​−ϕ^​a​\n其中oriented edgee=(a,b)。显然，这一结果可以借助Stokes定理推广到任意k-form上。噢噢噢噢噢，d^有了！\nMatrix Representation\n之前提到，在domain进行了编号的情况下，discrete k-form可以被编码成列向量。设想某个simplicial 2-complex，有∣V∣个顶点，∣E∣条边，而且都编好了号，那么从0-form到1-form的derivative operator就可以被编码为一个∣E∣×∣V∣的incident matrix，用它乘V对应的列向量， 就能得到E对应的向量。类似地，simplicial complex上所有的derivative都可以被编码成这样的矩阵，矩阵内容由simplicial complex中的邻接关系、编号、以及朝向决定。\nDiscrete Hodge Star\n之前把各种连续情形下的概念弄到离散情形下的方式都非常自然，但是接下来要说的discrete hodge star就充满了工程感——我们还没找到完美的离散版本，所以只能强行构造一个，近似捕获其主要特征，从而进行各种涉及到hodge star的计算（div,grad,curl,Δ等）。\nDual Forms (Based on Poincaré Duality). 对simplicial k-complex，其中的每个primal k-form对应一个dual 0-form，每个primal (k−1)-form对应一个dual 1-form，以此类推，每个primal 0-form对应一个dual k-form。\nCircumcentric Dual. 如何决定dual mesh的顶点位置呢？对simplicial k-complex中的每个k-simplex，其外接球体是唯一的，我们就把这个k-simplex的dual vertex放在球心的位置。可以证明，这样构造出的dual form和primary form在空间中相互垂直。\n也存在其他确定dual mesh位置的方式，但circumcentric dual是最常用的。\nDiagonal Hodge Star. 考虑一个primal k-formσ和其dual (n−k)-formσ∗，disgonal hodge star被定义为：\n⋆α(σ∗)=∣σ∣∣σ∗∣​α(σ)\n其中∣⋅∣是simplex cell的体积。\nDiscrete hodge star的定义背后有着这样的动机：假设primal form和其对应的dual form在几何上相互垂直，这和连续情形下的hodge star一致。我们知道，连续hodge star可以保持作用前后的”长度”不变，而discrete differential froms的值是把连续情形的值在simplex内积分得到的，其结果会受到cell大小的影响。通过∣σ∗∣/∣σ∣，这一影响被排除了。\n之所以把用这种方式定义的hodge star称为diagonal hodge star，是因为其矩阵表示是个对角矩阵，对角元素正是这些∣σ∗∣/∣σ∣。\n一般来说，我们很少会真的去计算dual mesh的位置，而是用各种边长和内角直接导出volume的比值，就像这样（0-form的volume被工程地设定为1）：\n"},"articles/2024.04.27.Cookbook":{"title":"菜谱分享","links":[],"tags":["Life"],"content":"食无定味，适口者珍。\n\n香碗\n\n猪肉馅，加葱白、姜末，蛋清、红薯淀粉，盐。\n摊蛋皮。\n蛋皮裹住肉馅，上汽蒸，参考时间半小时。\n切片，加汤。\n\n\n肉馅中的葱白和姜末尽量剁细一些，避免影响口感。肉馅太粗则容易形成在内部形成孔洞，影响切开后的外观。\n蛋皮用全蛋，可以加一点水淀粉让它更不容易破。烫蛋皮时锅上留一层油，用中小火。初始锅温不要太低，120°左右会缓慢凝固成一团，170°左右可行。\n确保蛋皮彻底成型后可以轻松揭下，如果感觉很软，就是还没烫到位。别急着出锅，这玩意儿没那么容易糊。\n蛋皮裹肉时可以先在蛋皮内侧抹一些水淀粉，便于其和肉馅结合。蛋皮适当裹紧一些，把接缝的位置压在下面，使其不易散开。\n蒸肉时根据底盘材质不同，可以选择性地刷一层油，避免粘在上面。\n冷却后切起来更容易些，热的时候容易破坏形状。\n\n关于烫蛋皮的后续补充：前面提到的温度是我用铁质炒锅得到的结论。最近买了口平底不粘锅，发现十分适合煎蛋皮。哪怕温度不那么高，蛋液稍慢些凝固，也不会在重力作用下聚集成一团。\n待补图。\n\n肉末豌豆\n从出门买材料到洗完碗不到一个小时，快得令我惊讶。\n\n炒肉末\n加豆瓣酱一起炒\n加[煮过的]豌豆，炒匀\n加水，调味，烧一会儿\n加仔姜丝，勾薄芡，出锅\n\n待补图。\n\n烧豆腐\n\n参照熊掌豆腐随便做的，味道不错，记下来。\n\n豆腐切片，多油煎干。\n肉末炒至油清亮，料酒去腥。\n依序加入并炒香下列材料：豆瓣酱，葱姜蒜，豆豉。\n加水，放入煎过的豆腐，水没过豆腐。\n加酱油、盐调味，加细辣椒面提色，加糖使味道柔和。\n大火烧开，中小火烧。\n中途加蒜苗杆切成的粒，再烧会儿。\n水剩余较少时加切成圈的小米椒和蒜苗叶。\n大火勾芡，出锅。\n\n\n肉末可以适当肥一些，只要煸炒到位、多烧会儿，只香不腻。\n煎豆腐时油温可以高一些，确保豆腐水分充分流失、定型，有利于后续烧制时入味。\n勾芡用的水淀粉别太稀了，做到芡汁下锅后短时间内就能收紧。\n豆瓣酱和豆豉最好提前剁细，使之更容易释放香味。\n\n\n麻婆豆腐\n从N次制作中总结而来。\n\n牛肉末煸干水分，加一点花雕酒去腥，加少许盐，小火煸至酥香，盛出备用。\n豆腐切成小方块，冷水下锅，加盐，煮至沸腾，盛出备用。\n小火，多油，把剁细的豆瓣酱炒熟，加葱白、蒜末、剁细的豆豉炒香。\n加水和焯好的豆腐，水稍微没过豆腐。有条件就用高汤，没条件就加鸡精。\n加少许糖，酱油调味，还可以加细辣椒面调色。\n烧开，中小火咕噜一会儿，中途加入一部分之前煸好的牛肉末。\n把蒜苗杆切成的颗粒和另一部分牛肉末也加入锅中。\n用浓稠的水淀粉，开大火勾芡，次数视锅中情况而定。\n最后加切碎的蒜苗叶，出锅，撒花椒面。\n\n\n肉末从低油温开始炒会更容易散开。\n焯水可以提前入味，去豆腥，以及增加豆腐韧性。还可以加点老抽提前上色。\n焯完水的豆腐可以暂时就保存在热水中，提前捞出来的话容易粘在一起。\n最开始给汤汁调味时应当适当偏淡，因为之后会蒸发一部分水分，而且材料都是入过味的。\n提前把一部分牛肉末放进去和豆腐一起烧，可以增加豆腐和汤汁的香味；另一部分牛肉末在最后才加入，则是为了保留其干酥的口感。\n多次勾芡间适当间隔那么十几二十秒，便于观察锅中的情况。最终使得汁水不能随意流动，但又不至于凝结成果冻质感。出锅后，芡汁要能把牛肉末、蒜苗、豆腐等托起来，不能全沉到下半部分去了。\n如果芡汁浓厚，油又偏少，看起来会很不美观。然而在家中放太多油实在让我很有心理压力，所以来点trick：在勾芡前从锅中表层打出一勺含油比例比较高的汤汁，出锅后再浇回去。\n豆腐极为脆弱，不能乱搅，建议用比较轻柔的“推”来代替搅拌。\n用小火把花椒炒一炒，然后铡成末，现焙现用，其香气远甚于买来的花椒面。\n\n\n\n蛋包饭\n大致可以分为三步：\n\n准备填充物，一般而言是炒饭\n煎蛋皮，在蛋液还没有完全凝固为固态，但无法自由流动时，把饭放到中间，将周围的蛋皮贴到饭的侧面\n倒扣到盘子里，上手塑形\n\n在经历了N次失败之后，我领悟了宇宙的真理——蛋包饭的底部原来是不用封口的！是的，只要放弃“让蛋皮全方位地包裹米饭”这个天真的想法，就可以避免把蛋包饭做成巨型蛋饺，或者因为操作时间过长导致蛋皮过老。\n另：我认为比较适合蛋包饭的一个炒饭配料：胡萝卜丁、（焯水）豌豆、淀粉肠丁、玉米粒、番茄酱。\n待补图。\n\n葱香五花肉\n\n懒人餐，建议搭配米饭做成猪肉盖饭。\n酱汁：盐，清酒，蒜泥，柠檬汁，清水。虽然名字带“酱”，但并不粘稠。\n\n五花肉切大片，中火，用香油煎出油脂，至表面微黄，控油\n加酱汁，烧一会儿至大部分水分蒸发\n勾薄芡\n加入大葱碎，拌匀出锅\n（撒白芝麻、黑胡椒末和小葱碎）\n\nNote：\n\n煎五花肉时温度可稍高，时间稍长，将表面煎至微黄\n并没有吃出放日式清酒和花雕酒的区别\n\n\n清炖牛肋条\n\n耗时虽长，但操作少，清闲时的懒人餐。\n\n牛肋条用葱姜酒三件套焯水。\n放进砂锅，加开水，少量姜片，一勺花雕酒，一丁点八角、香叶，小火开炖。\n中途可以选择性地把姜和香料捞出。看个人喜好。\n两小时后出锅，结束。\n\n\n香料宁少勿多，保持在能丰富味道但又不喧宾夺主的程度。如果肉的品质不错，不加也行。\n\n我通常不在清炖时放盐，喝汤前单独放，牛肉的味道则通过蘸水补充。自己常用的料汁有两种：\n\n酱油，少量米醋，少量香油。可以选择性地加入蒜末。\n蒜末和小米椒用热香激发香味，加入耗油、香菜末。可以选择性地来一勺红油辣子。\n\n\n照烧豆腐\n\n\n豆腐切片，用酱油和味淋腌味\n沾淀粉，两面煎至焦黄\n加酱油、味淋烧制收汁，出锅\n个人会再撒一点花椒面，丰富其味道\n\n就是咸 + 甜，具体使用糖、蜂蜜还是味淋倒无关紧要。豆腐也是标准的先煎后烧。把豆腐换成别的，譬如茄子，框架也是一样的。\n\n青椒酿肉\n\n\n肉末加姜末、盐、酱油、花椒粉、水，打匀，加淀粉，和匀\n青椒切断，将肉馅塞入其中，两边沾上小麦粉\n将塞了肉馅的青椒段用少量油煎，先给两边封口，再将青椒表面煎出微微的虎皮\n加酱油、糖、水混合成的酱汁，烧制收汁\n\n\n蒲烧茄子\n\n“蒲烧”一词通常只用在部分鱼类上，但在这里茄子是鳗鱼cosplay，所以就叫蒲烧茄子。\n料汁：咸甜即可，自己看着来，比如酱油加蜂蜜加水。\n\n茄子去皮，切成十厘米左右长的柱子，上汽蒸十分钟左右\n把茄子从中间剖开，划一些口子，就像书卷一样展平\n把展平的茄子煎至两面微焦黄\n加料汁，烧一会儿，收汁出锅\n\n展平的茄子尽量薄一些，不然会难以烧透。\n\n咖喱牛肉\n\n\n洋葱切碎，少量油煸透，至彻底变色。\n牛肋条切块，焯水。\n姜片爆锅，煸炒牛肉，加水、之前煸过的洋葱、酱油、糖，根据喜好加八角、香叶等香料，开炖！\n炖至中途，加滚刀切的萝卜块，当然，配菜选择都看个人喜好。\n牛肉炖软后，加滚刀切的土豆块、咖喱块、牛奶，慢慢收汁，出锅！\n\n我会在收汁时加一小块巧克力增加风味。\n\n茄汁土豆肉饼\n\n不知道确切的名字。\n\n小土豆去皮，加盐煮十分钟左右。\n土豆沥干，加橄榄油、辣椒粉、蒜粉、迷迭香、百里香、盐、黑胡椒，和匀。\n土豆200摄氏度烤20分钟左右，至金黄色。我没有烤箱，用空气炸锅代替。\n洋葱切碎，加少量蒜末，炒至半透，加入番茄泥，加糖、披萨草、盐、胡椒调味，适当熬制。\n在牛肉末中加适量洋葱末、蒜末，加入鸡蛋、辣椒粉、芥末酱、面包屑、盐、胡椒，搅拌后制成小肉饼。\n肉饼煎至两面金黄，将之前的番茄酱抹在饼上再煎会儿。\n摆盘，收工！\n\n\n完整的小土豆内部难以入味，因此外部下料应狠一些。\n\n\n烧鳝段\n\n\n鳝鱼斩成段备用。\n大蒜温油浸炸至表面起皱，备用。\n七成油温下鳝鱼，煸炒至油清亮后下少量盐、料酒，继续煸炒。\n加入豆瓣酱、姜末，煸炒出红油。\n加入泡椒段、泡姜片、之前炸过的大蒜，稍微煸炒，加水、酱油、料酒、糖，开始烧制。\n数分钟后，稍微收汁，加入葱段，大火勾芡，出锅。\n\n\n可以先用醋和盐抓洗鳝鱼，去掉表面的粘液，再切断。\n\n\n蒜香排骨\n\n空气炸锅真是偷懒神器，备菜简单，一锅出。\n\n排骨泡去血水，加蒜末、姜片、酱油、料酒、耗油、糖、盐、黑胡椒、淀粉，和匀后腌制一会儿。\n排骨表面裹一点油，空气炸锅180度加热28分钟，中途翻个面，收工。\n\n\n蒜末要切细，量可以多一些，也可以用干蒜粉。\n空气炸锅底部加一点水，可以避免排骨变得太干。\n\n\n空气炸锅烤牛肋条\n\n\n牛肋条切小块，加盐、酱油、花雕酒、少许糖、黑胡椒，腌制一会儿\n在空气炸锅中铺一张铝箔纸，放入牛肋条块，180℃烤10分钟\n在铝箔纸上戳个洞让大部分汁水漏下去，牛肋条块翻面，再烤6分钟，收工。\n\n省事且美味，但对牛肋条的品质有一定的要求，筋膜过多或非常不均匀的肉慎用。\n\n土豆烧排骨\n\n\n排骨焯水，擦干。\n少量油，将小排煸去水分，加酒去腥。\n加豆瓣酱炒香，加姜、大葱段、花椒，小火炒出香味。\n加开水，少许酱油，一点冰糖，小火烧四十分钟左右。\n加土豆块，拣去姜片、葱段等，根据想要的汁水多少调整火力，烧至土豆软糯，出锅。\n\n\n把排骨换成牛肋条，慢炖两小时，就是川式的土豆烧牛肉。炖煮前可以加干辣椒、八角、桂皮、香叶、干山楂片，末尾可以加仔姜丝，只要搭配和谐，可以自由发挥。\n\n\n\n卡门贝尔奶酪咖喱饭\n日々は過ぎれど、飯うまし\n\n白洋葱碎、香肠碎、玉米粒、豌豆、胡萝卜粒、生米、咖喱、番茄酱、苹果汁、酱油，浸泡30分钟。\n加入少量黄油，大火煮沸，转小火焖煮15分钟。\n放入一块卡门贝尔奶酪，继续焖15分钟。\n不爱吃温泉蛋，收工。\n\n\n水不宜多，没过食材即可\n图里的是贝里奶酪，卡门贝尔奶酪的弱化版 : (\n\n\n\n蚂蚁上树\n\n红薯粉条用温水浸泡，开水焯烫一分钟，捞出沥水。\n加入少量酱油、少量食用油，拌匀。\n猪瘦肉切细末，温油下锅，小火，煸干水分后加料酒，再次煸去水分后加入少量酱油，炒至酥香。\n另起锅，炒香豆瓣酱、细姜末、蒜末，加入红薯粉条和匀，加入炒好的肉末和匀。\n加入蒜苗末、花椒粉、香油，和匀，起锅。\n\n\n第1步浸泡时间和粉条性质有关，从半小时到大半天都说得通，泡至变软、没有明显硬芯即可。\n焯水后的粉条可能会粘连在一起，随着温度降低，会逐渐变得容易分开。\n肉末宜细不宜粗。\n第4步下锅的油适当少些，油多了肉末挂不上。\n\n\n\n杂项\n刀口辣椒/花椒\n每次铡刀口辣椒都四处飞溅，打扫不易。可以用食品袋把焙香的干辣椒/花椒装起来，然后擀碎，再倒出来用刀铡。焙花椒面时同理。\n后续补充：还是搅碎机好用，时代变了！\n猪油\n\n猪板油切大块焯水。\n切均匀小块，凉水下锅，加大葱、去皮姜片，[加白酒、香料]，大火烧开，水蒸发得不多后转中小火。\n时间适当时把姜葱捞走，无水后可以开始边熬边往外捞油。\n\n高汤保存\n可以熬一大锅，最后收至极浓，放凉后分装到小袋中冷冻保存，逐份取用。\n关于牛肉\n加热牛肉的过程中，有几个重要的变化：\n\n肌球蛋白变性，结构变得松散，使得肌肉纤维不再那么紧密，口感由韧转嫩。此过程在50℃左右开始发生。\n肌动蛋白变性收缩，变得致密，并且会把水分挤出，使口感变得干柴。此过程在66℃左右开始发生。\n结缔组织中的胶原蛋白转化为明胶，口感由韧转润。此过程相当缓慢。\n\n对火候的把控实际上就是寻找这几个过程的平衡点。\n一般而言，在煎牛排/烤肉时，至少要充分地进行第一个过程后，牛肉才处于“吃得动”的状态；与此同时，需要避免第二个过程过度进行，导致口感干柴。\n第三个过程在煎烤这种短时间的烹饪过程中发生得很少。因此煎烤的牛肉最好选择结缔组织比较少的部位。特别地，牛腩中的筋膜基本是结缔组织，需要长时间的炖煮才能充分转化。\n依靠截面的颜色来判断熟度/火候是完全不够的，因为肌红蛋白呈现的颜色只能反映其达到过的温度，而不能反映在此温度是否维持了足够长的时间。换言之，即使牛肉中心来到了52℃附近，切面颜色看起来是完美的三分熟，若是静置不足，牛肉内部的变化来不及进行，仍会吃起来过生。\n脂肪丰富且分布均匀的牛肉适合更高的熟度。一是因为脂肪可以弥补水分的损失，让它吃起来不干；二是因为脂肪本身如果温度不够，也不能充分融化并释放出香味，反倒不美。\n狮子头\n如果需要配肥瘦比，瘦肉部分千万别用过嫩的肉（如小里脊），口感会粉粉的，很糟糕。\n茶泡饭\n只需要煮饭和烧水，摆烂用。\n米饭，盐，拌饭酱油，葱花，白芝麻，海苔丝，腌渍的话梅，乌龙茶。"},"articles/2024.05.18.Bilinear-Interpolation-Precision":{"title":"硬件纹理插值的精度问题","links":[],"tags":["Graphics"],"content":"在GPU硬件提供的纹理线性插值中，与具体硬件相关地，插值系数的精度可能相当有限。譬如，CUDA文档明确指出其插值系数以9bits定点数存储（文档链接），其中8bits是分数位。\n本文代码\n来做个小实验。在Rtrc中构造一个简单的一维纹理，宽度为2，纹素值为[0.0, 1.0]——\nconst float texData[2] = { 0, 1 };\ntexture_ = GetDevice()-&gt;CreateAndUploadTexture(RHI::TextureDesc\n{\n    .dim    = RHI::TextureDimension::Tex1D,\n    .format = RHI::Format::R32_Float,\n    .width  = 2,\n    .usage  = RHI::TextureUsage::ShaderResource\n}, texData, RHI::TextureLayout::ShaderTexture);\n它在PIX中长这样：\n\n接下来，我们在屏幕上画一条被细分为1024个小段的水平线段，在shader中用x坐标采样这个纹理的中间部分，sampler使用硬件提供的线性插值，把采样结果转换为顶点的y坐标。不出所料，画出的结果不是一条从左往右斜向上的直线，而是阶梯状的：\n\n遇到相关问题时，读多个纹素值，然后手工插值即可。"},"articles/2024.06.15.Intrinsic-Delaunay-Triangulation":{"title":"Intrinsic Delaunay Triangulation","links":[],"tags":["Graphics"],"content":"参考：\nGeometry Processing with Intrinsic Triangulations\nNavigating Intrinsic Triangulations\nA Laplacian for Nonmanifold Triangle Meshes\n容易实现，效果还好，太帅了。\nDelaunay Triangulation\n所谓Delaunay triangulation，是指对triangulation（三角剖分）中的任意一个三角形ABC，其外接圆内都不包含任何A,B,C以外的顶点。当然，这里的上下文是二维平面上的triangulation。\n这个定义最为常见，但不便于计算，来看另一个等价的定义。对相邻的三角形ABC,BCD，如果有：\n∠BAC+∠BDC≤π\n就称边BC满足Delaunay condition。如果triangulation中所有的非边界边都满足此条件，则称它是一个Delaunay triangulation。\n给定任意triangulation，可以通过以下算法在不改变形状和顶点位置的前提下将其转换为一个Delaunay triangulation：\nwhile there exists an edge e that doesn&#039;t satisfy the Delaunay condition:\n    let ABC and BCD be the triangles containing e\n    replace edge BC with AD # this is called &#039;edge flip&#039;\n考虑把全体三角形的内角值进行非降序排序得到的向量，以及这些向量之间由词法序定义的全序关系。在上述算法的每次迭代中，triangulation的内角向量单调递增，故此算法必然可以停机。由停机条件可知最终得到的是一个Delaunay triangulation。\nIntrinsic Triangulation\n在二维情形下，edge flip只会改变内部的connectivity，不会改变geometry。但三维情形下就不一样了，当某条边两侧的三角形不共面时，这条边代表了一个实实在在的几何特征。如果还是遵照上面的算法，肆意使用edge flip，就会改变几何形状：\n\n这归根到底是因为顶点之间的connectivity和geometry之间耦合了。那如果我们强行让它们解耦，允许connectivity edge和geometry edge不一致，就会变成这样：\n\n这毫无疑问破坏了triangulation原本和geometry之间的一致性，这种不一致会导致本来正确的算法变得错误。\n有没有什么属性是在这种不一致下得以被保留的呢？如果要计算的量是“intrinsic property”，只依赖于“仍然正确的部分”，那么这些算法就可以继续在这种离谱的triangulation上运行。\n事实上，测地距离不受intrinsic edge flip的影响。用测地距离衡量长度（进而可以用内角表示方向），足以构建出一大堆算法了。最典型的莫过于Laplace Beltram算子，基于新triangulation构造的Laplace matrix仍然是一个∣V∣×∣V∣的矩阵，用法和老版本一样，区别则是它是基于Delaunay triangulation构造的，其中所有的非对角元素都非负，鲁棒性远超旧版。\n需要注意的是，在intrinsic triangulation的语境下，我们只能保存和使用那些“正确”的量，譬如内角和边长。这里的“边”也不能理解成顶点间的直线段，而是intrinsic edge，它在geometry上很可能对应了一条折线。\nTufted Triangulation\nTriangle mesh某种意义上是一个“壳”，或者说只有当它像个壳时，很多计算才有意义，不像壳的triangle mesh（比如有non-manifold edge，或者像莫比乌斯环那样不是orientable）则常常被各种算法拒绝。\n在遇到non-manifold edge时，如果我们赋予壳一个无限小的厚度，把它进行一个connectivity意义下的挤出操作，就能得到一个合理的triangulation了。\n\n类似的操作也可以用在boundary edge上，想象我们可以越过boundary，跑到mesh的另一侧去，给另一侧也构建对应的triangulation，它和原本的triangulation在boundary edge处连在一起。如此一来，我们获得了对boundary edge做intrinsic edge flip的能力，可以进一步提高很多算法的鲁棒性。"},"articles/2024.06.25.Differential-Operators-for-Triangle-Mesh":{"title":"Discrete Differential Operators for Triangle Mesh","links":[],"tags":["Graphics"],"content":"Hat Function\n对一个有∣V∣个顶点的三角形mesh，定义∣V∣个对应的基函数，每个函数ϕv​和一个顶点v对应。ϕv​的值由下式定义：\nϕv​(v)ϕv​(w)ϕv​(p)​:=1:=0,:=ϕv​(i)Bi​(p)+ϕv​(j)Bj​(p)+ϕv​(k)Bk​(p),​w∈V−{v}p∈triangle ijk,p∈/V​\n其中Bi​(p)是点p重心坐标（barycentric coordinate）的i分量。简而言之，ϕv​在顶点v处为1，在其他顶点处为0，在非顶点处则按其所处三角形的重心坐标对三个顶点进行插值。\n\n（图片来自CS 15-458/858: Discrete Differential Geometry. Keenan Crane）\n我们可以用这些ϕv​的加权和来近似其他的复杂函数u：\nu^=v∑​xv​ϕv​\n这就是“仅以顶点处的值构成的向量来表示整个函数”的几何解释。\nLaplacian\nCotan Formula\n给定triangle mesh M上的方程：\nΔu=f\n显然：\n∀ triangle D∈M,   ∀v∈V,   ∫D​Δuϕv​dA=∫D​fϕv​dA\n此时根据green’s first identity，有：\n∫D​Δuϕv​dA=−∫D​∇u⋅∇ϕv​dA+∫∂D​ϕv​∇u⋅ndl\n假设我们的mesh是无边界的，那么对∂D的每条边，都一定有另一个三角形的一条边与之重合，且法线相反。因此，当我们同时考虑meshM上所有的三角形时，上式右侧的第二项可以被抵消掉，只剩下：\n∫M​Δuϕv​dA=−∫M​∇u⋅∇ϕv​dA=−D∑​∫D​∇u⋅∇ϕv​dA\nu可以被近似表示为∑i​xi​ϕi​，于是：\n∫M​Δuϕv​dA=−D∑​∫D​∇(i∑​xi​ϕi​)⋅ϕv​dA=−D∑​i∑​∫D​∇ϕi​⋅∇ϕv​dA\n注意到：\n∫D​∇ϕi​⋅∇ϕv​dA=⎩⎨⎧​21​(cot⟨ji​,jk​⟩+cot⟨ki,kj​⟩),−21​cot⟨ji​,jv​⟩,0,​i=v,D=ijki=v,D=ijvotherwise​\n从而：\n∫M​Δuϕv​dA=21​i∈N(v)∑​(cot⟨ji​,jv​⟩+cot⟨ki,kv⟩)(xi​−xv​)\n这就得到了著名的cotan公式。基于此，对每个顶点v，都有：\n21​i∈N(v)∑​(cot⟨ji​,jv​⟩+cot⟨ki,kv⟩)(xi​−xv​)=∫M​fϕv​dA\nArea Matrix\n注意我们对u和f的离散化方式并不相同，u被“分解”为一系列ϕ的加权和，f则是被“投影”到了这些ϕ上。这两种离散化都说得过去，如果想看看它们的关系，可以考虑将f也表示为：\nf=i∑​yi​ϕi​\n在与i相邻的某个三角形ijk中，容易证明：\n∫Dijk​​fϕi​dA=Aijk​(61​yi​+121​yj​+121​yk​)\n其中Aijk​是三角形ijk的面积。\n如果用矩阵来表示yi​和∫fϕi​之间的关系，我们会发现它是对称的，但不是对角的。如果我们假定yi​,yj​,yk​的差异很小，那么上面的积分结果可以被近似为(1/3)Aijk​yi​，从而将其矩阵转换为对角阵——\nAii​=31​triangle ijk∑​Aijk​\n汇总\n我们把cotan公式的矩阵表示记作LC​，在实践中，常常把A−1和LC​预乘在一起，记作L=A−1LC​。这样一来，原方程Δu=f被转换为了：\nLx=y\n可以证明L是半正定的，十分便于求解。\nGradient\n\n给定三角形ijk（i,j,k以顺时针方向给出）各顶点的标量值ui​,uj​,uk​，以重心坐标指定其内部每个点对应的u：\nu(p)=Bi​(p)ui​+Bj​(p)uj​+Bk​(p)uk​\n此时：\n∇u=ui​∇Bi​+uj​∇Bj​+uk​∇Bk​\n接下来看看单独的∇Bi​。显然∇Bi​的方向是(pj​−pk​)⊥，⊥表示将向量pj​−pk​逆时针旋转90°，垂直于线段jk​且朝向i。此外，Bi​在jk​上为0，在i处为1，故∇Bi​的大小为1除以i到jk​的距离——\n∣∇Bi​∣=2Aijk​∣pj​−pk​∣​\n其中Aijk​是三角形ijk的面积。\n综合起来有：\n∇u​=ui​∇(1−Bj​−Bk​)+uj​∇Bj​+uk​∇Bk​=(uj​−ui​)∇Bj​+(uk​−ui​)∇Bk​=(uj​−ui​)2Aijk​(pk​−pi​)⊥​+(uk​−ui​)2Aijk​(pi​−pj​)⊥​​\nDivergence\n给定一个以三角形为单元的分段线性向量场X，且X的取值总是位于对应三角形所在的平面上（之前所讨论的梯度场就是一个绝佳的例子），来看看如何定义顶点处的散度。\n\n考虑与顶点i直接相连的一圈三角形，记其中的一个为ijk，进行研究。设i到jk的距离为h，取平行于jk​、与i相距h/2的线段xy​作为ijk上的边界，则ijk对i的散度的贡献为：\n∇ijk​⋅X=∣px​−py​∣(Xijk​⋅∣pk​−pj​∣(pk​−pj​)⊥​)=21​X⋅(pk​−pj​)⊥\n现记e1​=pj​−pi​,e2​=pk​−pi​，θ1​为j处的内角，θ2​为i处的内角，考虑方程：\nαe1​+βe2​=(pk​−pj​)⊥\n将它分解到jk​和jk​⊥这两个方向上：\nα∣e1​∣cosθ1​α∣e1​∣sinθ1​+β∣e2​∣sinθ2​​=β∣e2​∣cosθ2​=∣e1​∣cosθ1​+∣e2​∣cosθ2​​\n联立∣e1​∣sinθ1​=∣e2​∣sinθ2​，解得：\nα=cotθ2​      β=cotθ1​\n因此ijk对散度的贡献也可以写成：\n∇ijk​⋅X=21​(e1​cotθ2​+e2​cotθ1​)⋅X\n遍历与i相邻的所有三角形，将它们的上式值相加即可得到顶点i的散度。\n这里我们遗留了一个问题——为什么积分的边界被取作与i相距h/2的线段xy​？这其实不是很有道理，因为和连续情形下的散度对不上。但如果从“laplace=div grad”的角度出发，则可以给出一个解释。对包含顶点i的一圈区域D使用Stokes公式：\n∫∂D​X⋅ndl=∫D​∇⋅XdA\n现假设X是某个标量函数u的梯度∇u，则上式右侧是Δu在D上的积分。此时，考虑上式在三角形ijk中的部分：\n∫∂D​X⋅ndl=∫∂D​((uj​−ui​)2Aijk​(pk​−pi​)⊥​+(uk​−ui​)2Aijk​(pi​−pj​)⊥​)⋅ndl\n如果把∂D取成三角形的中线，那么：\n∫∂D​X⋅ndl​=4Aijk​1​((uj​−ui​)(pk​−pi​)⊥⋅(pk​−pj​)⊥+(uk​−ui​)(pi​−pj​)⊥⋅(pk​−pj​)⊥)=4Aijk​1​((uj​−ui​)​ki​​kj​​cos⟨ki,kj​⟩+(uk​−ui​)​ij​​​kj​​cos⟨ji​,jk​⟩)=4Aijk​1​((uj​−ui​)2Aijk​cot⟨ki,kj​⟩+(uk​−ui​)2Aijk​cot⟨ji​,jk​⟩)=21​((uj​−ui​)cot⟨ki,kj​⟩+(uk​−ui​)cot⟨ji​,jk​⟩)​\n由此可见，把∂D取成包含i的一圈三角形的中线，就能使得“laplace=div grad”成立。我们是在人为地构造梯度和cotan laplacian之间的桥梁，并把构造的结果称之为散度。"},"articles/2024.06.29.Heat-Method":{"title":"Heat Method","links":["articles/2024.06.25.Differential-Operators-for-Triangle-Mesh"],"tags":["Graphics"],"content":"给一个triangle mesh M，以及上面的一组点S，求M上其他所有顶点到S的测地距离。\n参考资料：The Heat Method for Distance Computation\n本文代码：Rtrc Sample 15.HeatMethod\nHeat Method\n理论\n如果以某个点x为热源在M表面做heat diffusion，将经过时间t后y点的热量记作kt,x​(y)，那么根据Varadhan’s formula，k和测地距离之间有如下关系：\nϕ(x,y)=t→0lim​−4tlogkt,x​(y)​\n换言之，我们可以用一个极短的时间步长模拟M上的热传输过程，然后用上式计算测地距离。然而当距离较大时，Varadhan’s formula会对数值精度提出不切实际的要求。因此这个做法仅在理论上正确，实践中没什么人用。\nKeenan Crane大佬注意到：尽管k本身的数值精度不足以支撑Varadhan’s formula，但k的梯度方向仍然是相对准确的，而∇k的方向正好就是∇ϕ的方向。同时根据测地距离的定义，∣∇ϕ∣=1。因此，我们可以从k计算出∇ϕ，而从∇ϕ还原ϕ的过程就顺理成章了。\n综上所述，可以用以下算法计算ϕ：\n\n选取一个较小的t，计算kt,x​\n计算kt,x​的梯度方向X=∇kt,x​/∣∇kt,x​∣，这其实就是∇ϕ\n取X的散度，解Poisson方程Δϕ=∇⋅X，得到ϕ\n\n这里细化第一步。Heat equation长这样：\n∂t∂u​=Δu\n取一个很小的时间步长，用backward Euler模拟一轮：\ntu1​−u0​​=Δu1​\n也就是：\n(1−tΔ)u1​=u0​\nu0​是初始热源，u1​则是我们所需要的k。Triangle mesh上的Δ算子可以参见我之前的博文Differential Operators for Triangle Mesh。\n效果\n我们在兔子上选一个点，首先模拟heat diffusion，得到k：\n\n利用离散梯度算子把k转换成per-face的梯度并归一化，得到∇ϕ：\n\n对∇ϕ求散度：\n\n其中红色表示散度为正，蓝色为负。\n最后，解poisson方程得到ϕ，其分段可视化结果为：\n\n这就得到了兔子上每一点到起始点的测地距离。\n也可以选取多个源点，乃至连成线：\n\n标量传输\n当源点S不仅包含一个点，而是包含一条曲线、乃至一片区域时，我们可能不仅想知道其他点到S的测地距离，还想知道每个点和S中的哪个点最近。\n换言之，如果给S中的每个点染个颜色，让这些颜色沿着测地线传播，那么我们想要求出mesh上每个位置最终的颜色。\n首先，让我们给每个源点设定初始值：\nui​=predefined value for i,    i∈S\nu沿着测地线传输，也就是说它在测地线方向上不会发生变化——\n∇u⋅∇ϕ=0\n在实践中，我们对每个三角形D，都可以从未知量u构建D上的∇u；而D上的∇ϕ是之前的heat method中已经计算过的。这样一来，我们就获得了方程数量等同于三角形数量的线性方程组，构成关于u的稀疏线性系统。\n在∣S∣&gt;1时，triangle mesh中的面数不会少于未知顶点数，再加上在各种离散化和数值误差，我们的线性方程组可以被看成是overdetermined。此时，可以用最小二乘法得到一组合理的u值。\n我们把上面那条曲线形状的S的左上端染成蓝色，右下端染成红色，中间插个值，然后让颜色沿着测地线传输，得到的结果如下：\n\n而如果把这里的S做个arc-length parameterzation，把结果沿着测地线传播出去，然后将测地距离和传播结果分别作为UV的两个通道可视化出来，就能得到下面的结果：\n\n如果我们只关注离S较近的区域，那么这应该是个不错的局部参数化方法，拓展版的DEM。"},"articles/2024.07.25.Differential-Geometry-Note":{"title":"Differential Geometry Note","links":[],"tags":["Mathematics"],"content":"Note. 如非专门说明，以下涉及到的函数均为任意阶可导。\n方向导数\nf在p点沿v的方向导数：\nvp​[f]=dtd​f(p+tv)\nTangent Map\n设F:Rn→Rm，对Rn中的tangent vector vp​，定义tangent map F∗，它将vp​映射至F(p)∈Rm处的tangent vector，向量部分则是：\nt→0lim​tF(p+tv)−F(p)​\n即：在p处向v方向挪一点，对应地在经F映射后会向哪个方向挪多少。显然tangent map对向量部分是线性的。\n1-form\n1-form：定义在Rn中的全体tangent vector上，在每一点的tangent vector间满足线性性的函数：\nϕ(avp​+bwp​)=aϕ(vp​)+bϕ(wp​)\nDifferential\n1-form df：\ndf(vp​):=vp​[f]\nExterior derivative:\nd(∑fi​dxi​)=∑dfi​∧dxi​\nRegular Mapping\n称映射F:Rn→Rm是regular的，当且仅当对任意p∈Rn，F∗p​是一一对应的。根据tangent map的线性性，以下三句话互相等价：\n\nF∗p​是一一对应的\nF∗(vp​)=0⇒vp​=0\nF在p处的Jacobian矩阵秩为n\n\nFrenet formulas\n对unit-speed curve：\nT′N′B′​==−κT=​​+κN−τN​+τB​\n对非unit-speed curve，右边所有项乘以速率v即可。\n对R3中的regular curve α：\nTNBκτ​=∣α′∣α′​=N×T=α′×α′′α′×α′′​=∣α′∣3∣α′×α′′∣​=∣α′×α′′∣2(α′×α′′)⋅α′′′​​\nCovariant Derivatives\n设W是vector field，v是p处的tangent vector，那么：\n∇v​W=W(p+tv)′(0)\n可以认为这就是向量版的方向导数，毕竟：\n∇v​W=∑v[wi​]Ui​(p)\nConnection Forms\n考虑空间中的frame field E1​,E2​,E3​，把它沿tangent vector v的变化率用它自己表达出来：\n∇v​Ei​=j∑​ωij​(v)Ej​(p)\n其中ωij​(v):=∇v​Ei​⋅Ej​(p)，可以证明ωij​是1-form，这些1-form被称为E1​,E2​,E3​的connection forms。\n由此衍生的connection equation：\n∇V​Ei​=j∑​ωij​(V)Ej​\n注意到ωij​=−ωji​，由此可以把R3中的9个ωij​归并成三个：\nω=​0−ω12​−ω13​​ω12​0−ω23​​ω13​ω23​0​​\n注意frenet formula与此式是一致的。\n记Ei​=∑j​aij​Uj​，容易证明：\nωij​=k∑​ajk​daik​\n或者说：\nω=dAAT\n其中dA是对A=[aij​]逐元素求differential。\nDual 1-Forms\nE1​,E2​,E3​的dual 1-forms θ1​,θ2​,θ3​如下定义：\nθi​(v)=v⋅Ei​(p)\nθi​(v)丈量了v在Ei​方向上有多大。\nCartan Structural Equations\n根据dual 1-forms的定义，可以把connection equations改写成：\ndθi​=j∑​ωij​∧θj​\n称为the first structural equation。The second structural equation则是：\ndωij​=k∑​ωik​∧ωkj​\nIsometry\n如果对任意F:R3→R3对任意p,q∈Rn，都满足：\nd(F(p),F(q))=d(p,q)\n就称F是R3中的一个等距映射（isometry）。\n省流：旋转C + 平移T，渲染人再熟悉不过了。\nIsometry的tangent map：\nF∗(vp​)=C(v)F(p)​\n其中C是F的旋转部分，也就是平移部分作用在p上，旋转部分作用在方向v上。\nSurface\nPatch. One-to-one regular mapping\nProper Patch. 反函数连续的patch\nSurface. R3的子集M，对M中任意一点p，均存在包含p在M中的邻域的proper patch\n隐式定义的表面：设M是方程g(x,y,z)=c的解集，若∀p∈M,∇g(p)=0，则M是一个surface。（当然，需要排除一些degenerate cases，比如M为空）\nParameterization\n设x:D→R3是regular mapping，且x(D)在表面M中，称x是x(D)的一个参数化（parameterization）。\nPartial Velocity\n固定patch x(u,v)中的u或v，可以得到两族曲线，每条曲线的velocity vector分别被记作xu​和xv​：\nxu​(u0​,v0​)xv​(u0​,v0​)​=t→0lim​tx(u0​+t,v0​)−x(u0​,v0​)​=t→0lim​tx(u0​,v0​+t)−x(u0​,v0​)​​\n若x=(x1​,x2​,x3​)，显然两个partial velocity可以被表示为：\nxu​xv​​=[∂u∂x1​​​∂u∂x2​​​∂u∂x3​​​]=[∂v∂x1​​​∂v∂x2​​​∂v∂x3​​​]​\n容易证明x是regular的当且仅当xu​×xv​总是不为0，或者说它两不平行。\nNormal\n若M:g=c是surface，那么∇g=0是M上的normal vector field，即∇g(p)垂直于p处的tangent plane。\nDirectional Derivative on Surface\n令v是表面M上点p处的一个tangent vector，f是M上的函数，对所有M上在点p处初速度为v的曲线α，下式的值相同：\ndtd​(fα)(0)\n将此值定义为v[f]。\n就是让f往v方向挪动一点点，然后看f变化了多少，和普通的方向导数没啥区别，只是使用曲线作为叙述的语言，方便在surface上处理。\n2-Form\n表面M上的2-form η是定义在M上的全体tangent vector pair上的实值函数，满足：\n\nη(v,w)对v和w都是线性的\nη(v,w)=−η(w,v)\n\n容易看到η(v,v)=0。此外：\nη(av+bw,cv+dw)=​ac​bd​​η(v,w)\nWedge Product\n设ϕ和ψ都是M上的1-form，定义：\n(ϕ∧ψ)(v,w):=ϕ(v)ψ(w)−ϕ(w)ψ(v)\nExterior Drivative\n设ϕ是M上的1-form，定义：\ndϕ(xu​,xv​):=∂u∂​(ϕ(xv​))−∂v∂​(ϕ(xu​))\n此定义对不同的参数化是一致的。\n称ϕ是closed的，若dϕ=0；称ϕ是exact的，若ϕ是某个ξ的dξ。\nInverse\n设x:D→M是个patch，记x−1(p)=(u~(p),v~(p))，则：\nu~(x(u,v))v~(x(u,v))​=u=v​\n并且：\ndu~(xu​)dv~(xu​)​=1,=0,​du~(xv​)dv~(xv​)​=0=1​\n给定1-form ϕ和2-form η，有：\nϕη​=ϕ(xu​)du~+ϕ(xv​)dv~=η(xu​,xv​)du~∧dv~​\nMapping of Surfaces\n设M,N是surface，F:M→N是从M到N的函数，如果对每个M的patch x和N的patch y，y−1Fx都是可微的，那么称F是可微的，且称其为mapping of surfaces。\n容易证明F∗保留速度（preserves velocities）。曲线α在某点的速度为α′，那么：\n(F(α))′=F∗(α′)\n由此：\nF∗(xu​)F∗(xv​)​=yu​=yv​​\nDiffeomorphism\n若mapping F:M→N有对应的逆F−1:N→M，就称F为diffeomorphism（微分同胚）。\n类似反函数定理：设F:M→N是mapping of surfaces，如果F∗在p处是linear isomorphism的（或者说F在p处是regular的），那么存在p的某个邻域N使得F在N上的部分是一个diffeomorphism。由此，如果F整个都是regular的，那么F是diffeomorphism。\nMapping on Differential Forms\n设F:M→N是mapping of surfaces，ϕ和η分别是N上的1-form和2-form，定义：\n(F∗ϕ)(v)(F∗η)(v,w)​=ϕ(F∗v)=η(F∗v,F∗w)​\n可以证明：\nF∗(ξ+η)F∗(ξ∧η)F∗(dξ)​=F∗ξ+F∗η=F∗ξ∧F∗η=d(F∗ξ)​\nLine Integral\n∫α​ϕ:=∫[a,b]​α∗ϕ=∫ab​ϕ(α′(t))dt\nϕ是定义在曲线α上的，α∗ϕ是将它“pullback”到参数区间[a,b]上来进行积分：\n(α∗ϕ)(U(t))=ϕ(α∗(U(t)))=ϕ(α′(t))\nFundamental Theorem of Calculus\n∫α​df=f(q)−f(p)     where  q=α(b),p=α(a),α=[a,b]\n2-form Integral\n∬x​η:=∬R​x∗η=∫ab​∫cd​η(xu​,xv​)dudv\nStokes’ Theorem\n∬x​dϕ=∫∂x​ϕ"},"articles/2025.04.06.wakayama":{"title":"和歌山","links":[],"tags":["Life"],"content":"\n\nR1 [和歌山城]\nR2 [白浜]\nR3 [白浜]\nR4 [那智勝浦]\nR5 [那智勝浦]\n"},"articles/2025.07.22.toyohasi-no-natu":{"title":"豊橋の夏","links":[],"tags":["Life"],"content":"\n\nR1 [豊橋駅]\nR2 [道の駅もっくる新城]\nR3 [豊川]\n"},"articles/2025.09.01.tokyo-to-kamakura":{"title":"東京 & 鎌倉","links":[],"tags":["Life"],"content":"\n\nR1 [鎌倉] [円覚寺]\nR2 [鎌倉] [江ノ島]\nR3 [鎌倉]\nR4 [東京] [うしごろ表参道]\nR5 [東京] [晴空塔]\nR6 [東京] [六本木ヒルズ &amp; 渋谷]\n\n关于うしごろ表参道：没啥大毛病，但与其说是烧肉店，不如说是以牛肉为主题的漂亮饭。"},"articles/index":{"title":"汇总","links":[],"tags":[],"content":""},"categories/Article":{"title":"文章列表","links":[],"tags":[],"content":"离开校园后的写作。"},"categories/Life":{"title":"无意义","links":[],"tags":[],"content":""},"categories/Note":{"title":"个人笔记","links":[],"tags":[],"content":"个人备忘，不要在意可读性。"},"categories/Old":{"title":"旧文归档","links":[],"tags":[],"content":"怀念通宵debug的日子。"},"index":{"title":"Automorphism","links":["categories/Article","categories/Note","categories/Old","categories/Life"],"tags":[],"content":"欢迎来到AirGuanZ的个人主页！\n文章             笔记            旧文归档            生活            GitHub"}}